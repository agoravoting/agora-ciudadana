(function(window, undefined) {
    var rootjQuery, readyList, document = window.document, location = window.location, navigator = window.navigator, _jQuery = window.jQuery, _$ = window.$, core_push = Array.prototype.push, core_slice = Array.prototype.slice, core_indexOf = Array.prototype.indexOf, core_toString = Object.prototype.toString, core_hasOwn = Object.prototype.hasOwnProperty, core_trim = String.prototype.trim, jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context, rootjQuery);
    }, core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source, core_rnotwhite = /\S/, core_rspace = /\s+/, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/, rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, rvalidchars = /^[\],:{}\s]*$/, rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g, rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g, rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function(all, letter) {
        return (letter + "").toUpperCase();
    }, DOMContentLoaded = function() {
        if (document.addEventListener) {
            document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
            jQuery.ready();
        } else if (document.readyState === "complete") {
            document.detachEvent("onreadystatechange", DOMContentLoaded);
            jQuery.ready();
        }
    }, class2type = {};
    jQuery.fn = jQuery.prototype = {
        constructor: jQuery,
        init: function(selector, context, rootjQuery) {
            var match, elem, ret, doc;
            if (!selector) {
                return this;
            }
            if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            }
            if (typeof selector === "string") {
                if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                    match = [ null, selector, null ];
                } else {
                    match = rquickExpr.exec(selector);
                }
                if (match && (match[1] || !context)) {
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        doc = context && context.nodeType ? context.ownerDocument || context : document;
                        selector = jQuery.parseHTML(match[1], doc, true);
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            this.attr.call(selector, context, true);
                        }
                        return jQuery.merge(this, selector);
                    } else {
                        elem = document.getElementById(match[2]);
                        if (elem && elem.parentNode) {
                            if (elem.id !== match[2]) {
                                return rootjQuery.find(selector);
                            }
                            this.length = 1;
                            this[0] = elem;
                        }
                        this.context = document;
                        this.selector = selector;
                        return this;
                    }
                } else if (!context || context.jquery) {
                    return (context || rootjQuery).find(selector);
                } else {
                    return this.constructor(context).find(selector);
                }
            } else if (jQuery.isFunction(selector)) {
                return rootjQuery.ready(selector);
            }
            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context;
            }
            return jQuery.makeArray(selector, this);
        },
        selector: "",
        jquery: "1.8.3",
        length: 0,
        size: function() {
            return this.length;
        },
        toArray: function() {
            return core_slice.call(this);
        },
        get: function(num) {
            return num == null ? this.toArray() : num < 0 ? this[this.length + num] : this[num];
        },
        pushStack: function(elems, name, selector) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            if (name === "find") {
                ret.selector = this.selector + (this.selector ? " " : "") + selector;
            } else if (name) {
                ret.selector = this.selector + "." + name + "(" + selector + ")";
            }
            return ret;
        },
        each: function(callback, args) {
            return jQuery.each(this, callback, args);
        },
        ready: function(fn) {
            jQuery.ready.promise().done(fn);
            return this;
        },
        eq: function(i) {
            i = +i;
            return i === -1 ? this.slice(i) : this.slice(i, i + 1);
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        slice: function() {
            return this.pushStack(core_slice.apply(this, arguments), "slice", core_slice.call(arguments).join(","));
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        push: core_push,
        sort: [].sort,
        splice: [].splice
    };
    jQuery.fn.init.prototype = jQuery.fn;
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[1] || {};
            i = 2;
        }
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {};
        }
        if (length === i) {
            target = this;
            --i;
        }
        for (;i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        noConflict: function(deep) {
            if (window.$ === jQuery) {
                window.$ = _$;
            }
            if (deep && window.jQuery === jQuery) {
                window.jQuery = _jQuery;
            }
            return jQuery;
        },
        isReady: false,
        readyWait: 1,
        holdReady: function(hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        ready: function(wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            if (!document.body) {
                return setTimeout(jQuery.ready, 1);
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [ jQuery ]);
            if (jQuery.fn.trigger) {
                jQuery(document).trigger("ready").off("ready");
            }
        },
        isFunction: function(obj) {
            return jQuery.type(obj) === "function";
        },
        isArray: Array.isArray || function(obj) {
            return jQuery.type(obj) === "array";
        },
        isWindow: function(obj) {
            return obj != null && obj == obj.window;
        },
        isNumeric: function(obj) {
            return !isNaN(parseFloat(obj)) && isFinite(obj);
        },
        type: function(obj) {
            return obj == null ? String(obj) : class2type[core_toString.call(obj)] || "object";
        },
        isPlainObject: function(obj) {
            if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            try {
                if (obj.constructor && !core_hasOwn.call(obj, "constructor") && !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                    return false;
                }
            } catch (e) {
                return false;
            }
            var key;
            for (key in obj) {}
            return key === undefined || core_hasOwn.call(obj, key);
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        error: function(msg) {
            throw new Error(msg);
        },
        parseHTML: function(data, context, scripts) {
            var parsed;
            if (!data || typeof data !== "string") {
                return null;
            }
            if (typeof context === "boolean") {
                scripts = context;
                context = 0;
            }
            context = context || document;
            if (parsed = rsingleTag.exec(data)) {
                return [ context.createElement(parsed[1]) ];
            }
            parsed = jQuery.buildFragment([ data ], context, scripts ? null : []);
            return jQuery.merge([], (parsed.cacheable ? jQuery.clone(parsed.fragment) : parsed.fragment).childNodes);
        },
        parseJSON: function(data) {
            if (!data || typeof data !== "string") {
                return null;
            }
            data = jQuery.trim(data);
            if (window.JSON && window.JSON.parse) {
                return window.JSON.parse(data);
            }
            if (rvalidchars.test(data.replace(rvalidescape, "@").replace(rvalidtokens, "]").replace(rvalidbraces, ""))) {
                return new Function("return " + data)();
            }
            jQuery.error("Invalid JSON: " + data);
        },
        parseXML: function(data) {
            var xml, tmp;
            if (!data || typeof data !== "string") {
                return null;
            }
            try {
                if (window.DOMParser) {
                    tmp = new DOMParser();
                    xml = tmp.parseFromString(data, "text/xml");
                } else {
                    xml = new ActiveXObject("Microsoft.XMLDOM");
                    xml.async = "false";
                    xml.loadXML(data);
                }
            } catch (e) {
                xml = undefined;
            }
            if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
                jQuery.error("Invalid XML: " + data);
            }
            return xml;
        },
        noop: function() {},
        globalEval: function(data) {
            if (data && core_rnotwhite.test(data)) {
                (window.execScript || function(data) {
                    window["eval"].call(window, data);
                })(data);
            }
        },
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function(obj, callback, args) {
            var name, i = 0, length = obj.length, isObj = length === undefined || jQuery.isFunction(obj);
            if (args) {
                if (isObj) {
                    for (name in obj) {
                        if (callback.apply(obj[name], args) === false) {
                            break;
                        }
                    }
                } else {
                    for (;i < length; ) {
                        if (callback.apply(obj[i++], args) === false) {
                            break;
                        }
                    }
                }
            } else {
                if (isObj) {
                    for (name in obj) {
                        if (callback.call(obj[name], name, obj[name]) === false) {
                            break;
                        }
                    }
                } else {
                    for (;i < length; ) {
                        if (callback.call(obj[i], i, obj[i++]) === false) {
                            break;
                        }
                    }
                }
            }
            return obj;
        },
        trim: core_trim && !core_trim.call("﻿ ") ? function(text) {
            return text == null ? "" : core_trim.call(text);
        } : function(text) {
            return text == null ? "" : (text + "").replace(rtrim, "");
        },
        makeArray: function(arr, results) {
            var type, ret = results || [];
            if (arr != null) {
                type = jQuery.type(arr);
                if (arr.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow(arr)) {
                    core_push.call(ret, arr);
                } else {
                    jQuery.merge(ret, arr);
                }
            }
            return ret;
        },
        inArray: function(elem, arr, i) {
            var len;
            if (arr) {
                if (core_indexOf) {
                    return core_indexOf.call(arr, elem, i);
                }
                len = arr.length;
                i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
                for (;i < len; i++) {
                    if (i in arr && arr[i] === elem) {
                        return i;
                    }
                }
            }
            return -1;
        },
        merge: function(first, second) {
            var l = second.length, i = first.length, j = 0;
            if (typeof l === "number") {
                for (;j < l; j++) {
                    first[i++] = second[j];
                }
            } else {
                while (second[j] !== undefined) {
                    first[i++] = second[j++];
                }
            }
            first.length = i;
            return first;
        },
        grep: function(elems, callback, inv) {
            var retVal, ret = [], i = 0, length = elems.length;
            inv = !!inv;
            for (;i < length; i++) {
                retVal = !!callback(elems[i], i);
                if (inv !== retVal) {
                    ret.push(elems[i]);
                }
            }
            return ret;
        },
        map: function(elems, callback, arg) {
            var value, key, ret = [], i = 0, length = elems.length, isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && (length > 0 && elems[0] && elems[length - 1] || length === 0 || jQuery.isArray(elems));
            if (isArray) {
                for (;i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret[ret.length] = value;
                    }
                }
            } else {
                for (key in elems) {
                    value = callback(elems[key], key, arg);
                    if (value != null) {
                        ret[ret.length] = value;
                    }
                }
            }
            return ret.concat.apply([], ret);
        },
        guid: 1,
        proxy: function(fn, context) {
            var tmp, args, proxy;
            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = core_slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context, args.concat(core_slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        access: function(elems, fn, key, value, chainable, emptyGet, pass) {
            var exec, bulk = key == null, i = 0, length = elems.length;
            if (key && typeof key === "object") {
                for (i in key) {
                    jQuery.access(elems, fn, i, key[i], 1, emptyGet, value);
                }
                chainable = 1;
            } else if (value !== undefined) {
                exec = pass === undefined && jQuery.isFunction(value);
                if (bulk) {
                    if (exec) {
                        exec = fn;
                        fn = function(elem, key, value) {
                            return exec.call(jQuery(elem), value);
                        };
                    } else {
                        fn.call(elems, value);
                        fn = null;
                    }
                }
                if (fn) {
                    for (;i < length; i++) {
                        fn(elems[i], key, exec ? value.call(elems[i], i, fn(elems[i], key)) : value, pass);
                    }
                }
                chainable = 1;
            }
            return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
        },
        now: function() {
            return new Date().getTime();
        }
    });
    jQuery.ready.promise = function(obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === "complete") {
                setTimeout(jQuery.ready, 1);
            } else if (document.addEventListener) {
                document.addEventListener("DOMContentLoaded", DOMContentLoaded, false);
                window.addEventListener("load", jQuery.ready, false);
            } else {
                document.attachEvent("onreadystatechange", DOMContentLoaded);
                window.attachEvent("onload", jQuery.ready);
                var top = false;
                try {
                    top = window.frameElement == null && document.documentElement;
                } catch (e) {}
                if (top && top.doScroll) {
                    (function doScrollCheck() {
                        if (!jQuery.isReady) {
                            try {
                                top.doScroll("left");
                            } catch (e) {
                                return setTimeout(doScrollCheck, 50);
                            }
                            jQuery.ready();
                        }
                    })();
                }
            }
        }
        return readyList.promise(obj);
    };
    jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    rootjQuery = jQuery(document);
    var optionsCache = {};
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.split(core_rspace), function(_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
        var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function(data) {
            memory = options.memory && data;
            fired = true;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            firing = true;
            for (;list && firingIndex < firingLength; firingIndex++) {
                if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                    memory = false;
                    break;
                }
            }
            firing = false;
            if (list) {
                if (stack) {
                    if (stack.length) {
                        fire(stack.shift());
                    }
                } else if (memory) {
                    list = [];
                } else {
                    self.disable();
                }
            }
        }, self = {
            add: function() {
                if (list) {
                    var start = list.length;
                    (function add(args) {
                        jQuery.each(args, function(_, arg) {
                            var type = jQuery.type(arg);
                            if (type === "function") {
                                if (!options.unique || !self.has(arg)) {
                                    list.push(arg);
                                }
                            } else if (arg && arg.length && type !== "string") {
                                add(arg);
                            }
                        });
                    })(arguments);
                    if (firing) {
                        firingLength = list.length;
                    } else if (memory) {
                        firingStart = start;
                        fire(memory);
                    }
                }
                return this;
            },
            remove: function() {
                if (list) {
                    jQuery.each(arguments, function(_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);
                            if (firing) {
                                if (index <= firingLength) {
                                    firingLength--;
                                }
                                if (index <= firingIndex) {
                                    firingIndex--;
                                }
                            }
                        }
                    });
                }
                return this;
            },
            has: function(fn) {
                return jQuery.inArray(fn, list) > -1;
            },
            empty: function() {
                list = [];
                return this;
            },
            disable: function() {
                list = stack = memory = undefined;
                return this;
            },
            disabled: function() {
                return !list;
            },
            lock: function() {
                stack = undefined;
                if (!memory) {
                    self.disable();
                }
                return this;
            },
            locked: function() {
                return !stack;
            },
            fireWith: function(context, args) {
                args = args || [];
                args = [ context, args.slice ? args.slice() : args ];
                if (list && (!fired || stack)) {
                    if (firing) {
                        stack.push(args);
                    } else {
                        fire(args);
                    }
                }
                return this;
            },
            fire: function() {
                self.fireWith(this, arguments);
                return this;
            },
            fired: function() {
                return !!fired;
            }
        };
        return self;
    };
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [ [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ], [ "notify", "progress", jQuery.Callbacks("memory") ] ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done(arguments).fail(arguments);
                    return this;
                },
                then: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var action = tuple[0], fn = fns[i];
                            deferred[tuple[1]](jQuery.isFunction(fn) ? function() {
                                var returned = fn.apply(this, arguments);
                                if (returned && jQuery.isFunction(returned.promise)) {
                                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                } else {
                                    newDefer[action + "With"](this === deferred ? newDefer : this, [ returned ]);
                                }
                            } : newDefer[action]);
                        });
                        fns = null;
                    }).promise();
                },
                promise: function(obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function() {
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                deferred[tuple[0]] = list.fire;
                deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function(subordinate) {
            var i = 0, resolveValues = core_slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function(i, contexts, values) {
                return function(value) {
                    contexts[i] = this;
                    values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
                    if (values === progressValues) {
                        deferred.notifyWith(contexts, values);
                    } else if (!--remaining) {
                        deferred.resolveWith(contexts, values);
                    }
                };
            }, progressValues, progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (;i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    jQuery.support = function() {
        var support, all, a, select, opt, input, fragment, eventName, i, isSupported, clickFn, div = document.createElement("div");
        div.setAttribute("className", "t");
        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
        all = div.getElementsByTagName("*");
        a = div.getElementsByTagName("a")[0];
        if (!all || !a || !all.length) {
            return {};
        }
        select = document.createElement("select");
        opt = select.appendChild(document.createElement("option"));
        input = div.getElementsByTagName("input")[0];
        a.style.cssText = "top:1px;float:left;opacity:.5";
        support = {
            leadingWhitespace: div.firstChild.nodeType === 3,
            tbody: !div.getElementsByTagName("tbody").length,
            htmlSerialize: !!div.getElementsByTagName("link").length,
            style: /top/.test(a.getAttribute("style")),
            hrefNormalized: a.getAttribute("href") === "/a",
            opacity: /^0.5/.test(a.style.opacity),
            cssFloat: !!a.style.cssFloat,
            checkOn: input.value === "on",
            optSelected: opt.selected,
            getSetAttribute: div.className !== "t",
            enctype: !!document.createElement("form").enctype,
            html5Clone: document.createElement("nav").cloneNode(true).outerHTML !== "<:nav></:nav>",
            boxModel: document.compatMode === "CSS1Compat",
            submitBubbles: true,
            changeBubbles: true,
            focusinBubbles: false,
            deleteExpando: true,
            noCloneEvent: true,
            inlineBlockNeedsLayout: false,
            shrinkWrapBlocks: false,
            reliableMarginRight: true,
            boxSizingReliable: true,
            pixelPosition: false
        };
        input.checked = true;
        support.noCloneChecked = input.cloneNode(true).checked;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        try {
            delete div.test;
        } catch (e) {
            support.deleteExpando = false;
        }
        if (!div.addEventListener && div.attachEvent && div.fireEvent) {
            div.attachEvent("onclick", clickFn = function() {
                support.noCloneEvent = false;
            });
            div.cloneNode(true).fireEvent("onclick");
            div.detachEvent("onclick", clickFn);
        }
        input = document.createElement("input");
        input.value = "t";
        input.setAttribute("type", "radio");
        support.radioValue = input.value === "t";
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        fragment = document.createDocumentFragment();
        fragment.appendChild(div.lastChild);
        support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;
        support.appendChecked = input.checked;
        fragment.removeChild(input);
        fragment.appendChild(div);
        if (div.attachEvent) {
            for (i in {
                submit: true,
                change: true,
                focusin: true
            }) {
                eventName = "on" + i;
                isSupported = eventName in div;
                if (!isSupported) {
                    div.setAttribute(eventName, "return;");
                    isSupported = typeof div[eventName] === "function";
                }
                support[i + "Bubbles"] = isSupported;
            }
        }
        jQuery(function() {
            var container, div, tds, marginDiv, divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;", body = document.getElementsByTagName("body")[0];
            if (!body) {
                return;
            }
            container = document.createElement("div");
            container.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
            body.insertBefore(container, body.firstChild);
            div = document.createElement("div");
            container.appendChild(div);
            div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
            tds = div.getElementsByTagName("td");
            tds[0].style.cssText = "padding:0;margin:0;border:0;display:none";
            isSupported = tds[0].offsetHeight === 0;
            tds[0].style.display = "";
            tds[1].style.display = "none";
            support.reliableHiddenOffsets = isSupported && tds[0].offsetHeight === 0;
            div.innerHTML = "";
            div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
            support.boxSizing = div.offsetWidth === 4;
            support.doesNotIncludeMarginInBodyOffset = body.offsetTop !== 1;
            if (window.getComputedStyle) {
                support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== "1%";
                support.boxSizingReliable = (window.getComputedStyle(div, null) || {
                    width: "4px"
                }).width === "4px";
                marginDiv = document.createElement("div");
                marginDiv.style.cssText = div.style.cssText = divReset;
                marginDiv.style.marginRight = marginDiv.style.width = "0";
                div.style.width = "1px";
                div.appendChild(marginDiv);
                support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
            }
            if (typeof div.style.zoom !== "undefined") {
                div.innerHTML = "";
                div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
                support.inlineBlockNeedsLayout = div.offsetWidth === 3;
                div.style.display = "block";
                div.style.overflow = "visible";
                div.innerHTML = "<div></div>";
                div.firstChild.style.width = "5px";
                support.shrinkWrapBlocks = div.offsetWidth !== 3;
                container.style.zoom = 1;
            }
            body.removeChild(container);
            container = div = tds = marginDiv = null;
        });
        fragment.removeChild(div);
        all = a = select = opt = input = fragment = div = null;
        return support;
    }();
    var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/, rmultiDash = /([A-Z])/g;
    jQuery.extend({
        cache: {},
        deletedIds: [],
        uuid: 0,
        expando: "jQuery" + (jQuery.fn.jquery + Math.random()).replace(/\D/g, ""),
        noData: {
            embed: true,
            object: "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
            applet: true
        },
        hasData: function(elem) {
            elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
            return !!elem && !isEmptyDataObject(elem);
        },
        data: function(elem, name, data, pvt) {
            if (!jQuery.acceptData(elem)) {
                return;
            }
            var thisCache, ret, internalKey = jQuery.expando, getByName = typeof name === "string", isNode = elem.nodeType, cache = isNode ? jQuery.cache : elem, id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;
            if ((!id || !cache[id] || !pvt && !cache[id].data) && getByName && data === undefined) {
                return;
            }
            if (!id) {
                if (isNode) {
                    elem[internalKey] = id = jQuery.deletedIds.pop() || jQuery.guid++;
                } else {
                    id = internalKey;
                }
            }
            if (!cache[id]) {
                cache[id] = {};
                if (!isNode) {
                    cache[id].toJSON = jQuery.noop;
                }
            }
            if (typeof name === "object" || typeof name === "function") {
                if (pvt) {
                    cache[id] = jQuery.extend(cache[id], name);
                } else {
                    cache[id].data = jQuery.extend(cache[id].data, name);
                }
            }
            thisCache = cache[id];
            if (!pvt) {
                if (!thisCache.data) {
                    thisCache.data = {};
                }
                thisCache = thisCache.data;
            }
            if (data !== undefined) {
                thisCache[jQuery.camelCase(name)] = data;
            }
            if (getByName) {
                ret = thisCache[name];
                if (ret == null) {
                    ret = thisCache[jQuery.camelCase(name)];
                }
            } else {
                ret = thisCache;
            }
            return ret;
        },
        removeData: function(elem, name, pvt) {
            if (!jQuery.acceptData(elem)) {
                return;
            }
            var thisCache, i, l, isNode = elem.nodeType, cache = isNode ? jQuery.cache : elem, id = isNode ? elem[jQuery.expando] : jQuery.expando;
            if (!cache[id]) {
                return;
            }
            if (name) {
                thisCache = pvt ? cache[id] : cache[id].data;
                if (thisCache) {
                    if (!jQuery.isArray(name)) {
                        if (name in thisCache) {
                            name = [ name ];
                        } else {
                            name = jQuery.camelCase(name);
                            if (name in thisCache) {
                                name = [ name ];
                            } else {
                                name = name.split(" ");
                            }
                        }
                    }
                    for (i = 0, l = name.length; i < l; i++) {
                        delete thisCache[name[i]];
                    }
                    if (!(pvt ? isEmptyDataObject : jQuery.isEmptyObject)(thisCache)) {
                        return;
                    }
                }
            }
            if (!pvt) {
                delete cache[id].data;
                if (!isEmptyDataObject(cache[id])) {
                    return;
                }
            }
            if (isNode) {
                jQuery.cleanData([ elem ], true);
            } else if (jQuery.support.deleteExpando || cache != cache.window) {
                delete cache[id];
            } else {
                cache[id] = null;
            }
        },
        _data: function(elem, name, data) {
            return jQuery.data(elem, name, data, true);
        },
        acceptData: function(elem) {
            var noData = elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()];
            return !noData || noData !== true && elem.getAttribute("classid") === noData;
        }
    });
    jQuery.fn.extend({
        data: function(key, value) {
            var parts, part, attr, name, l, elem = this[0], i = 0, data = null;
            if (key === undefined) {
                if (this.length) {
                    data = jQuery.data(elem);
                    if (elem.nodeType === 1 && !jQuery._data(elem, "parsedAttrs")) {
                        attr = elem.attributes;
                        for (l = attr.length; i < l; i++) {
                            name = attr[i].name;
                            if (!name.indexOf("data-")) {
                                name = jQuery.camelCase(name.substring(5));
                                dataAttr(elem, name, data[name]);
                            }
                        }
                        jQuery._data(elem, "parsedAttrs", true);
                    }
                }
                return data;
            }
            if (typeof key === "object") {
                return this.each(function() {
                    jQuery.data(this, key);
                });
            }
            parts = key.split(".", 2);
            parts[1] = parts[1] ? "." + parts[1] : "";
            part = parts[1] + "!";
            return jQuery.access(this, function(value) {
                if (value === undefined) {
                    data = this.triggerHandler("getData" + part, [ parts[0] ]);
                    if (data === undefined && elem) {
                        data = jQuery.data(elem, key);
                        data = dataAttr(elem, key, data);
                    }
                    return data === undefined && parts[1] ? this.data(parts[0]) : data;
                }
                parts[1] = value;
                this.each(function() {
                    var self = jQuery(this);
                    self.triggerHandler("setData" + part, parts);
                    jQuery.data(this, key, value);
                    self.triggerHandler("changeData" + part, parts);
                });
            }, null, value, arguments.length > 1, null, false);
        },
        removeData: function(key) {
            return this.each(function() {
                jQuery.removeData(this, key);
            });
        }
    });
    function dataAttr(elem, key, data) {
        if (data === undefined && elem.nodeType === 1) {
            var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
                try {
                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {}
                jQuery.data(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    function isEmptyDataObject(obj) {
        var name;
        for (name in obj) {
            if (name === "data" && jQuery.isEmptyObject(obj[name])) {
                continue;
            }
            if (name !== "toJSON") {
                return false;
            }
        }
        return true;
    }
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = jQuery._data(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = jQuery._data(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === "fx") {
                    queue.unshift("inprogress");
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return jQuery._data(elem, key) || jQuery._data(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    jQuery.removeData(elem, type + "queue", true);
                    jQuery.removeData(elem, key, true);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        delay: function(time, type) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
            type = type || "fx";
            return this.queue(type, function(next, hooks) {
                var timeout = setTimeout(next, time);
                hooks.stop = function() {
                    clearTimeout(timeout);
                };
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                if (!--count) {
                    defer.resolveWith(elements, [ elements ]);
                }
            };
            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";
            while (i--) {
                tmp = jQuery._data(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var nodeHook, boolHook, fixSpecified, rclass = /[\t\r\n]/g, rreturn = /\r/g, rtype = /^(?:button|input)$/i, rfocusable = /^(?:button|input|object|select|textarea)$/i, rclickable = /^a(?:rea|)$/i, rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i, getSetAttribute = jQuery.support.getSetAttribute;
    jQuery.fn.extend({
        attr: function(name, value) {
            return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        },
        prop: function(name, value) {
            return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            name = jQuery.propFix[name] || name;
            return this.each(function() {
                try {
                    this[name] = undefined;
                    delete this[name];
                } catch (e) {}
            });
        },
        addClass: function(value) {
            var classNames, i, l, elem, setClass, c, cl;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }
            if (value && typeof value === "string") {
                classNames = value.split(core_rspace);
                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];
                    if (elem.nodeType === 1) {
                        if (!elem.className && classNames.length === 1) {
                            elem.className = value;
                        } else {
                            setClass = " " + elem.className + " ";
                            for (c = 0, cl = classNames.length; c < cl; c++) {
                                if (setClass.indexOf(" " + classNames[c] + " ") < 0) {
                                    setClass += classNames[c] + " ";
                                }
                            }
                            elem.className = jQuery.trim(setClass);
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function(value) {
            var removes, className, elem, c, cl, i, l;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if (value && typeof value === "string" || value === undefined) {
                removes = (value || "").split(core_rspace);
                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];
                    if (elem.nodeType === 1 && elem.className) {
                        className = (" " + elem.className + " ").replace(rclass, " ");
                        for (c = 0, cl = removes.length; c < cl; c++) {
                            while (className.indexOf(" " + removes[c] + " ") >= 0) {
                                className = className.replace(" " + removes[c] + " ", " ");
                            }
                        }
                        elem.className = value ? jQuery.trim(className) : "";
                    }
                }
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value, isBool = typeof stateVal === "boolean";
            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }
            return this.each(function() {
                if (type === "string") {
                    var className, i = 0, self = jQuery(this), state = stateVal, classNames = value.split(core_rspace);
                    while (className = classNames[i++]) {
                        state = isBool ? state : !self.hasClass(className);
                        self[state ? "addClass" : "removeClass"](className);
                    }
                } else if (type === "undefined" || type === "boolean") {
                    if (this.className) {
                        jQuery._data(this, "__className__", this.className);
                    }
                    this.className = this.className || value === false ? "" : jQuery._data(this, "__className__") || "";
                }
            });
        },
        hasClass: function(selector) {
            var className = " " + selector + " ", i = 0, l = this.length;
            for (;i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                    return true;
                }
            }
            return false;
        },
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function(i) {
                var val, self = jQuery(this);
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, self.val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function(value) {
                        return value == null ? "" : value + "";
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = elem.attributes.value;
                    return !val || val.specified ? elem.value : elem.text;
                }
            },
            select: {
                get: function(elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one" || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                    for (;i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function(elem, value) {
                    var values = jQuery.makeArray(value);
                    jQuery(elem).find("option").each(function() {
                        this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0;
                    });
                    if (!values.length) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        },
        attrFn: {},
        attr: function(elem, name, value, pass) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (pass && jQuery.isFunction(jQuery.fn[name])) {
                return jQuery(elem)[name](value);
            }
            if (typeof elem.getAttribute === "undefined") {
                return jQuery.prop(elem, name, value);
            }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (rboolean.test(name) ? boolHook : nodeHook);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                } else if (hooks && "set" in hooks && notxml && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                } else {
                    elem.setAttribute(name, value + "");
                    return value;
                }
            } else if (hooks && "get" in hooks && notxml && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            } else {
                ret = elem.getAttribute(name);
                return ret === null ? undefined : ret;
            }
        },
        removeAttr: function(elem, value) {
            var propName, attrNames, name, isBool, i = 0;
            if (value && elem.nodeType === 1) {
                attrNames = value.split(core_rspace);
                for (;i < attrNames.length; i++) {
                    name = attrNames[i];
                    if (name) {
                        propName = jQuery.propFix[name] || name;
                        isBool = rboolean.test(name);
                        if (!isBool) {
                            jQuery.attr(elem, name, "");
                        }
                        elem.removeAttribute(getSetAttribute ? name : propName);
                        if (isBool && propName in elem) {
                            elem[propName] = false;
                        }
                    }
                }
            }
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (rtype.test(elem.nodeName) && elem.parentNode) {
                        jQuery.error("type property can't be changed");
                    } else if (!jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            },
            value: {
                get: function(elem, name) {
                    if (nodeHook && jQuery.nodeName(elem, "button")) {
                        return nodeHook.get(elem, name);
                    }
                    return name in elem ? elem.value : null;
                },
                set: function(elem, value, name) {
                    if (nodeHook && jQuery.nodeName(elem, "button")) {
                        return nodeHook.set(elem, value, name);
                    }
                    elem.value = value;
                }
            }
        },
        propFix: {
            tabindex: "tabIndex",
            readonly: "readOnly",
            "for": "htmlFor",
            "class": "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        },
        prop: function(elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                } else {
                    return elem[name] = value;
                }
            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                    return ret;
                } else {
                    return elem[name];
                }
            }
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    var attributeNode = elem.getAttributeNode("tabindex");
                    return attributeNode && attributeNode.specified ? parseInt(attributeNode.value, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : undefined;
                }
            }
        }
    });
    boolHook = {
        get: function(elem, name) {
            var attrNode, property = jQuery.prop(elem, name);
            return property === true || typeof property !== "boolean" && (attrNode = elem.getAttributeNode(name)) && attrNode.nodeValue !== false ? name.toLowerCase() : undefined;
        },
        set: function(elem, value, name) {
            var propName;
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else {
                propName = jQuery.propFix[name] || name;
                if (propName in elem) {
                    elem[propName] = true;
                }
                elem.setAttribute(name, name.toLowerCase());
            }
            return name;
        }
    };
    if (!getSetAttribute) {
        fixSpecified = {
            name: true,
            id: true,
            coords: true
        };
        nodeHook = jQuery.valHooks.button = {
            get: function(elem, name) {
                var ret;
                ret = elem.getAttributeNode(name);
                return ret && (fixSpecified[name] ? ret.value !== "" : ret.specified) ? ret.value : undefined;
            },
            set: function(elem, value, name) {
                var ret = elem.getAttributeNode(name);
                if (!ret) {
                    ret = document.createAttribute(name);
                    elem.setAttributeNode(ret);
                }
                return ret.value = value + "";
            }
        };
        jQuery.each([ "width", "height" ], function(i, name) {
            jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                set: function(elem, value) {
                    if (value === "") {
                        elem.setAttribute(name, "auto");
                        return value;
                    }
                }
            });
        });
        jQuery.attrHooks.contenteditable = {
            get: nodeHook.get,
            set: function(elem, value, name) {
                if (value === "") {
                    value = "false";
                }
                nodeHook.set(elem, value, name);
            }
        };
    }
    if (!jQuery.support.hrefNormalized) {
        jQuery.each([ "href", "src", "width", "height" ], function(i, name) {
            jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                get: function(elem) {
                    var ret = elem.getAttribute(name, 2);
                    return ret === null ? undefined : ret;
                }
            });
        });
    }
    if (!jQuery.support.style) {
        jQuery.attrHooks.style = {
            get: function(elem) {
                return elem.style.cssText.toLowerCase() || undefined;
            },
            set: function(elem, value) {
                return elem.style.cssText = value + "";
            }
        };
    }
    if (!jQuery.support.optSelected) {
        jQuery.propHooks.selected = jQuery.extend(jQuery.propHooks.selected, {
            get: function(elem) {
                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
                return null;
            }
        });
    }
    if (!jQuery.support.enctype) {
        jQuery.propFix.enctype = "encoding";
    }
    if (!jQuery.support.checkOn) {
        jQuery.each([ "radio", "checkbox" ], function() {
            jQuery.valHooks[this] = {
                get: function(elem) {
                    return elem.getAttribute("value") === null ? "on" : elem.value;
                }
            };
        });
    }
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[this] = jQuery.extend(jQuery.valHooks[this], {
            set: function(elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                }
            }
        });
    });
    var rformElems = /^(?:textarea|input|select)$/i, rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/, rhoverHack = /(?:^|\s)hover(\.\S+|)\b/, rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, hoverHack = function(events) {
        return jQuery.event.special.hover ? events : events.replace(rhoverHack, "mouseenter$1 mouseleave$1");
    };
    jQuery.event = {
        add: function(elem, types, handler, data, selector) {
            var elemData, eventHandle, events, t, tns, type, namespaces, handleObj, handleObjIn, handlers, special;
            if (elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data(elem))) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            events = elemData.events;
            if (!events) {
                elemData.events = events = {};
            }
            eventHandle = elemData.handle;
            if (!eventHandle) {
                elemData.handle = eventHandle = function(e) {
                    return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
                };
                eventHandle.elem = elem;
            }
            types = jQuery.trim(hoverHack(types)).split(" ");
            for (t = 0; t < types.length; t++) {
                tns = rtypenamespace.exec(types[t]) || [];
                type = tns[1];
                namespaces = (tns[2] || "").split(".").sort();
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: tns[1],
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);
                handlers = events[type];
                if (!handlers) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);
                        } else if (elem.attachEvent) {
                            elem.attachEvent("on" + type, eventHandle);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
            elem = null;
        },
        global: {},
        remove: function(elem, types, handler, selector, mappedTypes) {
            var t, tns, type, origType, namespaces, origCount, j, events, special, eventType, handleObj, elemData = jQuery.hasData(elem) && jQuery._data(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = jQuery.trim(hoverHack(types || "")).split(" ");
            for (t = 0; t < types.length; t++) {
                tns = rtypenamespace.exec(types[t]) || [];
                type = origType = tns[1];
                namespaces = tns[2];
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                eventType = events[type] || [];
                origCount = eventType.length;
                namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
                for (j = 0; j < eventType.length; j++) {
                    handleObj = eventType[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!namespaces || namespaces.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        eventType.splice(j--, 1);
                        if (handleObj.selector) {
                            eventType.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (eventType.length === 0 && origCount !== eventType.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                jQuery.removeData(elem, "events", true);
            }
        },
        customEvent: {
            getData: true,
            setData: true,
            changeData: true
        },
        trigger: function(event, data, elem, onlyHandlers) {
            if (elem && (elem.nodeType === 3 || elem.nodeType === 8)) {
                return;
            }
            var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType, type = event.type || event, namespaces = [];
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf("!") >= 0) {
                type = type.slice(0, -1);
                exclusive = true;
            }
            if (type.indexOf(".") >= 0) {
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            if ((!elem || jQuery.event.customEvent[type]) && !jQuery.event.global[type]) {
                return;
            }
            event = typeof event === "object" ? event[jQuery.expando] ? event : new jQuery.Event(type, event) : new jQuery.Event(type);
            event.type = type;
            event.isTrigger = true;
            event.exclusive = exclusive;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            ontype = type.indexOf(":") < 0 ? "on" + type : "";
            if (!elem) {
                cache = jQuery.cache;
                for (i in cache) {
                    if (cache[i].events && cache[i].events[type]) {
                        jQuery.event.trigger(event, data, cache[i].handle.elem, true);
                    }
                }
                return;
            }
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data != null ? jQuery.makeArray(data) : [];
            data.unshift(event);
            special = jQuery.event.special[type] || {};
            if (special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            eventPath = [ [ elem, special.bindType || type ] ];
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                cur = rfocusMorph.test(bubbleType + type) ? elem : elem.parentNode;
                for (old = elem; cur; cur = cur.parentNode) {
                    eventPath.push([ cur, bubbleType ]);
                    old = cur;
                }
                if (old === (elem.ownerDocument || document)) {
                    eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
                }
            }
            for (i = 0; i < eventPath.length && !event.isPropagationStopped(); i++) {
                cur = eventPath[i][0];
                event.type = eventPath[i][1];
                handle = (jQuery._data(cur, "events") || {})[event.type] && jQuery._data(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
                    event.preventDefault();
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(elem.ownerDocument, data) === false) && !(type === "click" && jQuery.nodeName(elem, "a")) && jQuery.acceptData(elem)) {
                    if (ontype && elem[type] && (type !== "focus" && type !== "blur" || event.target.offsetWidth !== 0) && !jQuery.isWindow(elem)) {
                        old = elem[ontype];
                        if (old) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (old) {
                            elem[ontype] = old;
                        }
                    }
                }
            }
            return event.result;
        },
        dispatch: function(event) {
            event = jQuery.event.fix(event || window.event);
            var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related, handlers = (jQuery._data(this, "events") || {})[event.type] || [], delegateCount = handlers.delegateCount, args = core_slice.call(arguments), run_all = !event.exclusive && !event.namespace, special = jQuery.event.special[event.type] || {}, handlerQueue = [];
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            if (delegateCount && !(event.button && event.type === "click")) {
                for (cur = event.target; cur != this; cur = cur.parentNode || this) {
                    if (cur.disabled !== true || event.type !== "click") {
                        selMatch = {};
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector;
                            if (selMatch[sel] === undefined) {
                                selMatch[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [ cur ]).length;
                            }
                            if (selMatch[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                matches: matches
                            });
                        }
                    }
                }
            }
            if (handlers.length > delegateCount) {
                handlerQueue.push({
                    elem: this,
                    matches: handlers.slice(delegateCount)
                });
            }
            for (i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++) {
                matched = handlerQueue[i];
                event.currentTarget = matched.elem;
                for (j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++) {
                    handleObj = matched.matches[j];
                    if (run_all || !event.namespace && !handleObj.namespace || event.namespace_re && event.namespace_re.test(handleObj.namespace)) {
                        event.data = handleObj.data;
                        event.handleObj = handleObj;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            event.result = ret;
                            if (ret === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(event, original) {
                var eventDoc, doc, body, button = original.button, fromElement = original.fromElement;
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                if (!event.relatedTarget && fromElement) {
                    event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                }
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }
                return event;
            }
        },
        fix: function(event) {
            if (event[jQuery.expando]) {
                return event;
            }
            var i, prop, originalEvent = event, fixHook = jQuery.event.fixHooks[event.type] || {}, copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = jQuery.Event(originalEvent);
            for (i = copy.length; i; ) {
                prop = copy[--i];
                event[prop] = originalEvent[prop];
            }
            if (!event.target) {
                event.target = originalEvent.srcElement || document;
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            event.metaKey = !!event.metaKey;
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
            load: {
                noBubble: true
            },
            focus: {
                delegateType: "focusin"
            },
            blur: {
                delegateType: "focusout"
            },
            beforeunload: {
                setup: function(data, namespaces, eventHandle) {
                    if (jQuery.isWindow(this)) {
                        this.onbeforeunload = eventHandle;
                    }
                },
                teardown: function(namespaces, eventHandle) {
                    if (this.onbeforeunload === eventHandle) {
                        this.onbeforeunload = null;
                    }
                }
            }
        },
        simulate: function(type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true,
                originalEvent: {}
            });
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };
    jQuery.event.handle = jQuery.event.dispatch;
    jQuery.removeEvent = document.removeEventListener ? function(elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
        }
    } : function(elem, type, handle) {
        var name = "on" + type;
        if (elem.detachEvent) {
            if (typeof elem[name] === "undefined") {
                elem[name] = null;
            }
            elem.detachEvent(name, handle);
        }
    };
    jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.returnValue === false || src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    function returnFalse() {
        return false;
    }
    function returnTrue() {
        return true;
    }
    jQuery.Event.prototype = {
        preventDefault: function() {
            this.isDefaultPrevented = returnTrue;
            var e = this.originalEvent;
            if (!e) {
                return;
            }
            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function() {
            this.isPropagationStopped = returnTrue;
            var e = this.originalEvent;
            if (!e) {
                return;
            }
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function() {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        },
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
    };
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj, selector = handleObj.selector;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    if (!jQuery.support.submitBubbles) {
        jQuery.event.special.submit = {
            setup: function() {
                if (jQuery.nodeName(this, "form")) {
                    return false;
                }
                jQuery.event.add(this, "click._submit keypress._submit", function(e) {
                    var elem = e.target, form = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ? elem.form : undefined;
                    if (form && !jQuery._data(form, "_submit_attached")) {
                        jQuery.event.add(form, "submit._submit", function(event) {
                            event._submit_bubble = true;
                        });
                        jQuery._data(form, "_submit_attached", true);
                    }
                });
            },
            postDispatch: function(event) {
                if (event._submit_bubble) {
                    delete event._submit_bubble;
                    if (this.parentNode && !event.isTrigger) {
                        jQuery.event.simulate("submit", this.parentNode, event, true);
                    }
                }
            },
            teardown: function() {
                if (jQuery.nodeName(this, "form")) {
                    return false;
                }
                jQuery.event.remove(this, "._submit");
            }
        };
    }
    if (!jQuery.support.changeBubbles) {
        jQuery.event.special.change = {
            setup: function() {
                if (rformElems.test(this.nodeName)) {
                    if (this.type === "checkbox" || this.type === "radio") {
                        jQuery.event.add(this, "propertychange._change", function(event) {
                            if (event.originalEvent.propertyName === "checked") {
                                this._just_changed = true;
                            }
                        });
                        jQuery.event.add(this, "click._change", function(event) {
                            if (this._just_changed && !event.isTrigger) {
                                this._just_changed = false;
                            }
                            jQuery.event.simulate("change", this, event, true);
                        });
                    }
                    return false;
                }
                jQuery.event.add(this, "beforeactivate._change", function(e) {
                    var elem = e.target;
                    if (rformElems.test(elem.nodeName) && !jQuery._data(elem, "_change_attached")) {
                        jQuery.event.add(elem, "change._change", function(event) {
                            if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                                jQuery.event.simulate("change", this.parentNode, event, true);
                            }
                        });
                        jQuery._data(elem, "_change_attached", true);
                    }
                });
            },
            handle: function(event) {
                var elem = event.target;
                if (this !== elem || event.isSimulated || event.isTrigger || elem.type !== "radio" && elem.type !== "checkbox") {
                    return event.handleObj.handler.apply(this, arguments);
                }
            },
            teardown: function() {
                jQuery.event.remove(this, "._change");
                return !rformElems.test(this.nodeName);
            }
        };
    }
    if (!jQuery.support.focusinBubbles) {
        jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(orig, fix) {
            var attaches = 0, handler = function(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };
            jQuery.event.special[fix] = {
                setup: function() {
                    if (attaches++ === 0) {
                        document.addEventListener(orig, handler, true);
                    }
                },
                teardown: function() {
                    if (--attaches === 0) {
                        document.removeEventListener(orig, handler, true);
                    }
                }
            };
        });
    }
    jQuery.fn.extend({
        on: function(types, selector, data, fn, one) {
            var origFn, type;
            if (typeof types === "object") {
                if (typeof selector !== "string") {
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }
            if (data == null && fn == null) {
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === "string") {
                    fn = data;
                    data = undefined;
                } else {
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }
            if (one === 1) {
                origFn = fn;
                fn = function(event) {
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function() {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function(types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === "object") {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        },
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        live: function(types, data, fn) {
            jQuery(this.context).on(types, this.selector, data, fn);
            return this;
        },
        die: function(types, fn) {
            jQuery(this.context).off(types, this.selector || "**", fn);
            return this;
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            if (this[0]) {
                return jQuery.event.trigger(type, data, this[0], true);
            }
        },
        toggle: function(fn) {
            var args = arguments, guid = fn.guid || jQuery.guid++, i = 0, toggler = function(event) {
                var lastToggle = (jQuery._data(this, "lastToggle" + fn.guid) || 0) % i;
                jQuery._data(this, "lastToggle" + fn.guid, lastToggle + 1);
                event.preventDefault();
                return args[lastToggle].apply(this, arguments) || false;
            };
            toggler.guid = guid;
            while (i < args.length) {
                args[i++].guid = guid;
            }
            return this.click(toggler);
        },
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });
    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
            if (fn == null) {
                fn = data;
                data = null;
            }
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
        if (rkeyEvent.test(name)) {
            jQuery.event.fixHooks[name] = jQuery.event.keyHooks;
        }
        if (rmouseEvent.test(name)) {
            jQuery.event.fixHooks[name] = jQuery.event.mouseHooks;
        }
    });
    (function(window, undefined) {
        var cachedruns, assertGetIdNotName, Expr, getText, isXML, contains, compile, sortOrder, hasDuplicate, outermostContext, baseHasDuplicate = true, strundefined = "undefined", expando = ("sizcache" + Math.random()).replace(".", ""), Token = String, document = window.document, docElem = document.documentElement, dirruns = 0, done = 0, pop = [].pop, push = [].push, slice = [].slice, indexOf = [].indexOf || function(elem) {
            var i = 0, len = this.length;
            for (;i < len; i++) {
                if (this[i] === elem) {
                    return i;
                }
            }
            return -1;
        }, markFunction = function(fn, value) {
            fn[expando] = value == null || value;
            return fn;
        }, createCache = function() {
            var cache = {}, keys = [];
            return markFunction(function(key, value) {
                if (keys.push(key) > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + " "] = value;
            }, cache);
        }, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), whitespace = "[\\x20\\t\\r\\n\\f]", characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+", identifier = characterEncoding.replace("w", "w#"), operators = "([*^$|!~]?=)", attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace + "*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]", pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)", pos = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*"), rpseudo = new RegExp(pseudos), rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/, rnot = /^:not/, rsibling = /[\x20\t\r\n\f]*[+~]/, rendsWithNot = /:not\($/, rheader = /h\d/i, rinputs = /input|select|textarea|button/i, rbackslash = /\\(?!\\)/g, matchExpr = {
            ID: new RegExp("^#(" + characterEncoding + ")"),
            CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
            NAME: new RegExp("^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]"),
            TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            POS: new RegExp(pos, "i"),
            CHILD: new RegExp("^:(only|nth|first|last)-child(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            needsContext: new RegExp("^" + whitespace + "*[>+~]|" + pos, "i")
        }, assert = function(fn) {
            var div = document.createElement("div");
            try {
                return fn(div);
            } catch (e) {
                return false;
            } finally {
                div = null;
            }
        }, assertTagNameNoComments = assert(function(div) {
            div.appendChild(document.createComment(""));
            return !div.getElementsByTagName("*").length;
        }), assertHrefNotNormalized = assert(function(div) {
            div.innerHTML = "<a href='#'></a>";
            return div.firstChild && typeof div.firstChild.getAttribute !== strundefined && div.firstChild.getAttribute("href") === "#";
        }), assertAttributes = assert(function(div) {
            div.innerHTML = "<select></select>";
            var type = typeof div.lastChild.getAttribute("multiple");
            return type !== "boolean" && type !== "string";
        }), assertUsableClassName = assert(function(div) {
            div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
            if (!div.getElementsByClassName || !div.getElementsByClassName("e").length) {
                return false;
            }
            div.lastChild.className = "e";
            return div.getElementsByClassName("e").length === 2;
        }), assertUsableName = assert(function(div) {
            div.id = expando + 0;
            div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
            docElem.insertBefore(div, docElem.firstChild);
            var pass = document.getElementsByName && document.getElementsByName(expando).length === 2 + document.getElementsByName(expando + 0).length;
            assertGetIdNotName = !document.getElementById(expando);
            docElem.removeChild(div);
            return pass;
        });
        try {
            slice.call(docElem.childNodes, 0)[0].nodeType;
        } catch (e) {
            slice = function(i) {
                var elem, results = [];
                for (;elem = this[i]; i++) {
                    results.push(elem);
                }
                return results;
            };
        }
        function Sizzle(selector, context, results, seed) {
            results = results || [];
            context = context || document;
            var match, elem, xml, m, nodeType = context.nodeType;
            if (!selector || typeof selector !== "string") {
                return results;
            }
            if (nodeType !== 1 && nodeType !== 9) {
                return [];
            }
            xml = isXML(context);
            if (!xml && !seed) {
                if (match = rquickExpr.exec(selector)) {
                    if (m = match[1]) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            if (elem && elem.parentNode) {
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            } else {
                                return results;
                            }
                        } else {
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        }
                    } else if (match[2]) {
                        push.apply(results, slice.call(context.getElementsByTagName(selector), 0));
                        return results;
                    } else if ((m = match[3]) && assertUsableClassName && context.getElementsByClassName) {
                        push.apply(results, slice.call(context.getElementsByClassName(m), 0));
                        return results;
                    }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed, xml);
        }
        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
            return Sizzle(expr, null, null, [ elem ]).length > 0;
        };
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (nodeType) {
                if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                    if (typeof elem.textContent === "string") {
                        return elem.textContent;
                    } else {
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += getText(elem);
                        }
                    }
                } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue;
                }
            } else {
                for (;node = elem[i]; i++) {
                    ret += getText(node);
                }
            }
            return ret;
        };
        isXML = Sizzle.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };
        contains = Sizzle.contains = docElem.contains ? function(a, b) {
            var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
            return a === bup || !!(bup && bup.nodeType === 1 && adown.contains && adown.contains(bup));
        } : docElem.compareDocumentPosition ? function(a, b) {
            return b && !!(a.compareDocumentPosition(b) & 16);
        } : function(a, b) {
            while (b = b.parentNode) {
                if (b === a) {
                    return true;
                }
            }
            return false;
        };
        Sizzle.attr = function(elem, name) {
            var val, xml = isXML(elem);
            if (!xml) {
                name = name.toLowerCase();
            }
            if (val = Expr.attrHandle[name]) {
                return val(elem);
            }
            if (xml || assertAttributes) {
                return elem.getAttribute(name);
            }
            val = elem.getAttributeNode(name);
            return val ? typeof elem[name] === "boolean" ? elem[name] ? name : null : val.specified ? val.value : null : null;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: assertHrefNotNormalized ? {} : {
                href: function(elem) {
                    return elem.getAttribute("href", 2);
                },
                type: function(elem) {
                    return elem.getAttribute("type");
                }
            },
            find: {
                ID: assertGetIdNotName ? function(id, context, xml) {
                    if (typeof context.getElementById !== strundefined && !xml) {
                        var m = context.getElementById(id);
                        return m && m.parentNode ? [ m ] : [];
                    }
                } : function(id, context, xml) {
                    if (typeof context.getElementById !== strundefined && !xml) {
                        var m = context.getElementById(id);
                        return m ? m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ? [ m ] : undefined : [];
                    }
                },
                TAG: assertTagNameNoComments ? function(tag, context) {
                    if (typeof context.getElementsByTagName !== strundefined) {
                        return context.getElementsByTagName(tag);
                    }
                } : function(tag, context) {
                    var results = context.getElementsByTagName(tag);
                    if (tag === "*") {
                        var elem, tmp = [], i = 0;
                        for (;elem = results[i]; i++) {
                            if (elem.nodeType === 1) {
                                tmp.push(elem);
                            }
                        }
                        return tmp;
                    }
                    return results;
                },
                NAME: assertUsableName && function(tag, context) {
                    if (typeof context.getElementsByName !== strundefined) {
                        return context.getElementsByName(name);
                    }
                },
                CLASS: assertUsableClassName && function(className, context, xml) {
                    if (typeof context.getElementsByClassName !== strundefined && !xml) {
                        return context.getElementsByClassName(className);
                    }
                }
            },
            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    match[1] = match[1].replace(rbackslash, "");
                    match[3] = (match[4] || match[5] || "").replace(rbackslash, "");
                    if (match[2] === "~=") {
                        match[3] = " " + match[3] + " ";
                    }
                    return match.slice(0, 4);
                },
                CHILD: function(match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1] === "nth") {
                        if (!match[2]) {
                            Sizzle.error(match[0]);
                        }
                        match[3] = +(match[3] ? match[4] + (match[5] || 1) : 2 * (match[2] === "even" || match[2] === "odd"));
                        match[4] = +(match[6] + match[7] || match[2] === "odd");
                    } else if (match[2]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                PSEUDO: function(match) {
                    var unquoted, excess;
                    if (matchExpr["CHILD"].test(match[0])) {
                        return null;
                    }
                    if (match[3]) {
                        match[2] = match[3];
                    } else if (unquoted = match[4]) {
                        if (rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                            unquoted = unquoted.slice(0, excess);
                            match[0] = match[0].slice(0, excess);
                        }
                        match[2] = unquoted;
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                ID: assertGetIdNotName ? function(id) {
                    id = id.replace(rbackslash, "");
                    return function(elem) {
                        return elem.getAttribute("id") === id;
                    };
                } : function(id) {
                    id = id.replace(rbackslash, "");
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                        return node && node.value === id;
                    };
                },
                TAG: function(nodeName) {
                    if (nodeName === "*") {
                        return function() {
                            return true;
                        };
                    }
                    nodeName = nodeName.replace(rbackslash, "").toLowerCase();
                    return function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                CLASS: function(className) {
                    var pattern = classCache[expando][className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test(elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "");
                    });
                },
                ATTR: function(name, operator, check) {
                    return function(elem, context) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === "!=";
                        }
                        if (!operator) {
                            return true;
                        }
                        result += "";
                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.substr(result.length - check.length) === check : operator === "~=" ? (" " + result + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.substr(0, check.length + 1) === check + "-" : false;
                    };
                },
                CHILD: function(type, argument, first, last) {
                    if (type === "nth") {
                        return function(elem) {
                            var node, diff, parent = elem.parentNode;
                            if (first === 1 && last === 0) {
                                return true;
                            }
                            if (parent) {
                                diff = 0;
                                for (node = parent.firstChild; node; node = node.nextSibling) {
                                    if (node.nodeType === 1) {
                                        diff++;
                                        if (elem === node) {
                                            break;
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        };
                    }
                    return function(elem) {
                        var node = elem;
                        switch (type) {
                          case "only":
                          case "first":
                            while (node = node.previousSibling) {
                                if (node.nodeType === 1) {
                                    return false;
                                }
                            }
                            if (type === "first") {
                                return true;
                            }
                            node = elem;

                          case "last":
                            while (node = node.nextSibling) {
                                if (node.nodeType === 1) {
                                    return false;
                                }
                            }
                            return true;
                        }
                    };
                },
                PSEUDO: function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [ pseudo, pseudo, "", argument ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf.call(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                not: markFunction(function(selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function(elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        return !results.pop();
                    };
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                contains: markFunction(function(text) {
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                enabled: function(elem) {
                    return elem.disabled === false;
                },
                disabled: function(elem) {
                    return elem.disabled === true;
                },
                checked: function(elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
                },
                selected: function(elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                parent: function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },
                empty: function(elem) {
                    var nodeType;
                    elem = elem.firstChild;
                    while (elem) {
                        if (elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4) {
                            return false;
                        }
                        elem = elem.nextSibling;
                    }
                    return true;
                },
                header: function(elem) {
                    return rheader.test(elem.nodeName);
                },
                text: function(elem) {
                    var type, attr;
                    return elem.nodeName.toLowerCase() === "input" && (type = elem.type) === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type);
                },
                radio: createInputPseudo("radio"),
                checkbox: createInputPseudo("checkbox"),
                file: createInputPseudo("file"),
                password: createInputPseudo("password"),
                image: createInputPseudo("image"),
                submit: createButtonPseudo("submit"),
                reset: createButtonPseudo("reset"),
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                focus: function(elem) {
                    var doc = elem.ownerDocument;
                    return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                active: function(elem) {
                    return elem === elem.ownerDocument.activeElement;
                },
                first: createPositionalPseudo(function() {
                    return [ 0 ];
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [ length - 1 ];
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [ argument < 0 ? argument + length : argument ];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 0; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 1; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = argument < 0 ? argument + length : argument; --i >= 0; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = argument < 0 ? argument + length : argument; ++i < length; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        function siblingCheck(a, b, ret) {
            if (a === b) {
                return ret;
            }
            var cur = a.nextSibling;
            while (cur) {
                if (cur === b) {
                    return -1;
                }
                cur = cur.nextSibling;
            }
            return 1;
        }
        sortOrder = docElem.compareDocumentPosition ? function(a, b) {
            if (a === b) {
                hasDuplicate = true;
                return 0;
            }
            return (!a.compareDocumentPosition || !b.compareDocumentPosition ? a.compareDocumentPosition : a.compareDocumentPosition(b) & 4) ? -1 : 1;
        } : function(a, b) {
            if (a === b) {
                hasDuplicate = true;
                return 0;
            } else if (a.sourceIndex && b.sourceIndex) {
                return a.sourceIndex - b.sourceIndex;
            }
            var al, bl, ap = [], bp = [], aup = a.parentNode, bup = b.parentNode, cur = aup;
            if (aup === bup) {
                return siblingCheck(a, b);
            } else if (!aup) {
                return -1;
            } else if (!bup) {
                return 1;
            }
            while (cur) {
                ap.unshift(cur);
                cur = cur.parentNode;
            }
            cur = bup;
            while (cur) {
                bp.unshift(cur);
                cur = cur.parentNode;
            }
            al = ap.length;
            bl = bp.length;
            for (var i = 0; i < al && i < bl; i++) {
                if (ap[i] !== bp[i]) {
                    return siblingCheck(ap[i], bp[i]);
                }
            }
            return i === al ? siblingCheck(a, bp[i], -1) : siblingCheck(ap[i], b, 1);
        };
        [ 0, 0 ].sort(sortOrder);
        baseHasDuplicate = !hasDuplicate;
        Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], i = 1, j = 0;
            hasDuplicate = baseHasDuplicate;
            results.sort(sortOrder);
            if (hasDuplicate) {
                for (;elem = results[i]; i++) {
                    if (elem === results[i - 1]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            return results;
        };
        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        function tokenize(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[expando][selector + " "];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    tokens.push(matched = new Token(match.shift()));
                    soFar = soFar.slice(matched.length);
                    matched.type = match[0].replace(rtrim, " ");
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        tokens.push(matched = new Token(match.shift()));
                        soFar = soFar.slice(matched.length);
                        matched.type = type;
                        matched.matches = match;
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && combinator.dir === "parentNode", doneName = done++;
            return combinator.first ? function(elem, context, xml) {
                while (elem = elem[dir]) {
                    if (checkNonElements || elem.nodeType === 1) {
                        return matcher(elem, context, xml);
                    }
                }
            } : function(elem, context, xml) {
                if (!xml) {
                    var cache, dirkey = dirruns + " " + doneName + " ", cachedkey = dirkey + cachedruns;
                    while (elem = elem[dir]) {
                        if (checkNonElements || elem.nodeType === 1) {
                            if ((cache = elem[expando]) === cachedkey) {
                                return elem.sizset;
                            } else if (typeof cache === "string" && cache.indexOf(dirkey) === 0) {
                                if (elem.sizset) {
                                    return elem;
                                }
                            } else {
                                elem[expando] = cachedkey;
                                if (matcher(elem, context, xml)) {
                                    elem.sizset = true;
                                    return elem;
                                }
                                elem.sizset = false;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (checkNonElements || elem.nodeType === 1) {
                            if (matcher(elem, context, xml)) {
                                return elem;
                            }
                        }
                    }
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (;i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf.call(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [ function(elem, context, xml) {
                return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            } ];
            for (;i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [ addCombinator(elementMatcher(matchers), matcher) ];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (;j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && tokens.slice(0, i - 1).join("").replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && tokens.join(""));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, expandContext) {
                var elem, j, matcher, setMatched = [], matchedCount = 0, i = "0", unmatched = seed && [], outermost = expandContext != null, contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", expandContext && context.parentNode || context), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.E;
                if (outermost) {
                    outermostContext = context !== document && context;
                    cachedruns = superMatcher.el;
                }
                for (;(elem = elems[i]) != null; i++) {
                    if (byElement && elem) {
                        for (j = 0; matcher = elementMatchers[j]; j++) {
                            if (matcher(elem, context, xml)) {
                                results.push(elem);
                                break;
                            }
                        }
                        if (outermost) {
                            dirruns = dirrunsUnique;
                            cachedruns = ++superMatcher.el;
                        }
                    }
                    if (bySet) {
                        if (elem = !matcher && elem) {
                            matchedCount--;
                        }
                        if (seed) {
                            unmatched.push(elem);
                        }
                    }
                }
                matchedCount += i;
                if (bySet && i !== matchedCount) {
                    for (j = 0; matcher = setMatchers[j]; j++) {
                        matcher(unmatched, setMatched, context, xml);
                    }
                    if (seed) {
                        if (matchedCount > 0) {
                            while (i--) {
                                if (!(unmatched[i] || setMatched[i])) {
                                    setMatched[i] = pop.call(results);
                                }
                            }
                        }
                        setMatched = condense(setMatched);
                    }
                    push.apply(results, setMatched);
                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                        Sizzle.uniqueSort(results);
                    }
                }
                if (outermost) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }
                return unmatched;
            };
            superMatcher.el = 0;
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, group) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[expando][selector + " "];
            if (!cached) {
                if (!group) {
                    group = tokenize(selector);
                }
                i = group.length;
                while (i--) {
                    cached = matcherFromTokens(group[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
            }
            return cached;
        };
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (;i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function select(selector, context, results, seed, xml) {
            var i, tokens, token, type, find, match = tokenize(selector), j = match.length;
            if (!seed) {
                if (match.length === 1) {
                    tokens = match[0] = match[0].slice(0);
                    if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && !xml && Expr.relative[tokens[1].type]) {
                        context = Expr.find["ID"](token.matches[0].replace(rbackslash, ""), context, xml)[0];
                        if (!context) {
                            return results;
                        }
                        selector = selector.slice(tokens.shift().length);
                    }
                    for (i = matchExpr["POS"].test(selector) ? -1 : tokens.length - 1; i >= 0; i--) {
                        token = tokens[i];
                        if (Expr.relative[type = token.type]) {
                            break;
                        }
                        if (find = Expr.find[type]) {
                            if (seed = find(token.matches[0].replace(rbackslash, ""), rsibling.test(tokens[0].type) && context.parentNode || context, xml)) {
                                tokens.splice(i, 1);
                                selector = seed.length && tokens.join("");
                                if (!selector) {
                                    push.apply(results, slice.call(seed, 0));
                                    return results;
                                }
                                break;
                            }
                        }
                    }
                }
            }
            compile(selector, match)(seed, context, xml, results, rsibling.test(selector));
            return results;
        }
        if (document.querySelectorAll) {
            (function() {
                var disconnectedMatch, oldSelect = select, rescape = /'|\\/g, rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g, rbuggyQSA = [ ":focus" ], rbuggyMatches = [ ":active" ], matches = docElem.matchesSelector || docElem.mozMatchesSelector || docElem.webkitMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector;
                assert(function(div) {
                    div.innerHTML = "<select><option selected=''></option></select>";
                    if (!div.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push("\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)");
                    }
                    if (!div.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked");
                    }
                });
                assert(function(div) {
                    div.innerHTML = "<p test=''></p>";
                    if (div.querySelectorAll("[test^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:\"\"|'')");
                    }
                    div.innerHTML = "<input type='hidden'/>";
                    if (!div.querySelectorAll(":enabled").length) {
                        rbuggyQSA.push(":enabled", ":disabled");
                    }
                });
                rbuggyQSA = new RegExp(rbuggyQSA.join("|"));
                select = function(selector, context, results, seed, xml) {
                    if (!seed && !xml && !rbuggyQSA.test(selector)) {
                        var groups, i, old = true, nid = expando, newContext = context, newSelector = context.nodeType === 9 && selector;
                        if (context.nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                            groups = tokenize(selector);
                            if (old = context.getAttribute("id")) {
                                nid = old.replace(rescape, "\\$&");
                            } else {
                                context.setAttribute("id", nid);
                            }
                            nid = "[id='" + nid + "'] ";
                            i = groups.length;
                            while (i--) {
                                groups[i] = nid + groups[i].join("");
                            }
                            newContext = rsibling.test(selector) && context.parentNode || context;
                            newSelector = groups.join(",");
                        }
                        if (newSelector) {
                            try {
                                push.apply(results, slice.call(newContext.querySelectorAll(newSelector), 0));
                                return results;
                            } catch (qsaError) {} finally {
                                if (!old) {
                                    context.removeAttribute("id");
                                }
                            }
                        }
                    }
                    return oldSelect(selector, context, results, seed, xml);
                };
                if (matches) {
                    assert(function(div) {
                        disconnectedMatch = matches.call(div, "div");
                        try {
                            matches.call(div, "[test!='']:sizzle");
                            rbuggyMatches.push("!=", pseudos);
                        } catch (e) {}
                    });
                    rbuggyMatches = new RegExp(rbuggyMatches.join("|"));
                    Sizzle.matchesSelector = function(elem, expr) {
                        expr = expr.replace(rattributeQuotes, "='$1']");
                        if (!isXML(elem) && !rbuggyMatches.test(expr) && !rbuggyQSA.test(expr)) {
                            try {
                                var ret = matches.call(elem, expr);
                                if (ret || disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                                    return ret;
                                }
                            } catch (e) {}
                        }
                        return Sizzle(expr, null, null, [ elem ]).length > 0;
                    };
                }
            })();
        }
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        function setFilters() {}
        Expr.filters = setFilters.prototype = Expr.pseudos;
        Expr.setFilters = new setFilters();
        Sizzle.attr = jQuery.attr;
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[":"] = jQuery.expr.pseudos;
        jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;
    })(window);
    var runtil = /Until$/, rparentsprev = /^(?:parents|prev(?:Until|All))/, isSimple = /^.[^:#\[\.,]*$/, rneedsContext = jQuery.expr.match.needsContext, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };
    jQuery.fn.extend({
        find: function(selector) {
            var i, l, length, n, r, ret, self = this;
            if (typeof selector !== "string") {
                return jQuery(selector).filter(function() {
                    for (i = 0, l = self.length; i < l; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                });
            }
            ret = this.pushStack("", "find", selector);
            for (i = 0, l = this.length; i < l; i++) {
                length = ret.length;
                jQuery.find(selector, this[i], ret);
                if (i > 0) {
                    for (n = length; n < ret.length; n++) {
                        for (r = 0; r < length; r++) {
                            if (ret[r] === ret[n]) {
                                ret.splice(n--, 1);
                                break;
                            }
                        }
                    }
                }
            }
            return ret;
        },
        has: function(target) {
            var i, targets = jQuery(target, this), len = targets.length;
            return this.filter(function() {
                for (i = 0; i < len; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector, false), "not", selector);
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector, true), "filter", selector);
        },
        is: function(selector) {
            return !!selector && (typeof selector === "string" ? rneedsContext.test(selector) ? jQuery(selector, this.context).index(this[0]) >= 0 : jQuery.filter(selector, this).length > 0 : this.filter(selector).length > 0);
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, ret = [], pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
            for (;i < l; i++) {
                cur = this[i];
                while (cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11) {
                    if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {
                        ret.push(cur);
                        break;
                    }
                    cur = cur.parentNode;
                }
            }
            ret = ret.length > 1 ? jQuery.unique(ret) : ret;
            return this.pushStack(ret, "closest", selectors);
        },
        index: function(elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.prevAll().length : -1;
            }
            if (typeof elem === "string") {
                return jQuery.inArray(this[0], jQuery(elem));
            }
            return jQuery.inArray(elem.jquery ? elem[0] : elem, this);
        },
        add: function(selector, context) {
            var set = typeof selector === "string" ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [ selector ] : selector), all = jQuery.merge(this.get(), set);
            return this.pushStack(isDisconnected(set[0]) || isDisconnected(all[0]) ? all : jQuery.unique(all));
        },
        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    jQuery.fn.andSelf = jQuery.fn.addBack;
    function isDisconnected(node) {
        return !node || !node.parentNode || node.parentNode.nodeType === 11;
    }
    function sibling(cur, dir) {
        do {
            cur = cur[dir];
        } while (cur && cur.nodeType !== 1);
        return cur;
    }
    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function(elem) {
            return jQuery.nodeName(elem, "iframe") ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var ret = jQuery.map(this, fn, until);
            if (!runtil.test(name)) {
                selector = until;
            }
            if (selector && typeof selector === "string") {
                ret = jQuery.filter(selector, ret);
            }
            ret = this.length > 1 && !guaranteedUnique[name] ? jQuery.unique(ret) : ret;
            if (this.length > 1 && rparentsprev.test(name)) {
                ret = ret.reverse();
            }
            return this.pushStack(ret, name, core_slice.call(arguments).join(","));
        };
    });
    jQuery.extend({
        filter: function(expr, elems, not) {
            if (not) {
                expr = ":not(" + expr + ")";
            }
            return elems.length === 1 ? jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] : jQuery.find.matches(expr, elems);
        },
        dir: function(elem, dir, until) {
            var matched = [], cur = elem[dir];
            while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) {
                    matched.push(cur);
                }
                cur = cur[dir];
            }
            return matched;
        },
        sibling: function(n, elem) {
            var r = [];
            for (;n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    r.push(n);
                }
            }
            return r;
        }
    });
    function winnow(elements, qualifier, keep) {
        qualifier = qualifier || 0;
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function(elem, i) {
                var retVal = !!qualifier.call(elem, i, elem);
                return retVal === keep;
            });
        } else if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem, i) {
                return elem === qualifier === keep;
            });
        } else if (typeof qualifier === "string") {
            var filtered = jQuery.grep(elements, function(elem) {
                return elem.nodeType === 1;
            });
            if (isSimple.test(qualifier)) {
                return jQuery.filter(qualifier, filtered, !keep);
            } else {
                qualifier = jQuery.filter(qualifier, filtered);
            }
        }
        return jQuery.grep(elements, function(elem, i) {
            return jQuery.inArray(elem, qualifier) >= 0 === keep;
        });
    }
    function createSafeFragment(document) {
        var list = nodeNames.split("|"), safeFrag = document.createDocumentFragment();
        if (safeFrag.createElement) {
            while (list.length) {
                safeFrag.createElement(list.pop());
            }
        }
        return safeFrag;
    }
    var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" + "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g, rleadingWhitespace = /^\s+/, rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rtbody = /<tbody/i, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rnocache = /<(?:script|object|embed|option|style)/i, rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"), rcheckableType = /^(?:checkbox|radio)$/, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /\/(java|ecma)script/i, rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g, wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        area: [ 1, "<map>", "</map>" ],
        _default: [ 0, "", "" ]
    }, safeFragment = createSafeFragment(document), fragmentDiv = safeFragment.appendChild(document.createElement("div"));
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    if (!jQuery.support.htmlSerialize) {
        wrapMap._default = [ 1, "X<div>", "</div>" ];
    }
    jQuery.fn.extend({
        text: function(value) {
            return jQuery.access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
            }, null, value, arguments.length);
        },
        wrapAll: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function() {
                    var elem = this;
                    while (elem.firstChild && elem.firstChild.nodeType === 1) {
                        elem = elem.firstChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function() {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        },
        append: function() {
            return this.domManip(arguments, true, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11) {
                    this.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, true, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11) {
                    this.insertBefore(elem, this.firstChild);
                }
            });
        },
        before: function() {
            if (!isDisconnected(this[0])) {
                return this.domManip(arguments, false, function(elem) {
                    this.parentNode.insertBefore(elem, this);
                });
            }
            if (arguments.length) {
                var set = jQuery.clean(arguments);
                return this.pushStack(jQuery.merge(set, this), "before", this.selector);
            }
        },
        after: function() {
            if (!isDisconnected(this[0])) {
                return this.domManip(arguments, false, function(elem) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                });
            }
            if (arguments.length) {
                var set = jQuery.clean(arguments);
                return this.pushStack(jQuery.merge(this, set), "after", this.selector);
            }
        },
        remove: function(selector, keepData) {
            var elem, i = 0;
            for (;(elem = this[i]) != null; i++) {
                if (!selector || jQuery.filter(selector, [ elem ]).length) {
                    if (!keepData && elem.nodeType === 1) {
                        jQuery.cleanData(elem.getElementsByTagName("*"));
                        jQuery.cleanData([ elem ]);
                    }
                    if (elem.parentNode) {
                        elem.parentNode.removeChild(elem);
                    }
                }
            }
            return this;
        },
        empty: function() {
            var elem, i = 0;
            for (;(elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(elem.getElementsByTagName("*"));
                }
                while (elem.firstChild) {
                    elem.removeChild(elem.firstChild);
                }
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return jQuery.access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined) {
                    return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, "") : undefined;
                }
                if (typeof value === "string" && !rnoInnerhtml.test(value) && (jQuery.support.htmlSerialize || !rnoshimcache.test(value)) && (jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, "<$1></$2>");
                    try {
                        for (;i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(elem.getElementsByTagName("*"));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {}
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function(value) {
            if (!isDisconnected(this[0])) {
                if (jQuery.isFunction(value)) {
                    return this.each(function(i) {
                        var self = jQuery(this), old = self.html();
                        self.replaceWith(value.call(this, i, old));
                    });
                }
                if (typeof value !== "string") {
                    value = jQuery(value).detach();
                }
                return this.each(function() {
                    var next = this.nextSibling, parent = this.parentNode;
                    jQuery(this).remove();
                    if (next) {
                        jQuery(next).before(value);
                    } else {
                        jQuery(parent).append(value);
                    }
                });
            }
            return this.length ? this.pushStack(jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value) : this;
        },
        detach: function(selector) {
            return this.remove(selector, true);
        },
        domManip: function(args, table, callback) {
            args = [].concat.apply([], args);
            var results, first, fragment, iNoClone, i = 0, value = args[0], scripts = [], l = this.length;
            if (!jQuery.support.checkClone && l > 1 && typeof value === "string" && rchecked.test(value)) {
                return this.each(function() {
                    jQuery(this).domManip(args, table, callback);
                });
            }
            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    var self = jQuery(this);
                    args[0] = value.call(this, i, table ? self.html() : undefined);
                    self.domManip(args, table, callback);
                });
            }
            if (this[0]) {
                results = jQuery.buildFragment(args, this, scripts);
                fragment = results.fragment;
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }
                if (first) {
                    table = table && jQuery.nodeName(first, "tr");
                    for (iNoClone = results.cacheable || l - 1; i < l; i++) {
                        callback.call(table && jQuery.nodeName(this[i], "table") ? findOrAppend(this[i], "tbody") : this[i], i === iNoClone ? fragment : jQuery.clone(fragment, true, true));
                    }
                }
                fragment = first = null;
                if (scripts.length) {
                    jQuery.each(scripts, function(i, elem) {
                        if (elem.src) {
                            if (jQuery.ajax) {
                                jQuery.ajax({
                                    url: elem.src,
                                    type: "GET",
                                    dataType: "script",
                                    async: false,
                                    global: false,
                                    "throws": true
                                });
                            } else {
                                jQuery.error("no ajax");
                            }
                        } else {
                            jQuery.globalEval((elem.text || elem.textContent || elem.innerHTML || "").replace(rcleanScript, ""));
                        }
                        if (elem.parentNode) {
                            elem.parentNode.removeChild(elem);
                        }
                    });
                }
            }
            return this;
        }
    });
    function findOrAppend(elem, tag) {
        return elem.getElementsByTagName(tag)[0] || elem.appendChild(elem.ownerDocument.createElement(tag));
    }
    function cloneCopyEvent(src, dest) {
        if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
            return;
        }
        var type, i, l, oldData = jQuery._data(src), curData = jQuery._data(dest, oldData), events = oldData.events;
        if (events) {
            delete curData.handle;
            curData.events = {};
            for (type in events) {
                for (i = 0, l = events[type].length; i < l; i++) {
                    jQuery.event.add(dest, type, events[type][i]);
                }
            }
        }
        if (curData.data) {
            curData.data = jQuery.extend({}, curData.data);
        }
    }
    function cloneFixAttributes(src, dest) {
        var nodeName;
        if (dest.nodeType !== 1) {
            return;
        }
        if (dest.clearAttributes) {
            dest.clearAttributes();
        }
        if (dest.mergeAttributes) {
            dest.mergeAttributes(src);
        }
        nodeName = dest.nodeName.toLowerCase();
        if (nodeName === "object") {
            if (dest.parentNode) {
                dest.outerHTML = src.outerHTML;
            }
            if (jQuery.support.html5Clone && src.innerHTML && !jQuery.trim(dest.innerHTML)) {
                dest.innerHTML = src.innerHTML;
            }
        } else if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.defaultChecked = dest.checked = src.checked;
            if (dest.value !== src.value) {
                dest.value = src.value;
            }
        } else if (nodeName === "option") {
            dest.selected = src.defaultSelected;
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        } else if (nodeName === "script" && dest.text !== src.text) {
            dest.text = src.text;
        }
        dest.removeAttribute(jQuery.expando);
    }
    jQuery.buildFragment = function(args, context, scripts) {
        var fragment, cacheable, cachehit, first = args[0];
        context = context || document;
        context = !context.nodeType && context[0] || context;
        context = context.ownerDocument || context;
        if (args.length === 1 && typeof first === "string" && first.length < 512 && context === document && first.charAt(0) === "<" && !rnocache.test(first) && (jQuery.support.checkClone || !rchecked.test(first)) && (jQuery.support.html5Clone || !rnoshimcache.test(first))) {
            cacheable = true;
            fragment = jQuery.fragments[first];
            cachehit = fragment !== undefined;
        }
        if (!fragment) {
            fragment = context.createDocumentFragment();
            jQuery.clean(args, context, fragment, scripts);
            if (cacheable) {
                jQuery.fragments[first] = cachehit && fragment;
            }
        }
        return {
            fragment: fragment,
            cacheable: cacheable
        };
    };
    jQuery.fragments = {};
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, i = 0, ret = [], insert = jQuery(selector), l = insert.length, parent = this.length === 1 && this[0].parentNode;
            if ((parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1) {
                insert[original](this[0]);
                return this;
            } else {
                for (;i < l; i++) {
                    elems = (i > 0 ? this.clone(true) : this).get();
                    jQuery(insert[i])[original](elems);
                    ret = ret.concat(elems);
                }
                return this.pushStack(ret, name, insert.selector);
            }
        };
    });
    function getAll(elem) {
        if (typeof elem.getElementsByTagName !== "undefined") {
            return elem.getElementsByTagName("*");
        } else if (typeof elem.querySelectorAll !== "undefined") {
            return elem.querySelectorAll("*");
        } else {
            return [];
        }
    }
    function fixDefaultChecked(elem) {
        if (rcheckableType.test(elem.type)) {
            elem.defaultChecked = elem.checked;
        }
    }
    jQuery.extend({
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var srcElements, destElements, i, clone;
            if (jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test("<" + elem.nodeName + ">")) {
                clone = elem.cloneNode(true);
            } else {
                fragmentDiv.innerHTML = elem.outerHTML;
                fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
            }
            if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                cloneFixAttributes(elem, clone);
                srcElements = getAll(elem);
                destElements = getAll(clone);
                for (i = 0; srcElements[i]; ++i) {
                    if (destElements[i]) {
                        cloneFixAttributes(srcElements[i], destElements[i]);
                    }
                }
            }
            if (dataAndEvents) {
                cloneCopyEvent(elem, clone);
                if (deepDataAndEvents) {
                    srcElements = getAll(elem);
                    destElements = getAll(clone);
                    for (i = 0; srcElements[i]; ++i) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                }
            }
            srcElements = destElements = null;
            return clone;
        },
        clean: function(elems, context, fragment, scripts) {
            var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags, safe = context === document && safeFragment, ret = [];
            if (!context || typeof context.createDocumentFragment === "undefined") {
                context = document;
            }
            for (i = 0; (elem = elems[i]) != null; i++) {
                if (typeof elem === "number") {
                    elem += "";
                }
                if (!elem) {
                    continue;
                }
                if (typeof elem === "string") {
                    if (!rhtml.test(elem)) {
                        elem = context.createTextNode(elem);
                    } else {
                        safe = safe || createSafeFragment(context);
                        div = context.createElement("div");
                        safe.appendChild(div);
                        elem = elem.replace(rxhtmlTag, "<$1></$2>");
                        tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        depth = wrap[0];
                        div.innerHTML = wrap[1] + elem + wrap[2];
                        while (depth--) {
                            div = div.lastChild;
                        }
                        if (!jQuery.support.tbody) {
                            hasBody = rtbody.test(elem);
                            tbody = tag === "table" && !hasBody ? div.firstChild && div.firstChild.childNodes : wrap[1] === "<table>" && !hasBody ? div.childNodes : [];
                            for (j = tbody.length - 1; j >= 0; --j) {
                                if (jQuery.nodeName(tbody[j], "tbody") && !tbody[j].childNodes.length) {
                                    tbody[j].parentNode.removeChild(tbody[j]);
                                }
                            }
                        }
                        if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                            div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild);
                        }
                        elem = div.childNodes;
                        div.parentNode.removeChild(div);
                    }
                }
                if (elem.nodeType) {
                    ret.push(elem);
                } else {
                    jQuery.merge(ret, elem);
                }
            }
            if (div) {
                elem = div = safe = null;
            }
            if (!jQuery.support.appendChecked) {
                for (i = 0; (elem = ret[i]) != null; i++) {
                    if (jQuery.nodeName(elem, "input")) {
                        fixDefaultChecked(elem);
                    } else if (typeof elem.getElementsByTagName !== "undefined") {
                        jQuery.grep(elem.getElementsByTagName("input"), fixDefaultChecked);
                    }
                }
            }
            if (fragment) {
                handleScript = function(elem) {
                    if (!elem.type || rscriptType.test(elem.type)) {
                        return scripts ? scripts.push(elem.parentNode ? elem.parentNode.removeChild(elem) : elem) : fragment.appendChild(elem);
                    }
                };
                for (i = 0; (elem = ret[i]) != null; i++) {
                    if (!(jQuery.nodeName(elem, "script") && handleScript(elem))) {
                        fragment.appendChild(elem);
                        if (typeof elem.getElementsByTagName !== "undefined") {
                            jsTags = jQuery.grep(jQuery.merge([], elem.getElementsByTagName("script")), handleScript);
                            ret.splice.apply(ret, [ i + 1, 0 ].concat(jsTags));
                            i += jsTags.length;
                        }
                    }
                }
            }
            return ret;
        },
        cleanData: function(elems, acceptData) {
            var data, id, elem, type, i = 0, internalKey = jQuery.expando, cache = jQuery.cache, deleteExpando = jQuery.support.deleteExpando, special = jQuery.event.special;
            for (;(elem = elems[i]) != null; i++) {
                if (acceptData || jQuery.acceptData(elem)) {
                    id = elem[internalKey];
                    data = id && cache[id];
                    if (data) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        if (cache[id]) {
                            delete cache[id];
                            if (deleteExpando) {
                                delete elem[internalKey];
                            } else if (elem.removeAttribute) {
                                elem.removeAttribute(internalKey);
                            } else {
                                elem[internalKey] = null;
                            }
                            jQuery.deletedIds.push(id);
                        }
                    }
                }
            }
        }
    });
    (function() {
        var matched, browser;
        jQuery.uaMatch = function(ua) {
            ua = ua.toLowerCase();
            var match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
            return {
                browser: match[1] || "",
                version: match[2] || "0"
            };
        };
        matched = jQuery.uaMatch(navigator.userAgent);
        browser = {};
        if (matched.browser) {
            browser[matched.browser] = true;
            browser.version = matched.version;
        }
        if (browser.chrome) {
            browser.webkit = true;
        } else if (browser.webkit) {
            browser.safari = true;
        }
        jQuery.browser = browser;
        jQuery.sub = function() {
            function jQuerySub(selector, context) {
                return new jQuerySub.fn.init(selector, context);
            }
            jQuery.extend(true, jQuerySub, this);
            jQuerySub.superclass = this;
            jQuerySub.fn = jQuerySub.prototype = this();
            jQuerySub.fn.constructor = jQuerySub;
            jQuerySub.sub = this.sub;
            jQuerySub.fn.init = function init(selector, context) {
                if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
                    context = jQuerySub(context);
                }
                return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
            };
            jQuerySub.fn.init.prototype = jQuerySub.fn;
            var rootjQuerySub = jQuerySub(document);
            return jQuerySub;
        };
    })();
    var curCSS, iframe, iframeDoc, ralpha = /alpha\([^)]*\)/i, ropacity = /opacity=([^)]*)/, rposition = /^(top|right|bottom|left)$/, rdisplayswap = /^(none|table(?!-c[ea]).+)/, rmargin = /^margin/, rnumsplit = new RegExp("^(" + core_pnum + ")(.*)$", "i"), rnumnonpx = new RegExp("^(" + core_pnum + ")(?!px)[a-z%]+$", "i"), rrelNum = new RegExp("^([-+])=(" + core_pnum + ")", "i"), elemdisplay = {
        BODY: "block"
    }, cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: 0,
        fontWeight: 400
    }, cssExpand = [ "Top", "Right", "Bottom", "Left" ], cssPrefixes = [ "Webkit", "O", "Moz", "ms" ], eventsToggle = jQuery.fn.toggle;
    function vendorPropName(style, name) {
        if (name in style) {
            return name;
        }
        var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }
        return origName;
    }
    function isHidden(elem, el) {
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    }
    function showHide(elements, show) {
        var elem, display, values = [], index = 0, length = elements.length;
        for (;index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = jQuery._data(elem, "olddisplay");
            if (show) {
                if (!values[index] && elem.style.display === "none") {
                    elem.style.display = "";
                }
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = jQuery._data(elem, "olddisplay", css_defaultDisplay(elem.nodeName));
                }
            } else {
                display = curCSS(elem, "display");
                if (!values[index] && display !== "none") {
                    jQuery._data(elem, "olddisplay", display);
                }
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none";
            }
        }
        return elements;
    }
    jQuery.fn.extend({
        css: function(name, value) {
            return jQuery.access(this, function(elem, name, value) {
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state, fn2) {
            var bool = typeof state === "boolean";
            if (jQuery.isFunction(state) && jQuery.isFunction(fn2)) {
                return eventsToggle.apply(this, arguments);
            }
            return this.each(function() {
                if (bool ? state : isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },
        cssNumber: {
            fillOpacity: true,
            fontWeight: true,
            lineHeight: true,
            opacity: true,
            orphans: true,
            widows: true,
            zIndex: true,
            zoom: true
        },
        cssProps: {
            "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
        },
        style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === "string" && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    type = "number";
                }
                if (value == null || type === "number" && isNaN(value)) {
                    return;
                }
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    try {
                        style[name] = value;
                    } catch (e) {}
                }
            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function(elem, name, numeric, extra) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name);
            }
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (numeric || extra !== undefined) {
                num = parseFloat(val);
                return numeric || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        },
        swap: function(elem, options, callback) {
            var ret, name, old = {};
            for (name in options) {
                old[name] = elem.style[name];
                elem.style[name] = options[name];
            }
            ret = callback.call(elem);
            for (name in options) {
                elem.style[name] = old[name];
            }
            return ret;
        }
    });
    if (window.getComputedStyle) {
        curCSS = function(elem, name) {
            var ret, width, minWidth, maxWidth, computed = window.getComputedStyle(elem, null), style = elem.style;
            if (computed) {
                ret = computed.getPropertyValue(name) || computed[name];
                if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                    ret = jQuery.style(elem, name);
                }
                if (rnumnonpx.test(ret) && rmargin.test(name)) {
                    width = style.width;
                    minWidth = style.minWidth;
                    maxWidth = style.maxWidth;
                    style.minWidth = style.maxWidth = style.width = ret;
                    ret = computed.width;
                    style.width = width;
                    style.minWidth = minWidth;
                    style.maxWidth = maxWidth;
                }
            }
            return ret;
        };
    } else if (document.documentElement.currentStyle) {
        curCSS = function(elem, name) {
            var left, rsLeft, ret = elem.currentStyle && elem.currentStyle[name], style = elem.style;
            if (ret == null && style && style[name]) {
                ret = style[name];
            }
            if (rnumnonpx.test(ret) && !rposition.test(name)) {
                left = style.left;
                rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;
                if (rsLeft) {
                    elem.runtimeStyle.left = elem.currentStyle.left;
                }
                style.left = name === "fontSize" ? "1em" : ret;
                ret = style.pixelLeft + "px";
                style.left = left;
                if (rsLeft) {
                    elem.runtimeStyle.left = rsLeft;
                }
            }
            return ret === "" ? "auto" : ret;
        };
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0, val = 0;
        for (;i < 4; i += 2) {
            if (extra === "margin") {
                val += jQuery.css(elem, extra + cssExpand[i], true);
            }
            if (isBorderBox) {
                if (extra === "content") {
                    val -= parseFloat(curCSS(elem, "padding" + cssExpand[i])) || 0;
                }
                if (extra !== "margin") {
                    val -= parseFloat(curCSS(elem, "border" + cssExpand[i] + "Width")) || 0;
                }
            } else {
                val += parseFloat(curCSS(elem, "padding" + cssExpand[i])) || 0;
                if (extra !== "padding") {
                    val += parseFloat(curCSS(elem, "border" + cssExpand[i] + "Width")) || 0;
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var val = name === "width" ? elem.offsetWidth : elem.offsetHeight, valueIsBorderBox = true, isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, "boxSizing") === "border-box";
        if (val <= 0 || val == null) {
            val = curCSS(elem, name);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox) + "px";
    }
    function css_defaultDisplay(nodeName) {
        if (elemdisplay[nodeName]) {
            return elemdisplay[nodeName];
        }
        var elem = jQuery("<" + nodeName + ">").appendTo(document.body), display = elem.css("display");
        elem.remove();
        if (display === "none" || display === "") {
            iframe = document.body.appendChild(iframe || jQuery.extend(document.createElement("iframe"), {
                frameBorder: 0,
                width: 0,
                height: 0
            }));
            if (!iframeDoc || !iframe.createElement) {
                iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;
                iframeDoc.write("<!doctype html><html><body>");
                iframeDoc.close();
            }
            elem = iframeDoc.body.appendChild(iframeDoc.createElement(nodeName));
            display = curCSS(elem, "display");
            document.body.removeChild(iframe);
        }
        elemdisplay[nodeName] = display;
        return display;
    }
    jQuery.each([ "height", "width" ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) {
                    if (elem.offsetWidth === 0 && rdisplayswap.test(curCSS(elem, "display"))) {
                        return jQuery.swap(elem, cssShow, function() {
                            return getWidthOrHeight(elem, name, extra);
                        });
                    } else {
                        return getWidthOrHeight(elem, name, extra);
                    }
                }
            },
            set: function(elem, value, extra) {
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && jQuery.css(elem, "boxSizing") === "border-box") : 0);
            }
        };
    });
    if (!jQuery.support.opacity) {
        jQuery.cssHooks.opacity = {
            get: function(elem, computed) {
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : computed ? "1" : "";
            },
            set: function(elem, value) {
                var style = elem.style, currentStyle = elem.currentStyle, opacity = jQuery.isNumeric(value) ? "alpha(opacity=" + value * 100 + ")" : "", filter = currentStyle && currentStyle.filter || style.filter || "";
                style.zoom = 1;
                if (value >= 1 && jQuery.trim(filter.replace(ralpha, "")) === "" && style.removeAttribute) {
                    style.removeAttribute("filter");
                    if (currentStyle && !currentStyle.filter) {
                        return;
                    }
                }
                style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + " " + opacity;
            }
        };
    }
    jQuery(function() {
        if (!jQuery.support.reliableMarginRight) {
            jQuery.cssHooks.marginRight = {
                get: function(elem, computed) {
                    return jQuery.swap(elem, {
                        display: "inline-block"
                    }, function() {
                        if (computed) {
                            return curCSS(elem, "marginRight");
                        }
                    });
                }
            };
        }
        if (!jQuery.support.pixelPosition && jQuery.fn.position) {
            jQuery.each([ "top", "left" ], function(i, prop) {
                jQuery.cssHooks[prop] = {
                    get: function(elem, computed) {
                        if (computed) {
                            var ret = curCSS(elem, prop);
                            return rnumnonpx.test(ret) ? jQuery(elem).position()[prop] + "px" : ret;
                        }
                    }
                };
            });
        }
    });
    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.hidden = function(elem) {
            return elem.offsetWidth === 0 && elem.offsetHeight === 0 || !jQuery.support.reliableHiddenOffsets && (elem.style && elem.style.display || curCSS(elem, "display")) === "none";
        };
        jQuery.expr.filters.visible = function(elem) {
            return !jQuery.expr.filters.hidden(elem);
        };
    }
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i, parts = typeof value === "string" ? value.split(" ") : [ value ], expanded = {};
                for (i = 0; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i, rselectTextarea = /^(?:select|textarea)/i;
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                return this.elements ? jQuery.makeArray(this.elements) : this;
            }).filter(function() {
                return this.name && !this.disabled && (this.checked || rselectTextarea.test(this.nodeName) || rinput.test(this.type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val, i) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, value) {
            value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function() {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join("&").replace(r20, "+");
    };
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function(i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === "object") {
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    var ajaxLocParts, ajaxLocation, rhash = /#.*$/, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rquery = /\?/, rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, rts = /([?&])_=[^&]*/, rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/, _load = jQuery.fn.load, prefilters = {}, transports = {}, allTypes = [ "*/" ] + [ "*" ];
    try {
        ajaxLocation = location.href;
    } catch (e) {
        ajaxLocation = document.createElement("a");
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
    function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
            var dataType, list, placeBefore, dataTypes = dataTypeExpression.toLowerCase().split(core_rspace), i = 0, length = dataTypes.length;
            if (jQuery.isFunction(func)) {
                for (;i < length; i++) {
                    dataType = dataTypes[i];
                    placeBefore = /^\+/.test(dataType);
                    if (placeBefore) {
                        dataType = dataType.substr(1) || "*";
                    }
                    list = structure[dataType] = structure[dataType] || [];
                    list[placeBefore ? "unshift" : "push"](func);
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR, dataType, inspected) {
        dataType = dataType || options.dataTypes[0];
        inspected = inspected || {};
        inspected[dataType] = true;
        var selection, list = structure[dataType], i = 0, length = list ? list.length : 0, executeOnly = structure === prefilters;
        for (;i < length && (executeOnly || !selection); i++) {
            selection = list[i](options, originalOptions, jqXHR);
            if (typeof selection === "string") {
                if (!executeOnly || inspected[selection]) {
                    selection = undefined;
                } else {
                    options.dataTypes.unshift(selection);
                    selection = inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR, selection, inspected);
                }
            }
        }
        if ((executeOnly || !selection) && !inspected["*"]) {
            selection = inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR, "*", inspected);
        }
        return selection;
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
    }
    jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
        }
        if (!this.length) {
            return this;
        }
        var selector, type, response, self = this, off = url.indexOf(" ");
        if (off >= 0) {
            selector = url.slice(off, url.length);
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === "object") {
            type = "POST";
        }
        jQuery.ajax({
            url: url,
            type: type,
            dataType: "html",
            data: params,
            complete: function(jqXHR, status) {
                if (callback) {
                    self.each(callback, response || [ jqXHR.responseText, status, jqXHR ]);
                }
            }
        }).done(function(responseText) {
            response = arguments;
            self.html(selector ? jQuery("<div>").append(responseText.replace(rscript, "")).find(selector) : responseText);
        });
        return this;
    };
    jQuery.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function(i, o) {
        jQuery.fn[o] = function(f) {
            return this.on(o, f);
        };
    });
    jQuery.each([ "get", "post" ], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax({
                type: method,
                url: url,
                data: data,
                success: callback,
                dataType: type
            });
        };
    });
    jQuery.extend({
        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        ajaxSetup: function(target, settings) {
            if (settings) {
                ajaxExtend(target, jQuery.ajaxSettings);
            } else {
                settings = target;
                target = jQuery.ajaxSettings;
            }
            ajaxExtend(target, settings);
            return target;
        },
        ajaxSettings: {
            url: ajaxLocation,
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            type: "GET",
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            processData: true,
            async: true,
            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": allTypes
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText"
            },
            converters: {
                "* text": window.String,
                "text html": true,
                "text json": jQuery.parseJSON,
                "text xml": jQuery.parseXML
            },
            flatOptions: {
                context: true,
                url: true
            }
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }
            options = options || {};
            var ifModifiedKey, responseHeadersString, responseHeaders, transport, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = callbackContext !== s && (callbackContext.nodeType || callbackContext instanceof jQuery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = "canceled", jqXHR = {
                readyState: 0,
                setRequestHeader: function(name, value) {
                    if (!state) {
                        var lname = name.toLowerCase();
                        name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : null;
                },
                getResponseHeader: function(key) {
                    var match;
                    if (state === 2) {
                        if (!responseHeaders) {
                            responseHeaders = {};
                            while (match = rheaders.exec(responseHeadersString)) {
                                responseHeaders[match[1].toLowerCase()] = match[2];
                            }
                        }
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return match === undefined ? null : match;
                },
                overrideMimeType: function(type) {
                    if (!state) {
                        s.mimeType = type;
                    }
                    return this;
                },
                abort: function(statusText) {
                    statusText = statusText || strAbort;
                    if (transport) {
                        transport.abort(statusText);
                    }
                    done(0, statusText);
                    return this;
                }
            };
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) {
                    return;
                }
                state = 2;
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || "";
                jqXHR.readyState = status > 0 ? 4 : 0;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                if (status >= 200 && status < 300 || status === 304) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[ifModifiedKey] = modified;
                        }
                        modified = jqXHR.getResponseHeader("Etag");
                        if (modified) {
                            jQuery.etag[ifModifiedKey] = modified;
                        }
                    }
                    if (status === 304) {
                        statusText = "notmodified";
                        isSuccess = true;
                    } else {
                        isSuccess = ajaxConvert(s, response);
                        statusText = isSuccess.state;
                        success = isSuccess.data;
                        error = isSuccess.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (!statusText || status) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]);
                } else {
                    deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger("ajax" + (isSuccess ? "Success" : "Error"), [ jqXHR, s, isSuccess ? success : error ]);
                }
                completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }
            deferred.promise(jqXHR);
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            jqXHR.complete = completeDeferred.add;
            jqXHR.statusCode = function(map) {
                if (map) {
                    var tmp;
                    if (state < 2) {
                        for (tmp in map) {
                            statusCode[tmp] = [ statusCode[tmp], map[tmp] ];
                        }
                    } else {
                        tmp = map[jqXHR.status];
                        jqXHR.always(tmp);
                    }
                }
                return this;
            };
            s.url = ((url || s.url) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().split(core_rspace);
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))));
            }
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) {
                return jqXHR;
            }
            fireGlobals = s.global;
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }
            if (!s.hasContent) {
                if (s.data) {
                    s.url += (rquery.test(s.url) ? "&" : "?") + s.data;
                    delete s.data;
                }
                ifModifiedKey = s.url;
                if (s.cache === false) {
                    var ts = jQuery.now(), ret = s.url.replace(rts, "$1_=" + ts);
                    s.url = ret + (ret === s.url ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : "");
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            if (s.ifModified) {
                ifModifiedKey = ifModifiedKey || s.url;
                if (jQuery.lastModified[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[ifModifiedKey]);
                }
                if (jQuery.etag[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[ifModifiedKey]);
                }
            }
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort();
            }
            strAbort = "abort";
            for (i in {
                success: 1,
                error: 1,
                complete: 1
            }) {
                jqXHR[i](s[i]);
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [ jqXHR, s ]);
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }
            return jqXHR;
        },
        active: 0,
        lastModified: {},
        etag: {}
    });
    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes, responseFields = s.responseFields;
        for (type in responseFields) {
            if (type in responses) {
                jqXHR[responseFields[type]] = responses[type];
            }
        }
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("content-type");
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response) {
        var conv, conv2, current, tmp, dataTypes = s.dataTypes.slice(), prev = dataTypes[0], converters = {}, i = 0;
        if (s.dataFilter) {
            response = s.dataFilter(response, s.dataType);
        }
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        for (;current = dataTypes[++i]; ) {
            if (current !== "*") {
                if (prev !== "*" && prev !== current) {
                    conv = converters[prev + " " + current] || converters["* " + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {
                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.splice(i--, 0, current);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s["throws"]) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
                prev = current;
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    var oldCallbacks = [], rquestion = /\?/, rjsonp = /(=)\?(?=&|$)|\?\?/, nonce = jQuery.now();
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, data = s.data, url = s.url, hasCallback = s.jsonp !== false, replaceInUrl = hasCallback && rjsonp.test(url), replaceInData = hasCallback && !replaceInUrl && typeof data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(data);
        if (s.dataTypes[0] === "jsonp" || replaceInUrl || replaceInData) {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            overwritten = window[callbackName];
            if (replaceInUrl) {
                s.url = url.replace(rjsonp, "$1" + callbackName);
            } else if (replaceInData) {
                s.data = data.replace(rjsonp, "$1" + callbackName);
            } else if (hasCallback) {
                s.url += (rquestion.test(url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            s.converters["script json"] = function() {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            window[callbackName] = function() {
                responseContainer = arguments;
            };
            jqXHR.always(function() {
                window[callbackName] = overwritten;
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return "script";
        }
    });
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /javascript|ecmascript/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
            s.global = false;
        }
    });
    jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;
            return {
                send: function(_, callback) {
                    script = document.createElement("script");
                    script.async = "async";
                    if (s.scriptCharset) {
                        script.charset = s.scriptCharset;
                    }
                    script.src = s.url;
                    script.onload = script.onreadystatechange = function(_, isAbort) {
                        if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
                            script.onload = script.onreadystatechange = null;
                            if (head && script.parentNode) {
                                head.removeChild(script);
                            }
                            script = undefined;
                            if (!isAbort) {
                                callback(200, "success");
                            }
                        }
                    };
                    head.insertBefore(script, head.firstChild);
                },
                abort: function() {
                    if (script) {
                        script.onload(0, 1);
                    }
                }
            };
        }
    });
    var xhrCallbacks, xhrOnUnloadAbort = window.ActiveXObject ? function() {
        for (var key in xhrCallbacks) {
            xhrCallbacks[key](0, 1);
        }
    } : false, xhrId = 0;
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {}
    }
    function createActiveXHR() {
        try {
            return new window.ActiveXObject("Microsoft.XMLHTTP");
        } catch (e) {}
    }
    jQuery.ajaxSettings.xhr = window.ActiveXObject ? function() {
        return !this.isLocal && createStandardXHR() || createActiveXHR();
    } : createStandardXHR;
    (function(xhr) {
        jQuery.extend(jQuery.support, {
            ajax: !!xhr,
            cors: !!xhr && "withCredentials" in xhr
        });
    })(jQuery.ajaxSettings.xhr());
    if (jQuery.support.ajax) {
        jQuery.ajaxTransport(function(s) {
            if (!s.crossDomain || jQuery.support.cors) {
                var callback;
                return {
                    send: function(headers, complete) {
                        var handle, i, xhr = s.xhr();
                        if (s.username) {
                            xhr.open(s.type, s.url, s.async, s.username, s.password);
                        } else {
                            xhr.open(s.type, s.url, s.async);
                        }
                        if (s.xhrFields) {
                            for (i in s.xhrFields) {
                                xhr[i] = s.xhrFields[i];
                            }
                        }
                        if (s.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(s.mimeType);
                        }
                        if (!s.crossDomain && !headers["X-Requested-With"]) {
                            headers["X-Requested-With"] = "XMLHttpRequest";
                        }
                        try {
                            for (i in headers) {
                                xhr.setRequestHeader(i, headers[i]);
                            }
                        } catch (_) {}
                        xhr.send(s.hasContent && s.data || null);
                        callback = function(_, isAbort) {
                            var status, statusText, responseHeaders, responses, xml;
                            try {
                                if (callback && (isAbort || xhr.readyState === 4)) {
                                    callback = undefined;
                                    if (handle) {
                                        xhr.onreadystatechange = jQuery.noop;
                                        if (xhrOnUnloadAbort) {
                                            delete xhrCallbacks[handle];
                                        }
                                    }
                                    if (isAbort) {
                                        if (xhr.readyState !== 4) {
                                            xhr.abort();
                                        }
                                    } else {
                                        status = xhr.status;
                                        responseHeaders = xhr.getAllResponseHeaders();
                                        responses = {};
                                        xml = xhr.responseXML;
                                        if (xml && xml.documentElement) {
                                            responses.xml = xml;
                                        }
                                        try {
                                            responses.text = xhr.responseText;
                                        } catch (e) {}
                                        try {
                                            statusText = xhr.statusText;
                                        } catch (e) {
                                            statusText = "";
                                        }
                                        if (!status && s.isLocal && !s.crossDomain) {
                                            status = responses.text ? 200 : 404;
                                        } else if (status === 1223) {
                                            status = 204;
                                        }
                                    }
                                }
                            } catch (firefoxAccessException) {
                                if (!isAbort) {
                                    complete(-1, firefoxAccessException);
                                }
                            }
                            if (responses) {
                                complete(status, statusText, responses, responseHeaders);
                            }
                        };
                        if (!s.async) {
                            callback();
                        } else if (xhr.readyState === 4) {
                            setTimeout(callback, 0);
                        } else {
                            handle = ++xhrId;
                            if (xhrOnUnloadAbort) {
                                if (!xhrCallbacks) {
                                    xhrCallbacks = {};
                                    jQuery(window).unload(xhrOnUnloadAbort);
                                }
                                xhrCallbacks[handle] = callback;
                            }
                            xhr.onreadystatechange = callback;
                        }
                    },
                    abort: function() {
                        if (callback) {
                            callback(0, 1);
                        }
                    }
                };
            }
        });
    }
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp("^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i"), rrun = /queueHooks$/, animationPrefilters = [ defaultPrefilter ], tweeners = {
        "*": [ function(prop, value) {
            var end, unit, tween = this.createTween(prop, value), parts = rfxnum.exec(value), target = tween.cur(), start = +target || 0, scale = 1, maxIterations = 20;
            if (parts) {
                end = +parts[2];
                unit = parts[3] || (jQuery.cssNumber[prop] ? "" : "px");
                if (unit !== "px" && start) {
                    start = jQuery.css(tween.elem, prop, true) || end || 1;
                    do {
                        scale = scale || ".5";
                        start = start / scale;
                        jQuery.style(tween.elem, prop, start + unit);
                    } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                }
                tween.unit = unit;
                tween.start = start;
                tween.end = parts[1] ? start + (parts[1] + 1) * end : end;
            }
            return tween;
        } ]
    };
    function createFxNow() {
        setTimeout(function() {
            fxNow = undefined;
        }, 0);
        return fxNow = jQuery.now();
    }
    function createTweens(animation, props) {
        jQuery.each(props, function(prop, value) {
            var collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length;
            for (;index < length; index++) {
                if (collection[index].call(animation, prop, value)) {
                    return;
                }
            }
        });
    }
    function Animation(elem, properties, options) {
        var result, index = 0, tweenerIndex = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function() {
            delete tick.elem;
        }), tick = function() {
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
            for (;index < length; index++) {
                animation.tweens[index].run(percent);
            }
            deferred.notifyWith(elem, [ animation, percent, remaining ]);
            if (percent < 1 && length) {
                return remaining;
            } else {
                deferred.resolveWith(elem, [ animation ]);
                return false;
            }
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
                specialEasing: {}
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end, easing) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
            },
            stop: function(gotoEnd) {
                var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                for (;index < length; index++) {
                    animation.tweens[index].run(1);
                }
                if (gotoEnd) {
                    deferred.resolveWith(elem, [ animation, gotoEnd ]);
                } else {
                    deferred.rejectWith(elem, [ animation, gotoEnd ]);
                }
                return this;
            }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (;index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }
        createTweens(animation, props);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            anim: animation,
            queue: animation.opts.queue,
            elem: elem
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = [ "*" ];
            } else {
                props = props.split(" ");
            }
            var prop, index = 0, length = props.length;
            for (;index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },
        prefilter: function(callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });
    function defaultPrefilter(elem, props, opts) {
        var index, prop, value, length, dataShow, toggle, tween, hooks, oldfire, anim = this, style = elem.style, orig = {}, handled = [], hidden = elem.nodeType && isHidden(elem);
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function() {
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
            if (jQuery.css(elem, "display") === "inline" && jQuery.css(elem, "float") === "none") {
                if (!jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay(elem.nodeName) === "inline") {
                    style.display = "inline-block";
                } else {
                    style.zoom = 1;
                }
            }
        }
        if (opts.overflow) {
            style.overflow = "hidden";
            if (!jQuery.support.shrinkWrapBlocks) {
                anim.done(function() {
                    style.overflow = opts.overflow[0];
                    style.overflowX = opts.overflow[1];
                    style.overflowY = opts.overflow[2];
                });
            }
        }
        for (index in props) {
            value = props[index];
            if (rfxtypes.exec(value)) {
                delete props[index];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    continue;
                }
                handled.push(index);
            }
        }
        length = handled.length;
        if (length) {
            dataShow = jQuery._data(elem, "fxshow") || jQuery._data(elem, "fxshow", {});
            if ("hidden" in dataShow) {
                hidden = dataShow.hidden;
            }
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function() {
                    jQuery(elem).hide();
                });
            }
            anim.done(function() {
                var prop;
                jQuery.removeData(elem, "fxshow", true);
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (index = 0; index < length; index++) {
                prop = handled[index];
                tween = anim.createTween(prop, hidden ? dataShow[prop] : 0);
                orig[prop] = dataShow[prop] || jQuery.style(elem, prop);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }
        }
    }
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, false, "");
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" || !i && jQuery.isFunction(speed) && jQuery.isFunction(easing) ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHidden).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                if (empty) {
                    anim.stop(true);
                }
            };
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }
            return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = jQuery._data(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        }
    });
    function genFx(type, includeWidth) {
        var which, attrs = {
            height: type
        }, i = 0;
        includeWidth = includeWidth ? 1 : 0;
        for (;i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2;
        }
    };
    jQuery.timers = [];
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.tick = function() {
        var timer, timers = jQuery.timers, i = 0;
        fxNow = jQuery.now();
        for (;i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) {
        if (timer() && jQuery.timers.push(timer) && !timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.stop = function() {
        clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fx.step = {};
    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.animated = function(elem) {
            return jQuery.grep(jQuery.timers, function(fn) {
                return elem === fn.elem;
            }).length;
        };
    }
    var rroot = /^(?:body|html)$/i;
    jQuery.fn.offset = function(options) {
        if (arguments.length) {
            return options === undefined ? this : this.each(function(i) {
                jQuery.offset.setOffset(this, options, i);
            });
        }
        var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft, box = {
            top: 0,
            left: 0
        }, elem = this[0], doc = elem && elem.ownerDocument;
        if (!doc) {
            return;
        }
        if ((body = doc.body) === elem) {
            return jQuery.offset.bodyOffset(elem);
        }
        docElem = doc.documentElement;
        if (!jQuery.contains(docElem, elem)) {
            return box;
        }
        if (typeof elem.getBoundingClientRect !== "undefined") {
            box = elem.getBoundingClientRect();
        }
        win = getWindow(doc);
        clientTop = docElem.clientTop || body.clientTop || 0;
        clientLeft = docElem.clientLeft || body.clientLeft || 0;
        scrollTop = win.pageYOffset || docElem.scrollTop;
        scrollLeft = win.pageXOffset || docElem.scrollLeft;
        return {
            top: box.top + scrollTop - clientTop,
            left: box.left + scrollLeft - clientLeft
        };
    };
    jQuery.offset = {
        bodyOffset: function(body) {
            var top = body.offsetTop, left = body.offsetLeft;
            if (jQuery.support.doesNotIncludeMarginInBodyOffset) {
                top += parseFloat(jQuery.css(body, "marginTop")) || 0;
                left += parseFloat(jQuery.css(body, "marginLeft")) || 0;
            }
            return {
                top: top,
                left: left
            };
        },
        setOffset: function(elem, options, i) {
            var position = jQuery.css(elem, "position");
            if (position === "static") {
                elem.style.position = "relative";
            }
            var curElem = jQuery(elem), curOffset = curElem.offset(), curCSSTop = jQuery.css(elem, "top"), curCSSLeft = jQuery.css(elem, "left"), calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [ curCSSTop, curCSSLeft ]) > -1, props = {}, curPosition = {}, curTop, curLeft;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        position: function() {
            if (!this[0]) {
                return;
            }
            var elem = this[0], offsetParent = this.offsetParent(), offset = this.offset(), parentOffset = rroot.test(offsetParent[0].nodeName) ? {
                top: 0,
                left: 0
            } : offsetParent.offset();
            offset.top -= parseFloat(jQuery.css(elem, "marginTop")) || 0;
            offset.left -= parseFloat(jQuery.css(elem, "marginLeft")) || 0;
            parentOffset.top += parseFloat(jQuery.css(offsetParent[0], "borderTopWidth")) || 0;
            parentOffset.left += parseFloat(jQuery.css(offsetParent[0], "borderLeftWidth")) || 0;
            return {
                top: offset.top - parentOffset.top,
                left: offset.left - parentOffset.left
            };
        },
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || document.body;
                while (offsetParent && !rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || document.body;
            });
        }
    });
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = /Y/.test(prop);
        jQuery.fn[method] = function(val) {
            return jQuery.access(this, function(elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;
    }
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return jQuery.access(this, function(elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return elem.document.documentElement["client" + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, value, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    window.jQuery = window.$ = jQuery;
    if (typeof define === "function" && define.amd && define.amd.jQuery) {
        define("jquery", [], function() {
            return jQuery;
        });
    }
})(window);

(function() {
    var root = this;
    var previousUnderscore = root._;
    var breaker = {};
    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
    var push = ArrayProto.push, slice = ArrayProto.slice, concat = ArrayProto.concat, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
    var nativeForEach = ArrayProto.forEach, nativeMap = ArrayProto.map, nativeReduce = ArrayProto.reduce, nativeReduceRight = ArrayProto.reduceRight, nativeFilter = ArrayProto.filter, nativeEvery = ArrayProto.every, nativeSome = ArrayProto.some, nativeIndexOf = ArrayProto.indexOf, nativeLastIndexOf = ArrayProto.lastIndexOf, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind;
    var _ = function(obj) {
        if (obj instanceof _) return obj;
        if (!(this instanceof _)) return new _(obj);
        this._wrapped = obj;
    };
    if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
            exports = module.exports = _;
        }
        exports._ = _;
    } else {
        root._ = _;
    }
    _.VERSION = "1.4.4";
    var each = _.each = _.forEach = function(obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
            obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
            for (var i = 0, l = obj.length; i < l; i++) {
                if (iterator.call(context, obj[i], i, obj) === breaker) return;
            }
        } else {
            for (var key in obj) {
                if (_.has(obj, key)) {
                    if (iterator.call(context, obj[key], key, obj) === breaker) return;
                }
            }
        }
    };
    _.map = _.collect = function(obj, iterator, context) {
        var results = [];
        if (obj == null) return results;
        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
        each(obj, function(value, index, list) {
            results[results.length] = iterator.call(context, value, index, list);
        });
        return results;
    };
    var reduceError = "Reduce of empty array with no initial value";
    _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null) obj = [];
        if (nativeReduce && obj.reduce === nativeReduce) {
            if (context) iterator = _.bind(iterator, context);
            return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
        }
        each(obj, function(value, index, list) {
            if (!initial) {
                memo = value;
                initial = true;
            } else {
                memo = iterator.call(context, memo, value, index, list);
            }
        });
        if (!initial) throw new TypeError(reduceError);
        return memo;
    };
    _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null) obj = [];
        if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
            if (context) iterator = _.bind(iterator, context);
            return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
        }
        var length = obj.length;
        if (length !== +length) {
            var keys = _.keys(obj);
            length = keys.length;
        }
        each(obj, function(value, index, list) {
            index = keys ? keys[--length] : --length;
            if (!initial) {
                memo = obj[index];
                initial = true;
            } else {
                memo = iterator.call(context, memo, obj[index], index, list);
            }
        });
        if (!initial) throw new TypeError(reduceError);
        return memo;
    };
    _.find = _.detect = function(obj, iterator, context) {
        var result;
        any(obj, function(value, index, list) {
            if (iterator.call(context, value, index, list)) {
                result = value;
                return true;
            }
        });
        return result;
    };
    _.filter = _.select = function(obj, iterator, context) {
        var results = [];
        if (obj == null) return results;
        if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
        each(obj, function(value, index, list) {
            if (iterator.call(context, value, index, list)) results[results.length] = value;
        });
        return results;
    };
    _.reject = function(obj, iterator, context) {
        return _.filter(obj, function(value, index, list) {
            return !iterator.call(context, value, index, list);
        }, context);
    };
    _.every = _.all = function(obj, iterator, context) {
        iterator || (iterator = _.identity);
        var result = true;
        if (obj == null) return result;
        if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
        each(obj, function(value, index, list) {
            if (!(result = result && iterator.call(context, value, index, list))) return breaker;
        });
        return !!result;
    };
    var any = _.some = _.any = function(obj, iterator, context) {
        iterator || (iterator = _.identity);
        var result = false;
        if (obj == null) return result;
        if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
        each(obj, function(value, index, list) {
            if (result || (result = iterator.call(context, value, index, list))) return breaker;
        });
        return !!result;
    };
    _.contains = _.include = function(obj, target) {
        if (obj == null) return false;
        if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
        return any(obj, function(value) {
            return value === target;
        });
    };
    _.invoke = function(obj, method) {
        var args = slice.call(arguments, 2);
        var isFunc = _.isFunction(method);
        return _.map(obj, function(value) {
            return (isFunc ? method : value[method]).apply(value, args);
        });
    };
    _.pluck = function(obj, key) {
        return _.map(obj, function(value) {
            return value[key];
        });
    };
    _.where = function(obj, attrs, first) {
        if (_.isEmpty(attrs)) return first ? null : [];
        return _[first ? "find" : "filter"](obj, function(value) {
            for (var key in attrs) {
                if (attrs[key] !== value[key]) return false;
            }
            return true;
        });
    };
    _.findWhere = function(obj, attrs) {
        return _.where(obj, attrs, true);
    };
    _.max = function(obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
            return Math.max.apply(Math, obj);
        }
        if (!iterator && _.isEmpty(obj)) return -Infinity;
        var result = {
            computed: -Infinity,
            value: -Infinity
        };
        each(obj, function(value, index, list) {
            var computed = iterator ? iterator.call(context, value, index, list) : value;
            computed >= result.computed && (result = {
                value: value,
                computed: computed
            });
        });
        return result.value;
    };
    _.min = function(obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
            return Math.min.apply(Math, obj);
        }
        if (!iterator && _.isEmpty(obj)) return Infinity;
        var result = {
            computed: Infinity,
            value: Infinity
        };
        each(obj, function(value, index, list) {
            var computed = iterator ? iterator.call(context, value, index, list) : value;
            computed < result.computed && (result = {
                value: value,
                computed: computed
            });
        });
        return result.value;
    };
    _.shuffle = function(obj) {
        var rand;
        var index = 0;
        var shuffled = [];
        each(obj, function(value) {
            rand = _.random(index++);
            shuffled[index - 1] = shuffled[rand];
            shuffled[rand] = value;
        });
        return shuffled;
    };
    var lookupIterator = function(value) {
        return _.isFunction(value) ? value : function(obj) {
            return obj[value];
        };
    };
    _.sortBy = function(obj, value, context) {
        var iterator = lookupIterator(value);
        return _.pluck(_.map(obj, function(value, index, list) {
            return {
                value: value,
                index: index,
                criteria: iterator.call(context, value, index, list)
            };
        }).sort(function(left, right) {
            var a = left.criteria;
            var b = right.criteria;
            if (a !== b) {
                if (a > b || a === void 0) return 1;
                if (a < b || b === void 0) return -1;
            }
            return left.index < right.index ? -1 : 1;
        }), "value");
    };
    var group = function(obj, value, context, behavior) {
        var result = {};
        var iterator = lookupIterator(value || _.identity);
        each(obj, function(value, index) {
            var key = iterator.call(context, value, index, obj);
            behavior(result, key, value);
        });
        return result;
    };
    _.groupBy = function(obj, value, context) {
        return group(obj, value, context, function(result, key, value) {
            (_.has(result, key) ? result[key] : result[key] = []).push(value);
        });
    };
    _.countBy = function(obj, value, context) {
        return group(obj, value, context, function(result, key) {
            if (!_.has(result, key)) result[key] = 0;
            result[key]++;
        });
    };
    _.sortedIndex = function(array, obj, iterator, context) {
        iterator = iterator == null ? _.identity : lookupIterator(iterator);
        var value = iterator.call(context, obj);
        var low = 0, high = array.length;
        while (low < high) {
            var mid = low + high >>> 1;
            iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
        }
        return low;
    };
    _.toArray = function(obj) {
        if (!obj) return [];
        if (_.isArray(obj)) return slice.call(obj);
        if (obj.length === +obj.length) return _.map(obj, _.identity);
        return _.values(obj);
    };
    _.size = function(obj) {
        if (obj == null) return 0;
        return obj.length === +obj.length ? obj.length : _.keys(obj).length;
    };
    _.first = _.head = _.take = function(array, n, guard) {
        if (array == null) return void 0;
        return n != null && !guard ? slice.call(array, 0, n) : array[0];
    };
    _.initial = function(array, n, guard) {
        return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));
    };
    _.last = function(array, n, guard) {
        if (array == null) return void 0;
        if (n != null && !guard) {
            return slice.call(array, Math.max(array.length - n, 0));
        } else {
            return array[array.length - 1];
        }
    };
    _.rest = _.tail = _.drop = function(array, n, guard) {
        return slice.call(array, n == null || guard ? 1 : n);
    };
    _.compact = function(array) {
        return _.filter(array, _.identity);
    };
    var flatten = function(input, shallow, output) {
        each(input, function(value) {
            if (_.isArray(value)) {
                shallow ? push.apply(output, value) : flatten(value, shallow, output);
            } else {
                output.push(value);
            }
        });
        return output;
    };
    _.flatten = function(array, shallow) {
        return flatten(array, shallow, []);
    };
    _.without = function(array) {
        return _.difference(array, slice.call(arguments, 1));
    };
    _.uniq = _.unique = function(array, isSorted, iterator, context) {
        if (_.isFunction(isSorted)) {
            context = iterator;
            iterator = isSorted;
            isSorted = false;
        }
        var initial = iterator ? _.map(array, iterator, context) : array;
        var results = [];
        var seen = [];
        each(initial, function(value, index) {
            if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {
                seen.push(value);
                results.push(array[index]);
            }
        });
        return results;
    };
    _.union = function() {
        return _.uniq(concat.apply(ArrayProto, arguments));
    };
    _.intersection = function(array) {
        var rest = slice.call(arguments, 1);
        return _.filter(_.uniq(array), function(item) {
            return _.every(rest, function(other) {
                return _.indexOf(other, item) >= 0;
            });
        });
    };
    _.difference = function(array) {
        var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
        return _.filter(array, function(value) {
            return !_.contains(rest, value);
        });
    };
    _.zip = function() {
        var args = slice.call(arguments);
        var length = _.max(_.pluck(args, "length"));
        var results = new Array(length);
        for (var i = 0; i < length; i++) {
            results[i] = _.pluck(args, "" + i);
        }
        return results;
    };
    _.object = function(list, values) {
        if (list == null) return {};
        var result = {};
        for (var i = 0, l = list.length; i < l; i++) {
            if (values) {
                result[list[i]] = values[i];
            } else {
                result[list[i][0]] = list[i][1];
            }
        }
        return result;
    };
    _.indexOf = function(array, item, isSorted) {
        if (array == null) return -1;
        var i = 0, l = array.length;
        if (isSorted) {
            if (typeof isSorted == "number") {
                i = isSorted < 0 ? Math.max(0, l + isSorted) : isSorted;
            } else {
                i = _.sortedIndex(array, item);
                return array[i] === item ? i : -1;
            }
        }
        if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
        for (;i < l; i++) if (array[i] === item) return i;
        return -1;
    };
    _.lastIndexOf = function(array, item, from) {
        if (array == null) return -1;
        var hasIndex = from != null;
        if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
            return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
        }
        var i = hasIndex ? from : array.length;
        while (i--) if (array[i] === item) return i;
        return -1;
    };
    _.range = function(start, stop, step) {
        if (arguments.length <= 1) {
            stop = start || 0;
            start = 0;
        }
        step = arguments[2] || 1;
        var len = Math.max(Math.ceil((stop - start) / step), 0);
        var idx = 0;
        var range = new Array(len);
        while (idx < len) {
            range[idx++] = start;
            start += step;
        }
        return range;
    };
    _.bind = function(func, context) {
        if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
        var args = slice.call(arguments, 2);
        return function() {
            return func.apply(context, args.concat(slice.call(arguments)));
        };
    };
    _.partial = function(func) {
        var args = slice.call(arguments, 1);
        return function() {
            return func.apply(this, args.concat(slice.call(arguments)));
        };
    };
    _.bindAll = function(obj) {
        var funcs = slice.call(arguments, 1);
        if (funcs.length === 0) funcs = _.functions(obj);
        each(funcs, function(f) {
            obj[f] = _.bind(obj[f], obj);
        });
        return obj;
    };
    _.memoize = function(func, hasher) {
        var memo = {};
        hasher || (hasher = _.identity);
        return function() {
            var key = hasher.apply(this, arguments);
            return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);
        };
    };
    _.delay = function(func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function() {
            return func.apply(null, args);
        }, wait);
    };
    _.defer = function(func) {
        return _.delay.apply(_, [ func, 1 ].concat(slice.call(arguments, 1)));
    };
    _.throttle = function(func, wait) {
        var context, args, timeout, result;
        var previous = 0;
        var later = function() {
            previous = new Date();
            timeout = null;
            result = func.apply(context, args);
        };
        return function() {
            var now = new Date();
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0) {
                clearTimeout(timeout);
                timeout = null;
                previous = now;
                result = func.apply(context, args);
            } else if (!timeout) {
                timeout = setTimeout(later, remaining);
            }
            return result;
        };
    };
    _.debounce = function(func, wait, immediate) {
        var timeout, result;
        return function() {
            var context = this, args = arguments;
            var later = function() {
                timeout = null;
                if (!immediate) result = func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) result = func.apply(context, args);
            return result;
        };
    };
    _.once = function(func) {
        var ran = false, memo;
        return function() {
            if (ran) return memo;
            ran = true;
            memo = func.apply(this, arguments);
            func = null;
            return memo;
        };
    };
    _.wrap = function(func, wrapper) {
        return function() {
            var args = [ func ];
            push.apply(args, arguments);
            return wrapper.apply(this, args);
        };
    };
    _.compose = function() {
        var funcs = arguments;
        return function() {
            var args = arguments;
            for (var i = funcs.length - 1; i >= 0; i--) {
                args = [ funcs[i].apply(this, args) ];
            }
            return args[0];
        };
    };
    _.after = function(times, func) {
        if (times <= 0) return func();
        return function() {
            if (--times < 1) {
                return func.apply(this, arguments);
            }
        };
    };
    _.keys = nativeKeys || function(obj) {
        if (obj !== Object(obj)) throw new TypeError("Invalid object");
        var keys = [];
        for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
        return keys;
    };
    _.values = function(obj) {
        var values = [];
        for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
        return values;
    };
    _.pairs = function(obj) {
        var pairs = [];
        for (var key in obj) if (_.has(obj, key)) pairs.push([ key, obj[key] ]);
        return pairs;
    };
    _.invert = function(obj) {
        var result = {};
        for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
        return result;
    };
    _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) {
            if (_.isFunction(obj[key])) names.push(key);
        }
        return names.sort();
    };
    _.extend = function(obj) {
        each(slice.call(arguments, 1), function(source) {
            if (source) {
                for (var prop in source) {
                    obj[prop] = source[prop];
                }
            }
        });
        return obj;
    };
    _.pick = function(obj) {
        var copy = {};
        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
        each(keys, function(key) {
            if (key in obj) copy[key] = obj[key];
        });
        return copy;
    };
    _.omit = function(obj) {
        var copy = {};
        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
        for (var key in obj) {
            if (!_.contains(keys, key)) copy[key] = obj[key];
        }
        return copy;
    };
    _.defaults = function(obj) {
        each(slice.call(arguments, 1), function(source) {
            if (source) {
                for (var prop in source) {
                    if (obj[prop] == null) obj[prop] = source[prop];
                }
            }
        });
        return obj;
    };
    _.clone = function(obj) {
        if (!_.isObject(obj)) return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };
    _.tap = function(obj, interceptor) {
        interceptor(obj);
        return obj;
    };
    var eq = function(a, b, aStack, bStack) {
        if (a === b) return a !== 0 || 1 / a == 1 / b;
        if (a == null || b == null) return a === b;
        if (a instanceof _) a = a._wrapped;
        if (b instanceof _) b = b._wrapped;
        var className = toString.call(a);
        if (className != toString.call(b)) return false;
        switch (className) {
          case "[object String]":
            return a == String(b);

          case "[object Number]":
            return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

          case "[object Date]":
          case "[object Boolean]":
            return +a == +b;

          case "[object RegExp]":
            return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
        }
        if (typeof a != "object" || typeof b != "object") return false;
        var length = aStack.length;
        while (length--) {
            if (aStack[length] == a) return bStack[length] == b;
        }
        aStack.push(a);
        bStack.push(b);
        var size = 0, result = true;
        if (className == "[object Array]") {
            size = a.length;
            result = size == b.length;
            if (result) {
                while (size--) {
                    if (!(result = eq(a[size], b[size], aStack, bStack))) break;
                }
            }
        } else {
            var aCtor = a.constructor, bCtor = b.constructor;
            if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor)) {
                return false;
            }
            for (var key in a) {
                if (_.has(a, key)) {
                    size++;
                    if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
                }
            }
            if (result) {
                for (key in b) {
                    if (_.has(b, key) && !size--) break;
                }
                result = !size;
            }
        }
        aStack.pop();
        bStack.pop();
        return result;
    };
    _.isEqual = function(a, b) {
        return eq(a, b, [], []);
    };
    _.isEmpty = function(obj) {
        if (obj == null) return true;
        if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
        for (var key in obj) if (_.has(obj, key)) return false;
        return true;
    };
    _.isElement = function(obj) {
        return !!(obj && obj.nodeType === 1);
    };
    _.isArray = nativeIsArray || function(obj) {
        return toString.call(obj) == "[object Array]";
    };
    _.isObject = function(obj) {
        return obj === Object(obj);
    };
    each([ "Arguments", "Function", "String", "Number", "Date", "RegExp" ], function(name) {
        _["is" + name] = function(obj) {
            return toString.call(obj) == "[object " + name + "]";
        };
    });
    if (!_.isArguments(arguments)) {
        _.isArguments = function(obj) {
            return !!(obj && _.has(obj, "callee"));
        };
    }
    if (typeof /./ !== "function") {
        _.isFunction = function(obj) {
            return typeof obj === "function";
        };
    }
    _.isFinite = function(obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj));
    };
    _.isNaN = function(obj) {
        return _.isNumber(obj) && obj != +obj;
    };
    _.isBoolean = function(obj) {
        return obj === true || obj === false || toString.call(obj) == "[object Boolean]";
    };
    _.isNull = function(obj) {
        return obj === null;
    };
    _.isUndefined = function(obj) {
        return obj === void 0;
    };
    _.has = function(obj, key) {
        return hasOwnProperty.call(obj, key);
    };
    _.noConflict = function() {
        root._ = previousUnderscore;
        return this;
    };
    _.identity = function(value) {
        return value;
    };
    _.times = function(n, iterator, context) {
        var accum = Array(n);
        for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
        return accum;
    };
    _.random = function(min, max) {
        if (max == null) {
            max = min;
            min = 0;
        }
        return min + Math.floor(Math.random() * (max - min + 1));
    };
    var entityMap = {
        escape: {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;",
            "/": "&#x2F;"
        }
    };
    entityMap.unescape = _.invert(entityMap.escape);
    var entityRegexes = {
        escape: new RegExp("[" + _.keys(entityMap.escape).join("") + "]", "g"),
        unescape: new RegExp("(" + _.keys(entityMap.unescape).join("|") + ")", "g")
    };
    _.each([ "escape", "unescape" ], function(method) {
        _[method] = function(string) {
            if (string == null) return "";
            return ("" + string).replace(entityRegexes[method], function(match) {
                return entityMap[method][match];
            });
        };
    });
    _.result = function(object, property) {
        if (object == null) return null;
        var value = object[property];
        return _.isFunction(value) ? value.call(object) : value;
    };
    _.mixin = function(obj) {
        each(_.functions(obj), function(name) {
            var func = _[name] = obj[name];
            _.prototype[name] = function() {
                var args = [ this._wrapped ];
                push.apply(args, arguments);
                return result.call(this, func.apply(_, args));
            };
        });
    };
    var idCounter = 0;
    _.uniqueId = function(prefix) {
        var id = ++idCounter + "";
        return prefix ? prefix + id : id;
    };
    _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };
    var noMatch = /(.)^/;
    var escapes = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "	": "t",
        "\u2028": "u2028",
        "\u2029": "u2029"
    };
    var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
    _.template = function(text, data, settings) {
        var render;
        settings = _.defaults({}, settings, _.templateSettings);
        var matcher = new RegExp([ (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source ].join("|") + "|$", "g");
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
            source += text.slice(index, offset).replace(escaper, function(match) {
                return "\\" + escapes[match];
            });
            if (escape) {
                source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
            }
            if (interpolate) {
                source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
            }
            if (evaluate) {
                source += "';\n" + evaluate + "\n__p+='";
            }
            index = offset + match.length;
            return match;
        });
        source += "';\n";
        if (!settings.variable) source = "with(obj||{}){\n" + source + "}\n";
        source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
        try {
            render = new Function(settings.variable || "obj", "_", source);
        } catch (e) {
            e.source = source;
            throw e;
        }
        if (data) return render(data, _);
        var template = function(data) {
            return render.call(this, data, _);
        };
        template.source = "function(" + (settings.variable || "obj") + "){\n" + source + "}";
        return template;
    };
    _.chain = function(obj) {
        return _(obj).chain();
    };
    var result = function(obj) {
        return this._chain ? _(obj).chain() : obj;
    };
    _.mixin(_);
    each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            var obj = this._wrapped;
            method.apply(obj, arguments);
            if ((name == "shift" || name == "splice") && obj.length === 0) delete obj[0];
            return result.call(this, obj);
        };
    });
    each([ "concat", "join", "slice" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            return result.call(this, method.apply(this._wrapped, arguments));
        };
    });
    _.extend(_.prototype, {
        chain: function() {
            this._chain = true;
            return this;
        },
        value: function() {
            return this._wrapped;
        }
    });
}).call(this);

if (typeof JSON !== "object") {
    JSON = {};
}

(function() {
    "use strict";
    function f(n) {
        return n < 10 ? "0" + n : n;
    }
    if (typeof Date.prototype.toJSON !== "function") {
        Date.prototype.toJSON = function(key) {
            return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null;
        };
        String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function(key) {
            return this.valueOf();
        };
    }
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
    }, rep;
    function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
            var c = meta[a];
            return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }
    function str(key, holder) {
        var i, k, v, length, mind = gap, partial, value = holder[key];
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
            value = value.toJSON(key);
        }
        if (typeof rep === "function") {
            value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            return quote(value);

          case "number":
            return isFinite(value) ? String(value) : "null";

          case "boolean":
          case "null":
            return String(value);

          case "object":
            if (!value) {
                return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || "null";
                }
                v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
                gap = mind;
                return v;
            }
            if (rep && typeof rep === "object") {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === "string") {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ": " : ":") + v);
                        }
                    }
                }
            } else {
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ": " : ":") + v);
                        }
                    }
                }
            }
            v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
    }
    JSON.stringifyCompat = function(value, replacer, space) {
        var i;
        gap = "";
        indent = "";
        if (typeof space === "number") {
            for (i = 0; i < space; i += 1) {
                indent += " ";
            }
        } else if (typeof space === "string") {
            indent = space;
        }
        rep = replacer;
        if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
        }
        return str("", {
            "": value
        });
    };
    JSON.parseCompat = function(text, reviver) {
        var j;
        function walk(holder, key) {
            var k, v, value = holder[key];
            if (value && typeof value === "object") {
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = walk(value, k);
                        if (v !== undefined) {
                            value[k] = v;
                        } else {
                            delete value[k];
                        }
                    }
                }
            }
            return reviver.call(holder, key, value);
        }
        text = String(text);
        cx.lastIndex = 0;
        if (cx.test(text)) {
            text = text.replace(cx, function(a) {
                return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            });
        }
        if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) {
            j = eval("(" + text + ")");
            return typeof reviver === "function" ? walk({
                "": j
            }, "") : j;
        }
        throw new SyntaxError("JSON.parse");
    };
})();

(function() {
    var root = this;
    var previousBackbone = root.Backbone;
    var array = [];
    var push = array.push;
    var slice = array.slice;
    var splice = array.splice;
    var Backbone;
    if (typeof exports !== "undefined") {
        Backbone = exports;
    } else {
        Backbone = root.Backbone = {};
    }
    Backbone.VERSION = "1.0.0";
    var _ = root._;
    if (!_ && typeof require !== "undefined") _ = require("underscore");
    Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;
    Backbone.noConflict = function() {
        root.Backbone = previousBackbone;
        return this;
    };
    Backbone.emulateHTTP = false;
    Backbone.emulateJSON = false;
    var Events = Backbone.Events = {
        on: function(name, callback, context) {
            if (!eventsApi(this, "on", name, [ callback, context ]) || !callback) return this;
            this._events || (this._events = {});
            var events = this._events[name] || (this._events[name] = []);
            events.push({
                callback: callback,
                context: context,
                ctx: context || this
            });
            return this;
        },
        once: function(name, callback, context) {
            if (!eventsApi(this, "once", name, [ callback, context ]) || !callback) return this;
            var self = this;
            var once = _.once(function() {
                self.off(name, once);
                callback.apply(this, arguments);
            });
            once._callback = callback;
            return this.on(name, once, context);
        },
        off: function(name, callback, context) {
            var retain, ev, events, names, i, l, j, k;
            if (!this._events || !eventsApi(this, "off", name, [ callback, context ])) return this;
            if (!name && !callback && !context) {
                this._events = {};
                return this;
            }
            names = name ? [ name ] : _.keys(this._events);
            for (i = 0, l = names.length; i < l; i++) {
                name = names[i];
                if (events = this._events[name]) {
                    this._events[name] = retain = [];
                    if (callback || context) {
                        for (j = 0, k = events.length; j < k; j++) {
                            ev = events[j];
                            if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {
                                retain.push(ev);
                            }
                        }
                    }
                    if (!retain.length) delete this._events[name];
                }
            }
            return this;
        },
        trigger: function(name) {
            if (!this._events) return this;
            var args = slice.call(arguments, 1);
            if (!eventsApi(this, "trigger", name, args)) return this;
            var events = this._events[name];
            var allEvents = this._events.all;
            if (events) triggerEvents(events, args);
            if (allEvents) triggerEvents(allEvents, arguments);
            return this;
        },
        stopListening: function(obj, name, callback) {
            var listeners = this._listeners;
            if (!listeners) return this;
            var deleteListener = !name && !callback;
            if (typeof name === "object") callback = this;
            if (obj) (listeners = {})[obj._listenerId] = obj;
            for (var id in listeners) {
                listeners[id].off(name, callback, this);
                if (deleteListener) delete this._listeners[id];
            }
            return this;
        }
    };
    var eventSplitter = /\s+/;
    var eventsApi = function(obj, action, name, rest) {
        if (!name) return true;
        if (typeof name === "object") {
            for (var key in name) {
                obj[action].apply(obj, [ key, name[key] ].concat(rest));
            }
            return false;
        }
        if (eventSplitter.test(name)) {
            var names = name.split(eventSplitter);
            for (var i = 0, l = names.length; i < l; i++) {
                obj[action].apply(obj, [ names[i] ].concat(rest));
            }
            return false;
        }
        return true;
    };
    var triggerEvents = function(events, args) {
        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
        switch (args.length) {
          case 0:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx);
            return;

          case 1:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1);
            return;

          case 2:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2);
            return;

          case 3:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
            return;

          default:
            while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
        }
    };
    var listenMethods = {
        listenTo: "on",
        listenToOnce: "once"
    };
    _.each(listenMethods, function(implementation, method) {
        Events[method] = function(obj, name, callback) {
            var listeners = this._listeners || (this._listeners = {});
            var id = obj._listenerId || (obj._listenerId = _.uniqueId("l"));
            listeners[id] = obj;
            if (typeof name === "object") callback = this;
            obj[implementation](name, callback, this);
            return this;
        };
    });
    Events.bind = Events.on;
    Events.unbind = Events.off;
    _.extend(Backbone, Events);
    var Model = Backbone.Model = function(attributes, options) {
        var defaults;
        var attrs = attributes || {};
        options || (options = {});
        this.cid = _.uniqueId("c");
        this.attributes = {};
        _.extend(this, _.pick(options, modelOptions));
        if (options.parse) attrs = this.parse(attrs, options) || {};
        if (defaults = _.result(this, "defaults")) {
            attrs = _.defaults({}, attrs, defaults);
        }
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
    };
    var modelOptions = [ "url", "urlRoot", "collection" ];
    _.extend(Model.prototype, Events, {
        changed: null,
        validationError: null,
        idAttribute: "id",
        initialize: function() {},
        toJSON: function(options) {
            return _.clone(this.attributes);
        },
        sync: function() {
            return Backbone.sync.apply(this, arguments);
        },
        get: function(attr) {
            return this.attributes[attr];
        },
        escape: function(attr) {
            return _.escape(this.get(attr));
        },
        has: function(attr) {
            return this.get(attr) != null;
        },
        set: function(key, val, options) {
            var attr, attrs, unset, changes, silent, changing, prev, current;
            if (key == null) return this;
            if (typeof key === "object") {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }
            options || (options = {});
            if (!this._validate(attrs, options)) return false;
            unset = options.unset;
            silent = options.silent;
            changes = [];
            changing = this._changing;
            this._changing = true;
            if (!changing) {
                this._previousAttributes = _.clone(this.attributes);
                this.changed = {};
            }
            current = this.attributes, prev = this._previousAttributes;
            if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];
            for (attr in attrs) {
                val = attrs[attr];
                if (!_.isEqual(current[attr], val)) changes.push(attr);
                if (!_.isEqual(prev[attr], val)) {
                    this.changed[attr] = val;
                } else {
                    delete this.changed[attr];
                }
                unset ? delete current[attr] : current[attr] = val;
            }
            if (!silent) {
                if (changes.length) this._pending = true;
                for (var i = 0, l = changes.length; i < l; i++) {
                    this.trigger("change:" + changes[i], this, current[changes[i]], options);
                }
            }
            if (changing) return this;
            if (!silent) {
                while (this._pending) {
                    this._pending = false;
                    this.trigger("change", this, options);
                }
            }
            this._pending = false;
            this._changing = false;
            return this;
        },
        unset: function(attr, options) {
            return this.set(attr, void 0, _.extend({}, options, {
                unset: true
            }));
        },
        clear: function(options) {
            var attrs = {};
            for (var key in this.attributes) attrs[key] = void 0;
            return this.set(attrs, _.extend({}, options, {
                unset: true
            }));
        },
        hasChanged: function(attr) {
            if (attr == null) return !_.isEmpty(this.changed);
            return _.has(this.changed, attr);
        },
        changedAttributes: function(diff) {
            if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
            var val, changed = false;
            var old = this._changing ? this._previousAttributes : this.attributes;
            for (var attr in diff) {
                if (_.isEqual(old[attr], val = diff[attr])) continue;
                (changed || (changed = {}))[attr] = val;
            }
            return changed;
        },
        previous: function(attr) {
            if (attr == null || !this._previousAttributes) return null;
            return this._previousAttributes[attr];
        },
        previousAttributes: function() {
            return _.clone(this._previousAttributes);
        },
        fetch: function(options) {
            options = options ? _.clone(options) : {};
            if (options.parse === void 0) options.parse = true;
            var model = this;
            var success = options.success;
            options.success = function(resp) {
                if (!model.set(model.parse(resp, options), options)) return false;
                if (success) success(model, resp, options);
                model.trigger("sync", model, resp, options);
            };
            wrapError(this, options);
            return this.sync("read", this, options);
        },
        save: function(key, val, options) {
            var attrs, method, xhr, attributes = this.attributes;
            if (key == null || typeof key === "object") {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }
            if (attrs && (!options || !options.wait) && !this.set(attrs, options)) return false;
            options = _.extend({
                validate: true
            }, options);
            if (!this._validate(attrs, options)) return false;
            if (attrs && options.wait) {
                this.attributes = _.extend({}, attributes, attrs);
            }
            if (options.parse === void 0) options.parse = true;
            var model = this;
            var success = options.success;
            options.success = function(resp) {
                model.attributes = attributes;
                var serverAttrs = model.parse(resp, options);
                if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
                if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
                    return false;
                }
                if (success) success(model, resp, options);
                model.trigger("sync", model, resp, options);
            };
            wrapError(this, options);
            method = this.isNew() ? "create" : options.patch ? "patch" : "update";
            if (method === "patch") options.attrs = attrs;
            xhr = this.sync(method, this, options);
            if (attrs && options.wait) this.attributes = attributes;
            return xhr;
        },
        destroy: function(options) {
            options = options ? _.clone(options) : {};
            var model = this;
            var success = options.success;
            var destroy = function() {
                model.trigger("destroy", model, model.collection, options);
            };
            options.success = function(resp) {
                if (options.wait || model.isNew()) destroy();
                if (success) success(model, resp, options);
                if (!model.isNew()) model.trigger("sync", model, resp, options);
            };
            if (this.isNew()) {
                options.success();
                return false;
            }
            wrapError(this, options);
            var xhr = this.sync("delete", this, options);
            if (!options.wait) destroy();
            return xhr;
        },
        url: function() {
            var base = _.result(this, "urlRoot") || _.result(this.collection, "url") || urlError();
            if (this.isNew()) return base;
            return base + (base.charAt(base.length - 1) === "/" ? "" : "/") + encodeURIComponent(this.id);
        },
        parse: function(resp, options) {
            return resp;
        },
        clone: function() {
            return new this.constructor(this.attributes);
        },
        isNew: function() {
            return this.id == null;
        },
        isValid: function(options) {
            return this._validate({}, _.extend(options || {}, {
                validate: true
            }));
        },
        _validate: function(attrs, options) {
            if (!options.validate || !this.validate) return true;
            attrs = _.extend({}, this.attributes, attrs);
            var error = this.validationError = this.validate(attrs, options) || null;
            if (!error) return true;
            this.trigger("invalid", this, error, _.extend(options || {}, {
                validationError: error
            }));
            return false;
        }
    });
    var modelMethods = [ "keys", "values", "pairs", "invert", "pick", "omit" ];
    _.each(modelMethods, function(method) {
        Model.prototype[method] = function() {
            var args = slice.call(arguments);
            args.unshift(this.attributes);
            return _[method].apply(_, args);
        };
    });
    var Collection = Backbone.Collection = function(models, options) {
        options || (options = {});
        if (options.url) this.url = options.url;
        if (options.model) this.model = options.model;
        if (options.comparator !== void 0) this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models) this.reset(models, _.extend({
            silent: true
        }, options));
    };
    var setOptions = {
        add: true,
        remove: true,
        merge: true
    };
    var addOptions = {
        add: true,
        merge: false,
        remove: false
    };
    _.extend(Collection.prototype, Events, {
        model: Model,
        initialize: function() {},
        toJSON: function(options) {
            return this.map(function(model) {
                return model.toJSON(options);
            });
        },
        sync: function() {
            return Backbone.sync.apply(this, arguments);
        },
        add: function(models, options) {
            return this.set(models, _.defaults(options || {}, addOptions));
        },
        remove: function(models, options) {
            models = _.isArray(models) ? models.slice() : [ models ];
            options || (options = {});
            var i, l, index, model;
            for (i = 0, l = models.length; i < l; i++) {
                model = this.get(models[i]);
                if (!model) continue;
                delete this._byId[model.id];
                delete this._byId[model.cid];
                index = this.indexOf(model);
                this.models.splice(index, 1);
                this.length--;
                if (!options.silent) {
                    options.index = index;
                    model.trigger("remove", model, this, options);
                }
                this._removeReference(model);
            }
            return this;
        },
        set: function(models, options) {
            options = _.defaults(options || {}, setOptions);
            if (options.parse) models = this.parse(models, options);
            if (!_.isArray(models)) models = models ? [ models ] : [];
            var i, l, model, attrs, existing, sort;
            var at = options.at;
            var sortable = this.comparator && at == null && options.sort !== false;
            var sortAttr = _.isString(this.comparator) ? this.comparator : null;
            var toAdd = [], toRemove = [], modelMap = {};
            for (i = 0, l = models.length; i < l; i++) {
                if (!(model = this._prepareModel(models[i], options))) continue;
                if (existing = this.get(model)) {
                    if (options.remove) modelMap[existing.cid] = true;
                    if (options.merge) {
                        existing.set(model.attributes, options);
                        if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
                    }
                } else if (options.add) {
                    toAdd.push(model);
                    model.on("all", this._onModelEvent, this);
                    this._byId[model.cid] = model;
                    if (model.id != null) this._byId[model.id] = model;
                }
            }
            if (options.remove) {
                for (i = 0, l = this.length; i < l; ++i) {
                    if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
                }
                if (toRemove.length) this.remove(toRemove, options);
            }
            if (toAdd.length) {
                if (sortable) sort = true;
                this.length += toAdd.length;
                if (at != null) {
                    splice.apply(this.models, [ at, 0 ].concat(toAdd));
                } else {
                    push.apply(this.models, toAdd);
                }
            }
            if (sort) this.sort({
                silent: true
            });
            if (options.silent) return this;
            for (i = 0, l = toAdd.length; i < l; i++) {
                (model = toAdd[i]).trigger("add", model, this, options);
            }
            if (sort) this.trigger("sort", this, options);
            return this;
        },
        reset: function(models, options) {
            options || (options = {});
            for (var i = 0, l = this.models.length; i < l; i++) {
                this._removeReference(this.models[i]);
            }
            options.previousModels = this.models;
            this._reset();
            this.add(models, _.extend({
                silent: true
            }, options));
            if (!options.silent) this.trigger("reset", this, options);
            return this;
        },
        push: function(model, options) {
            model = this._prepareModel(model, options);
            this.add(model, _.extend({
                at: this.length
            }, options));
            return model;
        },
        pop: function(options) {
            var model = this.at(this.length - 1);
            this.remove(model, options);
            return model;
        },
        unshift: function(model, options) {
            model = this._prepareModel(model, options);
            this.add(model, _.extend({
                at: 0
            }, options));
            return model;
        },
        shift: function(options) {
            var model = this.at(0);
            this.remove(model, options);
            return model;
        },
        slice: function(begin, end) {
            return this.models.slice(begin, end);
        },
        get: function(obj) {
            if (obj == null) return void 0;
            return this._byId[obj.id != null ? obj.id : obj.cid || obj];
        },
        at: function(index) {
            return this.models[index];
        },
        where: function(attrs, first) {
            if (_.isEmpty(attrs)) return first ? void 0 : [];
            return this[first ? "find" : "filter"](function(model) {
                for (var key in attrs) {
                    if (attrs[key] !== model.get(key)) return false;
                }
                return true;
            });
        },
        findWhere: function(attrs) {
            return this.where(attrs, true);
        },
        sort: function(options) {
            if (!this.comparator) throw new Error("Cannot sort a set without a comparator");
            options || (options = {});
            if (_.isString(this.comparator) || this.comparator.length === 1) {
                this.models = this.sortBy(this.comparator, this);
            } else {
                this.models.sort(_.bind(this.comparator, this));
            }
            if (!options.silent) this.trigger("sort", this, options);
            return this;
        },
        sortedIndex: function(model, value, context) {
            value || (value = this.comparator);
            var iterator = _.isFunction(value) ? value : function(model) {
                return model.get(value);
            };
            return _.sortedIndex(this.models, model, iterator, context);
        },
        pluck: function(attr) {
            return _.invoke(this.models, "get", attr);
        },
        fetch: function(options) {
            options = options ? _.clone(options) : {};
            if (options.parse === void 0) options.parse = true;
            var success = options.success;
            var collection = this;
            options.success = function(resp) {
                var method = options.reset ? "reset" : "set";
                collection[method](resp, options);
                if (success) success(collection, resp, options);
                collection.trigger("sync", collection, resp, options);
            };
            wrapError(this, options);
            return this.sync("read", this, options);
        },
        create: function(model, options) {
            options = options ? _.clone(options) : {};
            if (!(model = this._prepareModel(model, options))) return false;
            if (!options.wait) this.add(model, options);
            var collection = this;
            var success = options.success;
            options.success = function(resp) {
                if (options.wait) collection.add(model, options);
                if (success) success(model, resp, options);
            };
            model.save(null, options);
            return model;
        },
        parse: function(resp, options) {
            return resp;
        },
        clone: function() {
            return new this.constructor(this.models);
        },
        _reset: function() {
            this.length = 0;
            this.models = [];
            this._byId = {};
        },
        _prepareModel: function(attrs, options) {
            if (attrs instanceof Model) {
                if (!attrs.collection) attrs.collection = this;
                return attrs;
            }
            options || (options = {});
            options.collection = this;
            var model = new this.model(attrs, options);
            if (!model._validate(attrs, options)) {
                this.trigger("invalid", this, attrs, options);
                return false;
            }
            return model;
        },
        _removeReference: function(model) {
            if (this === model.collection) delete model.collection;
            model.off("all", this._onModelEvent, this);
        },
        _onModelEvent: function(event, model, collection, options) {
            if ((event === "add" || event === "remove") && collection !== this) return;
            if (event === "destroy") this.remove(model, options);
            if (model && event === "change:" + model.idAttribute) {
                delete this._byId[model.previous(model.idAttribute)];
                if (model.id != null) this._byId[model.id] = model;
            }
            this.trigger.apply(this, arguments);
        }
    });
    var methods = [ "forEach", "each", "map", "collect", "reduce", "foldl", "inject", "reduceRight", "foldr", "find", "detect", "filter", "select", "reject", "every", "all", "some", "any", "include", "contains", "invoke", "max", "min", "toArray", "size", "first", "head", "take", "initial", "rest", "tail", "drop", "last", "without", "indexOf", "shuffle", "lastIndexOf", "isEmpty", "chain" ];
    _.each(methods, function(method) {
        Collection.prototype[method] = function() {
            var args = slice.call(arguments);
            args.unshift(this.models);
            return _[method].apply(_, args);
        };
    });
    var attributeMethods = [ "groupBy", "countBy", "sortBy" ];
    _.each(attributeMethods, function(method) {
        Collection.prototype[method] = function(value, context) {
            var iterator = _.isFunction(value) ? value : function(model) {
                return model.get(value);
            };
            return _[method](this.models, iterator, context);
        };
    });
    var View = Backbone.View = function(options) {
        this.cid = _.uniqueId("view");
        this._configure(options || {});
        this._ensureElement();
        this.initialize.apply(this, arguments);
        this.delegateEvents();
    };
    var delegateEventSplitter = /^(\S+)\s*(.*)$/;
    var viewOptions = [ "model", "collection", "el", "id", "attributes", "className", "tagName", "events" ];
    _.extend(View.prototype, Events, {
        tagName: "div",
        $: function(selector) {
            return this.$el.find(selector);
        },
        initialize: function() {},
        render: function() {
            return this;
        },
        remove: function() {
            this.$el.remove();
            this.stopListening();
            return this;
        },
        setElement: function(element, delegate) {
            if (this.$el) this.undelegateEvents();
            this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
            this.el = this.$el[0];
            if (delegate !== false) this.delegateEvents();
            return this;
        },
        delegateEvents: function(events) {
            if (!(events || (events = _.result(this, "events")))) return this;
            this.undelegateEvents();
            for (var key in events) {
                var method = events[key];
                if (!_.isFunction(method)) method = this[events[key]];
                if (!method) continue;
                var match = key.match(delegateEventSplitter);
                var eventName = match[1], selector = match[2];
                method = _.bind(method, this);
                eventName += ".delegateEvents" + this.cid;
                if (selector === "") {
                    this.$el.on(eventName, method);
                } else {
                    this.$el.on(eventName, selector, method);
                }
            }
            return this;
        },
        undelegateEvents: function() {
            this.$el.off(".delegateEvents" + this.cid);
            return this;
        },
        _configure: function(options) {
            if (this.options) options = _.extend({}, _.result(this, "options"), options);
            _.extend(this, _.pick(options, viewOptions));
            this.options = options;
        },
        _ensureElement: function() {
            if (!this.el) {
                var attrs = _.extend({}, _.result(this, "attributes"));
                if (this.id) attrs.id = _.result(this, "id");
                if (this.className) attrs["class"] = _.result(this, "className");
                var $el = Backbone.$("<" + _.result(this, "tagName") + ">").attr(attrs);
                this.setElement($el, false);
            } else {
                this.setElement(_.result(this, "el"), false);
            }
        }
    });
    Backbone.sync = function(method, model, options) {
        var type = methodMap[method];
        _.defaults(options || (options = {}), {
            emulateHTTP: Backbone.emulateHTTP,
            emulateJSON: Backbone.emulateJSON
        });
        var params = {
            type: type,
            dataType: "json"
        };
        if (!options.url) {
            params.url = _.result(model, "url") || urlError();
        }
        if (options.data == null && model && (method === "create" || method === "update" || method === "patch")) {
            params.contentType = "application/json";
            params.data = JSON.stringify(options.attrs || model.toJSON(options));
        }
        if (options.emulateJSON) {
            params.contentType = "application/x-www-form-urlencoded";
            params.data = params.data ? {
                model: params.data
            } : {};
        }
        if (options.emulateHTTP && (type === "PUT" || type === "DELETE" || type === "PATCH")) {
            params.type = "POST";
            if (options.emulateJSON) params.data._method = type;
            var beforeSend = options.beforeSend;
            options.beforeSend = function(xhr) {
                xhr.setRequestHeader("X-HTTP-Method-Override", type);
                if (beforeSend) return beforeSend.apply(this, arguments);
            };
        }
        if (params.type !== "GET" && !options.emulateJSON) {
            params.processData = false;
        }
        if (params.type === "PATCH" && window.ActiveXObject && !(window.external && window.external.msActiveXFilteringEnabled)) {
            params.xhr = function() {
                return new ActiveXObject("Microsoft.XMLHTTP");
            };
        }
        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
        model.trigger("request", model, xhr, options);
        return xhr;
    };
    var methodMap = {
        create: "POST",
        update: "PUT",
        patch: "PATCH",
        "delete": "DELETE",
        read: "GET"
    };
    Backbone.ajax = function() {
        return Backbone.$.ajax.apply(Backbone.$, arguments);
    };
    var Router = Backbone.Router = function(options) {
        options || (options = {});
        if (options.routes) this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
    };
    var optionalParam = /\((.*?)\)/g;
    var namedParam = /(\(\?)?:\w+/g;
    var splatParam = /\*\w+/g;
    var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
    _.extend(Router.prototype, Events, {
        initialize: function() {},
        route: function(route, name, callback) {
            if (!_.isRegExp(route)) route = this._routeToRegExp(route);
            if (_.isFunction(name)) {
                callback = name;
                name = "";
            }
            if (!callback) callback = this[name];
            var router = this;
            Backbone.history.route(route, function(fragment) {
                var args = router._extractParameters(route, fragment);
                callback && callback.apply(router, args);
                router.trigger.apply(router, [ "route:" + name ].concat(args));
                router.trigger("route", name, args);
                Backbone.history.trigger("route", router, name, args);
            });
            return this;
        },
        navigate: function(fragment, options) {
            Backbone.history.navigate(fragment, options);
            return this;
        },
        _bindRoutes: function() {
            if (!this.routes) return;
            this.routes = _.result(this, "routes");
            var route, routes = _.keys(this.routes);
            while ((route = routes.pop()) != null) {
                this.route(route, this.routes[route]);
            }
        },
        _routeToRegExp: function(route) {
            route = route.replace(escapeRegExp, "\\$&").replace(optionalParam, "(?:$1)?").replace(namedParam, function(match, optional) {
                return optional ? match : "([^/]+)";
            }).replace(splatParam, "(.*?)");
            return new RegExp("^" + route + "$");
        },
        _extractParameters: function(route, fragment) {
            var params = route.exec(fragment).slice(1);
            return _.map(params, function(param) {
                return param ? decodeURIComponent(param) : null;
            });
        }
    });
    var History = Backbone.History = function() {
        this.handlers = [];
        _.bindAll(this, "checkUrl");
        if (typeof window !== "undefined") {
            this.location = window.location;
            this.history = window.history;
        }
    };
    var routeStripper = /^[#\/]|\s+$/g;
    var rootStripper = /^\/+|\/+$/g;
    var isExplorer = /msie [\w.]+/;
    var trailingSlash = /\/$/;
    History.started = false;
    _.extend(History.prototype, Events, {
        interval: 50,
        getHash: function(window) {
            var match = (window || this).location.href.match(/#(.*)$/);
            return match ? match[1] : "";
        },
        getFragment: function(fragment, forcePushState) {
            if (fragment == null) {
                if (this._hasPushState || !this._wantsHashChange || forcePushState) {
                    fragment = this.location.pathname;
                    var root = this.root.replace(trailingSlash, "");
                    if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);
                } else {
                    fragment = this.getHash();
                }
            }
            return fragment.replace(routeStripper, "");
        },
        start: function(options) {
            if (History.started) throw new Error("Backbone.history has already been started");
            History.started = true;
            this.options = _.extend({}, {
                root: "/"
            }, this.options, options);
            this.root = this.options.root;
            this._wantsHashChange = this.options.hashChange !== false;
            this._wantsPushState = !!this.options.pushState;
            this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);
            var fragment = this.getFragment();
            var docMode = document.documentMode;
            var oldIE = isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7);
            this.root = ("/" + this.root + "/").replace(rootStripper, "/");
            if (oldIE && this._wantsHashChange) {
                this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo("body")[0].contentWindow;
                this.navigate(fragment);
            }
            if (this._hasPushState) {
                Backbone.$(window).on("popstate", this.checkUrl);
            } else if (this._wantsHashChange && "onhashchange" in window && !oldIE) {
                Backbone.$(window).on("hashchange", this.checkUrl);
            } else if (this._wantsHashChange) {
                this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
            }
            this.fragment = fragment;
            var loc = this.location;
            var atRoot = loc.pathname.replace(/[^\/]$/, "$&/") === this.root;
            if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
                this.fragment = this.getFragment(null, true);
                this.location.replace(this.root + this.location.search + "#" + this.fragment);
                return true;
            } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
                this.fragment = this.getHash().replace(routeStripper, "");
                this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
            }
            if (!this.options.silent) return this.loadUrl();
        },
        stop: function() {
            Backbone.$(window).off("popstate", this.checkUrl).off("hashchange", this.checkUrl);
            clearInterval(this._checkUrlInterval);
            History.started = false;
        },
        route: function(route, callback) {
            this.handlers.unshift({
                route: route,
                callback: callback
            });
        },
        checkUrl: function(e) {
            var current = this.getFragment();
            if (current === this.fragment && this.iframe) {
                current = this.getFragment(this.getHash(this.iframe));
            }
            if (current === this.fragment) return false;
            if (this.iframe) this.navigate(current);
            this.loadUrl() || this.loadUrl(this.getHash());
        },
        loadUrl: function(fragmentOverride) {
            var fragment = this.fragment = this.getFragment(fragmentOverride);
            var matched = _.any(this.handlers, function(handler) {
                if (handler.route.test(fragment)) {
                    handler.callback(fragment);
                    return true;
                }
            });
            return matched;
        },
        navigate: function(fragment, options) {
            if (!History.started) return false;
            if (!options || options === true) options = {
                trigger: options
            };
            fragment = this.getFragment(fragment || "");
            if (this.fragment === fragment) return;
            this.fragment = fragment;
            var url = this.root + fragment;
            if (this._hasPushState) {
                this.history[options.replace ? "replaceState" : "pushState"]({}, document.title, url);
            } else if (this._wantsHashChange) {
                this._updateHash(this.location, fragment, options.replace);
                if (this.iframe && fragment !== this.getFragment(this.getHash(this.iframe))) {
                    if (!options.replace) this.iframe.document.open().close();
                    this._updateHash(this.iframe.location, fragment, options.replace);
                }
            } else {
                return this.location.assign(url);
            }
            if (options.trigger) this.loadUrl(fragment);
        },
        _updateHash: function(location, fragment, replace) {
            if (replace) {
                var href = location.href.replace(/(javascript:|#).*$/, "");
                location.replace(href + "#" + fragment);
            } else {
                location.hash = "#" + fragment;
            }
        }
    });
    Backbone.history = new History();
    var extend = function(protoProps, staticProps) {
        var parent = this;
        var child;
        if (protoProps && _.has(protoProps, "constructor")) {
            child = protoProps.constructor;
        } else {
            child = function() {
                return parent.apply(this, arguments);
            };
        }
        _.extend(child, parent, staticProps);
        var Surrogate = function() {
            this.constructor = child;
        };
        Surrogate.prototype = parent.prototype;
        child.prototype = new Surrogate();
        if (protoProps) _.extend(child.prototype, protoProps);
        child.__super__ = parent.prototype;
        return child;
    };
    Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
    var urlError = function() {
        throw new Error('A "url" property or function must be specified');
    };
    var wrapError = function(model, options) {
        var error = options.error;
        options.error = function(resp) {
            if (error) error(model, resp, options);
            model.trigger("error", model, resp, options);
        };
    };
}).call(this);

!function(root, String) {
    "use strict";
    var nativeTrim = String.prototype.trim;
    var nativeTrimRight = String.prototype.trimRight;
    var nativeTrimLeft = String.prototype.trimLeft;
    var parseNumber = function(source) {
        return source * 1 || 0;
    };
    var strRepeat = function(str, qty) {
        if (qty < 1) return "";
        var result = "";
        while (qty > 0) {
            if (qty & 1) result += str;
            qty >>= 1, str += str;
        }
        return result;
    };
    var slice = [].slice;
    var defaultToWhiteSpace = function(characters) {
        if (characters == null) return "\\s"; else if (characters.source) return characters.source; else return "[" + _s.escapeRegExp(characters) + "]";
    };
    var escapeChars = {
        lt: "<",
        gt: ">",
        quot: '"',
        apos: "'",
        amp: "&"
    };
    var reversedEscapeChars = {};
    for (var key in escapeChars) {
        reversedEscapeChars[escapeChars[key]] = key;
    }
    var sprintf = function() {
        function get_type(variable) {
            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
        }
        var str_repeat = strRepeat;
        var str_format = function() {
            if (!str_format.cache.hasOwnProperty(arguments[0])) {
                str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
            }
            return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
        };
        str_format.format = function(parse_tree, argv) {
            var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length;
            for (i = 0; i < tree_length; i++) {
                node_type = get_type(parse_tree[i]);
                if (node_type === "string") {
                    output.push(parse_tree[i]);
                } else if (node_type === "array") {
                    match = parse_tree[i];
                    if (match[2]) {
                        arg = argv[cursor];
                        for (k = 0; k < match[2].length; k++) {
                            if (!arg.hasOwnProperty(match[2][k])) {
                                throw new Error(sprintf('[_.sprintf] property "%s" does not exist', match[2][k]));
                            }
                            arg = arg[match[2][k]];
                        }
                    } else if (match[1]) {
                        arg = argv[match[1]];
                    } else {
                        arg = argv[cursor++];
                    }
                    if (/[^s]/.test(match[8]) && get_type(arg) != "number") {
                        throw new Error(sprintf("[_.sprintf] expecting number but found %s", get_type(arg)));
                    }
                    switch (match[8]) {
                      case "b":
                        arg = arg.toString(2);
                        break;

                      case "c":
                        arg = String.fromCharCode(arg);
                        break;

                      case "d":
                        arg = parseInt(arg, 10);
                        break;

                      case "e":
                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
                        break;

                      case "f":
                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
                        break;

                      case "o":
                        arg = arg.toString(8);
                        break;

                      case "s":
                        arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;
                        break;

                      case "u":
                        arg = Math.abs(arg);
                        break;

                      case "x":
                        arg = arg.toString(16);
                        break;

                      case "X":
                        arg = arg.toString(16).toUpperCase();
                        break;
                    }
                    arg = /[def]/.test(match[8]) && match[3] && arg >= 0 ? "+" + arg : arg;
                    pad_character = match[4] ? match[4] == "0" ? "0" : match[4].charAt(1) : " ";
                    pad_length = match[6] - String(arg).length;
                    pad = match[6] ? str_repeat(pad_character, pad_length) : "";
                    output.push(match[5] ? arg + pad : pad + arg);
                }
            }
            return output.join("");
        };
        str_format.cache = {};
        str_format.parse = function(fmt) {
            var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
            while (_fmt) {
                if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                    parse_tree.push(match[0]);
                } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                    parse_tree.push("%");
                } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                    if (match[2]) {
                        arg_names |= 1;
                        var field_list = [], replacement_field = match[2], field_match = [];
                        if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                            field_list.push(field_match[1]);
                            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                } else {
                                    throw new Error("[_.sprintf] huh?");
                                }
                            }
                        } else {
                            throw new Error("[_.sprintf] huh?");
                        }
                        match[2] = field_list;
                    } else {
                        arg_names |= 2;
                    }
                    if (arg_names === 3) {
                        throw new Error("[_.sprintf] mixing positional and named placeholders is not (yet) supported");
                    }
                    parse_tree.push(match);
                } else {
                    throw new Error("[_.sprintf] huh?");
                }
                _fmt = _fmt.substring(match[0].length);
            }
            return parse_tree;
        };
        return str_format;
    }();
    var _s = {
        VERSION: "2.3.0",
        isBlank: function(str) {
            if (str == null) str = "";
            return /^\s*$/.test(str);
        },
        stripTags: function(str) {
            if (str == null) return "";
            return String(str).replace(/<\/?[^>]+>/g, "");
        },
        capitalize: function(str) {
            str = str == null ? "" : String(str);
            return str.charAt(0).toUpperCase() + str.slice(1);
        },
        chop: function(str, step) {
            if (str == null) return [];
            str = String(str);
            step = ~~step;
            return step > 0 ? str.match(new RegExp(".{1," + step + "}", "g")) : [ str ];
        },
        clean: function(str) {
            return _s.strip(str).replace(/\s+/g, " ");
        },
        count: function(str, substr) {
            if (str == null || substr == null) return 0;
            return String(str).split(substr).length - 1;
        },
        chars: function(str) {
            if (str == null) return [];
            return String(str).split("");
        },
        swapCase: function(str) {
            if (str == null) return "";
            return String(str).replace(/\S/g, function(c) {
                return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();
            });
        },
        escapeHTML: function(str) {
            if (str == null) return "";
            return String(str).replace(/[&<>"']/g, function(m) {
                return "&" + reversedEscapeChars[m] + ";";
            });
        },
        unescapeHTML: function(str) {
            if (str == null) return "";
            return String(str).replace(/\&([^;]+);/g, function(entity, entityCode) {
                var match;
                if (entityCode in escapeChars) {
                    return escapeChars[entityCode];
                } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) {
                    return String.fromCharCode(parseInt(match[1], 16));
                } else if (match = entityCode.match(/^#(\d+)$/)) {
                    return String.fromCharCode(~~match[1]);
                } else {
                    return entity;
                }
            });
        },
        escapeRegExp: function(str) {
            if (str == null) return "";
            return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
        },
        splice: function(str, i, howmany, substr) {
            var arr = _s.chars(str);
            arr.splice(~~i, ~~howmany, substr);
            return arr.join("");
        },
        insert: function(str, i, substr) {
            return _s.splice(str, i, 0, substr);
        },
        include: function(str, needle) {
            if (needle === "") return true;
            if (str == null) return false;
            return String(str).indexOf(needle) !== -1;
        },
        join: function() {
            var args = slice.call(arguments), separator = args.shift();
            if (separator == null) separator = "";
            return args.join(separator);
        },
        lines: function(str) {
            if (str == null) return [];
            return String(str).split("\n");
        },
        reverse: function(str) {
            return _s.chars(str).reverse().join("");
        },
        startsWith: function(str, starts) {
            if (starts === "") return true;
            if (str == null || starts == null) return false;
            str = String(str);
            starts = String(starts);
            return str.length >= starts.length && str.slice(0, starts.length) === starts;
        },
        endsWith: function(str, ends) {
            if (ends === "") return true;
            if (str == null || ends == null) return false;
            str = String(str);
            ends = String(ends);
            return str.length >= ends.length && str.slice(str.length - ends.length) === ends;
        },
        succ: function(str) {
            if (str == null) return "";
            str = String(str);
            return str.slice(0, -1) + String.fromCharCode(str.charCodeAt(str.length - 1) + 1);
        },
        titleize: function(str) {
            if (str == null) return "";
            return String(str).replace(/(?:^|\s)\S/g, function(c) {
                return c.toUpperCase();
            });
        },
        camelize: function(str) {
            return _s.trim(str).replace(/[-_\s]+(.)?/g, function(match, c) {
                return c.toUpperCase();
            });
        },
        underscored: function(str) {
            return _s.trim(str).replace(/([a-z\d])([A-Z]+)/g, "$1_$2").replace(/[-\s]+/g, "_").toLowerCase();
        },
        dasherize: function(str) {
            return _s.trim(str).replace(/([A-Z])/g, "-$1").replace(/[-_\s]+/g, "-").toLowerCase();
        },
        classify: function(str) {
            return _s.titleize(String(str).replace(/_/g, " ")).replace(/\s/g, "");
        },
        humanize: function(str) {
            return _s.capitalize(_s.underscored(str).replace(/_id$/, "").replace(/_/g, " "));
        },
        trim: function(str, characters) {
            if (str == null) return "";
            if (!characters && nativeTrim) return nativeTrim.call(str);
            characters = defaultToWhiteSpace(characters);
            return String(str).replace(new RegExp("^" + characters + "+|" + characters + "+$", "g"), "");
        },
        ltrim: function(str, characters) {
            if (str == null) return "";
            if (!characters && nativeTrimLeft) return nativeTrimLeft.call(str);
            characters = defaultToWhiteSpace(characters);
            return String(str).replace(new RegExp("^" + characters + "+"), "");
        },
        rtrim: function(str, characters) {
            if (str == null) return "";
            if (!characters && nativeTrimRight) return nativeTrimRight.call(str);
            characters = defaultToWhiteSpace(characters);
            return String(str).replace(new RegExp(characters + "+$"), "");
        },
        truncate: function(str, length, truncateStr) {
            if (str == null) return "";
            str = String(str);
            truncateStr = truncateStr || "...";
            length = ~~length;
            return str.length > length ? str.slice(0, length) + truncateStr : str;
        },
        prune: function(str, length, pruneStr) {
            if (str == null) return "";
            str = String(str);
            length = ~~length;
            pruneStr = pruneStr != null ? String(pruneStr) : "...";
            if (str.length <= length) return str;
            var tmpl = function(c) {
                return c.toUpperCase() !== c.toLowerCase() ? "A" : " ";
            }, template = str.slice(0, length + 1).replace(/.(?=\W*\w*$)/g, tmpl);
            if (template.slice(template.length - 2).match(/\w\w/)) template = template.replace(/\s*\S+$/, ""); else template = _s.rtrim(template.slice(0, template.length - 1));
            return (template + pruneStr).length > str.length ? str : str.slice(0, template.length) + pruneStr;
        },
        words: function(str, delimiter) {
            if (_s.isBlank(str)) return [];
            return _s.trim(str, delimiter).split(delimiter || /\s+/);
        },
        pad: function(str, length, padStr, type) {
            str = str == null ? "" : String(str);
            length = ~~length;
            var padlen = 0;
            if (!padStr) padStr = " "; else if (padStr.length > 1) padStr = padStr.charAt(0);
            switch (type) {
              case "right":
                padlen = length - str.length;
                return str + strRepeat(padStr, padlen);

              case "both":
                padlen = length - str.length;
                return strRepeat(padStr, Math.ceil(padlen / 2)) + str + strRepeat(padStr, Math.floor(padlen / 2));

              default:
                padlen = length - str.length;
                return strRepeat(padStr, padlen) + str;
            }
        },
        lpad: function(str, length, padStr) {
            return _s.pad(str, length, padStr);
        },
        rpad: function(str, length, padStr) {
            return _s.pad(str, length, padStr, "right");
        },
        lrpad: function(str, length, padStr) {
            return _s.pad(str, length, padStr, "both");
        },
        sprintf: sprintf,
        vsprintf: function(fmt, argv) {
            argv.unshift(fmt);
            return sprintf.apply(null, argv);
        },
        toNumber: function(str, decimals) {
            if (str == null || str == "") return 0;
            str = String(str);
            var num = parseNumber(parseNumber(str).toFixed(~~decimals));
            return num === 0 && !str.match(/^0+$/) ? Number.NaN : num;
        },
        numberFormat: function(number, dec, dsep, tsep) {
            if (isNaN(number) || number == null) return "";
            number = number.toFixed(~~dec);
            tsep = tsep || ",";
            var parts = number.split("."), fnums = parts[0], decimals = parts[1] ? (dsep || ".") + parts[1] : "";
            return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, "$1" + tsep) + decimals;
        },
        strRight: function(str, sep) {
            if (str == null) return "";
            str = String(str);
            sep = sep != null ? String(sep) : sep;
            var pos = !sep ? -1 : str.indexOf(sep);
            return ~pos ? str.slice(pos + sep.length, str.length) : str;
        },
        strRightBack: function(str, sep) {
            if (str == null) return "";
            str = String(str);
            sep = sep != null ? String(sep) : sep;
            var pos = !sep ? -1 : str.lastIndexOf(sep);
            return ~pos ? str.slice(pos + sep.length, str.length) : str;
        },
        strLeft: function(str, sep) {
            if (str == null) return "";
            str = String(str);
            sep = sep != null ? String(sep) : sep;
            var pos = !sep ? -1 : str.indexOf(sep);
            return ~pos ? str.slice(0, pos) : str;
        },
        strLeftBack: function(str, sep) {
            if (str == null) return "";
            str += "";
            sep = sep != null ? "" + sep : sep;
            var pos = str.lastIndexOf(sep);
            return ~pos ? str.slice(0, pos) : str;
        },
        toSentence: function(array, separator, lastSeparator, serial) {
            separator = separator || ", ";
            lastSeparator = lastSeparator || " and ";
            var a = array.slice(), lastMember = a.pop();
            if (array.length > 2 && serial) lastSeparator = _s.rtrim(separator) + lastSeparator;
            return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember;
        },
        toSentenceSerial: function() {
            var args = slice.call(arguments);
            args[3] = true;
            return _s.toSentence.apply(_s, args);
        },
        slugify: function(str) {
            if (str == null) return "";
            var from = "ąàáäâãåæćęèéëêìíïîłńòóöôõøùúüûñçżź", to = "aaaaaaaaceeeeeiiiilnoooooouuuunczz", regex = new RegExp(defaultToWhiteSpace(from), "g");
            str = String(str).toLowerCase().replace(regex, function(c) {
                var index = from.indexOf(c);
                return to.charAt(index) || "-";
            });
            return _s.dasherize(str.replace(/[^\w\s-]/g, ""));
        },
        surround: function(str, wrapper) {
            return [ wrapper, str, wrapper ].join("");
        },
        quote: function(str) {
            return _s.surround(str, '"');
        },
        exports: function() {
            var result = {};
            for (var prop in this) {
                if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse)$/)) continue;
                result[prop] = this[prop];
            }
            return result;
        },
        repeat: function(str, qty, separator) {
            if (str == null) return "";
            qty = ~~qty;
            if (separator == null) return strRepeat(String(str), qty);
            for (var repeat = []; qty > 0; repeat[--qty] = str) {}
            return repeat.join(separator);
        },
        levenshtein: function(str1, str2) {
            if (str1 == null && str2 == null) return 0;
            if (str1 == null) return String(str2).length;
            if (str2 == null) return String(str1).length;
            str1 = String(str1);
            str2 = String(str2);
            var current = [], prev, value;
            for (var i = 0; i <= str2.length; i++) for (var j = 0; j <= str1.length; j++) {
                if (i && j) if (str1.charAt(j - 1) === str2.charAt(i - 1)) value = prev; else value = Math.min(current[j], current[j - 1], prev) + 1; else value = i + j;
                prev = current[j];
                current[j] = value;
            }
            return current.pop();
        }
    };
    _s.strip = _s.trim;
    _s.lstrip = _s.ltrim;
    _s.rstrip = _s.rtrim;
    _s.center = _s.lrpad;
    _s.rjust = _s.lpad;
    _s.ljust = _s.rpad;
    _s.contains = _s.include;
    _s.q = _s.quote;
    if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
            module.exports = _s;
        }
        exports._s = _s;
    } else if (typeof define === "function" && define.amd) {
        define("underscore.string", [], function() {
            return _s;
        });
    } else {
        root._ = root._ || {};
        root._.string = root._.str = _s;
    }
}(this, String);

!function($) {
    $(function() {
        "use strict";
        $.support.transition = function() {
            var thisBody = document.body || document.documentElement, thisStyle = thisBody.style, support = thisStyle.transition !== undefined || thisStyle.WebkitTransition !== undefined || thisStyle.MozTransition !== undefined || thisStyle.MsTransition !== undefined || thisStyle.OTransition !== undefined;
            return support && {
                end: function() {
                    var transitionEnd = "TransitionEnd";
                    if ($.browser.webkit) {
                        transitionEnd = "webkitTransitionEnd";
                    } else if ($.browser.mozilla) {
                        transitionEnd = "transitionend";
                    } else if ($.browser.opera) {
                        transitionEnd = "oTransitionEnd";
                    }
                    return transitionEnd;
                }()
            };
        }();
    });
}(window.jQuery);

!function($) {
    "use strict";
    var dismiss = '[data-dismiss="alert"]', Alert = function(el) {
        $(el).on("click", dismiss, this.close);
    };
    Alert.prototype = {
        constructor: Alert,
        close: function(e) {
            var $this = $(this), selector = $this.attr("data-target"), $parent;
            if (!selector) {
                selector = $this.attr("href");
                selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
            }
            $parent = $(selector);
            $parent.trigger("close");
            e && e.preventDefault();
            $parent.length || ($parent = $this.hasClass("alert") ? $this : $this.parent());
            $parent.trigger("close").removeClass("in");
            function removeElement() {
                $parent.trigger("closed").remove();
            }
            $.support.transition && $parent.hasClass("fade") ? $parent.on($.support.transition.end, removeElement) : removeElement();
        }
    };
    $.fn.alert = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("alert");
            if (!data) $this.data("alert", data = new Alert(this));
            if (typeof option == "string") data[option].call($this);
        });
    };
    $.fn.alert.Constructor = Alert;
    $(function() {
        $("body").on("click.alert.data-api", dismiss, Alert.prototype.close);
    });
}(window.jQuery);

!function($) {
    "use strict";
    var Button = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, $.fn.button.defaults, options);
    };
    Button.prototype = {
        constructor: Button,
        setState: function(state) {
            var d = "disabled", $el = this.$element, data = $el.data(), val = $el.is("input") ? "val" : "html";
            state = state + "Text";
            data.resetText || $el.data("resetText", $el[val]());
            $el[val](data[state] || this.options[state]);
            setTimeout(function() {
                state == "loadingText" ? $el.addClass(d).attr(d, d) : $el.removeClass(d).removeAttr(d);
            }, 0);
        },
        toggle: function() {
            var $parent = this.$element.parent('[data-toggle="buttons-radio"]');
            $parent && $parent.find(".active").removeClass("active");
            this.$element.toggleClass("active");
        }
    };
    $.fn.button = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("button"), options = typeof option == "object" && option;
            if (!data) $this.data("button", data = new Button(this, options));
            if (option == "toggle") data.toggle(); else if (option) data.setState(option);
        });
    };
    $.fn.button.defaults = {
        loadingText: "loading..."
    };
    $.fn.button.Constructor = Button;
    $(function() {
        $("body").on("click.button.data-api", "[data-toggle^=button]", function(e) {
            var $btn = $(e.target);
            if (!$btn.hasClass("btn")) $btn = $btn.closest(".btn");
            $btn.button("toggle");
        });
    });
}(window.jQuery);

!function($) {
    "use strict";
    var Carousel = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, $.fn.carousel.defaults, options);
        this.options.slide && this.slide(this.options.slide);
        this.options.pause == "hover" && this.$element.on("mouseenter", $.proxy(this.pause, this)).on("mouseleave", $.proxy(this.cycle, this));
    };
    Carousel.prototype = {
        cycle: function() {
            this.interval = setInterval($.proxy(this.next, this), this.options.interval);
            return this;
        },
        to: function(pos) {
            var $active = this.$element.find(".active"), children = $active.parent().children(), activePos = children.index($active), that = this;
            if (pos > children.length - 1 || pos < 0) return;
            if (this.sliding) {
                return this.$element.one("slid", function() {
                    that.to(pos);
                });
            }
            if (activePos == pos) {
                return this.pause().cycle();
            }
            return this.slide(pos > activePos ? "next" : "prev", $(children[pos]));
        },
        pause: function() {
            clearInterval(this.interval);
            this.interval = null;
            return this;
        },
        next: function() {
            if (this.sliding) return;
            return this.slide("next");
        },
        prev: function() {
            if (this.sliding) return;
            return this.slide("prev");
        },
        slide: function(type, next) {
            var $active = this.$element.find(".active"), $next = next || $active[type](), isCycling = this.interval, direction = type == "next" ? "left" : "right", fallback = type == "next" ? "first" : "last", that = this;
            this.sliding = true;
            isCycling && this.pause();
            $next = $next.length ? $next : this.$element.find(".item")[fallback]();
            if ($next.hasClass("active")) return;
            if (!$.support.transition && this.$element.hasClass("slide")) {
                this.$element.trigger("slide");
                $active.removeClass("active");
                $next.addClass("active");
                this.sliding = false;
                this.$element.trigger("slid");
            } else {
                $next.addClass(type);
                $next[0].offsetWidth;
                $active.addClass(direction);
                $next.addClass(direction);
                this.$element.trigger("slide");
                this.$element.one($.support.transition.end, function() {
                    $next.removeClass([ type, direction ].join(" ")).addClass("active");
                    $active.removeClass([ "active", direction ].join(" "));
                    that.sliding = false;
                    setTimeout(function() {
                        that.$element.trigger("slid");
                    }, 0);
                });
            }
            isCycling && this.cycle();
            return this;
        }
    };
    $.fn.carousel = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("carousel"), options = typeof option == "object" && option;
            if (!data) $this.data("carousel", data = new Carousel(this, options));
            if (typeof option == "number") data.to(option); else if (typeof option == "string" || (option = options.slide)) data[option](); else data.cycle();
        });
    };
    $.fn.carousel.defaults = {
        interval: 5e3,
        pause: "hover"
    };
    $.fn.carousel.Constructor = Carousel;
    $(function() {
        $("body").on("click.carousel.data-api", "[data-slide]", function(e) {
            var $this = $(this), href, $target = $($this.attr("data-target") || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "")), options = !$target.data("modal") && $.extend({}, $target.data(), $this.data());
            $target.carousel(options);
            e.preventDefault();
        });
    });
}(window.jQuery);

!function($) {
    "use strict";
    var Collapse = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, $.fn.collapse.defaults, options);
        if (this.options["parent"]) {
            this.$parent = $(this.options["parent"]);
        }
        this.options.toggle && this.toggle();
    };
    Collapse.prototype = {
        constructor: Collapse,
        dimension: function() {
            var hasWidth = this.$element.hasClass("width");
            return hasWidth ? "width" : "height";
        },
        show: function() {
            var dimension = this.dimension(), scroll = $.camelCase([ "scroll", dimension ].join("-")), actives = this.$parent && this.$parent.find(".in"), hasData;
            if (actives && actives.length) {
                hasData = actives.data("collapse");
                actives.collapse("hide");
                hasData || actives.data("collapse", null);
            }
            this.$element[dimension](0);
            this.transition("addClass", "show", "shown");
            this.$element[dimension](this.$element[0][scroll]);
        },
        hide: function() {
            var dimension = this.dimension();
            this.reset(this.$element[dimension]());
            this.transition("removeClass", "hide", "hidden");
            this.$element[dimension](0);
        },
        reset: function(size) {
            var dimension = this.dimension();
            this.$element.removeClass("collapse")[dimension](size || "auto")[0].offsetWidth;
            this.$element[size ? "addClass" : "removeClass"]("collapse");
            return this;
        },
        transition: function(method, startEvent, completeEvent) {
            var that = this, complete = function() {
                if (startEvent == "show") that.reset();
                that.$element.trigger(completeEvent);
            };
            this.$element.trigger(startEvent)[method]("in");
            $.support.transition && this.$element.hasClass("collapse") ? this.$element.one($.support.transition.end, complete) : complete();
        },
        toggle: function() {
            this[this.$element.hasClass("in") ? "hide" : "show"]();
        }
    };
    $.fn.collapse = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("collapse"), options = typeof option == "object" && option;
            if (!data) $this.data("collapse", data = new Collapse(this, options));
            if (typeof option == "string") data[option]();
        });
    };
    $.fn.collapse.defaults = {
        toggle: true
    };
    $.fn.collapse.Constructor = Collapse;
    $(function() {
        $("body").on("click.collapse.data-api", "[data-toggle=collapse]", function(e) {
            var $this = $(this), href, target = $this.attr("data-target") || e.preventDefault() || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""), option = $(target).data("collapse") ? "toggle" : $this.data();
            $(target).collapse(option);
        });
    });
}(window.jQuery);

!function($) {
    "use strict";
    var toggle = '[data-toggle="dropdown"]', Dropdown = function(element) {
        var $el = $(element).on("click.dropdown.data-api", this.toggle);
        $("html").on("click.dropdown.data-api", function() {
            $el.parent().removeClass("open");
        });
    };
    Dropdown.prototype = {
        constructor: Dropdown,
        toggle: function(e) {
            var $this = $(this), selector = $this.attr("data-target"), $parent, isActive;
            if (!selector) {
                selector = $this.attr("href");
                selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
            }
            $parent = $(selector);
            $parent.length || ($parent = $this.parent());
            isActive = $parent.hasClass("open");
            clearMenus();
            !isActive && $parent.toggleClass("open");
            return false;
        }
    };
    function clearMenus() {
        $(toggle).parent().removeClass("open");
    }
    $.fn.dropdown = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("dropdown");
            if (!data) $this.data("dropdown", data = new Dropdown(this));
            if (typeof option == "string") data[option].call($this);
        });
    };
    $.fn.dropdown.Constructor = Dropdown;
    $(function() {
        $("html").on("click.dropdown.data-api", clearMenus);
        $("body").on("click.dropdown.data-api", toggle, Dropdown.prototype.toggle);
    });
}(window.jQuery);

!function($) {
    "use strict";
    var Modal = function(content, options) {
        this.options = options;
        this.$element = $(content).delegate('[data-dismiss="modal"]', "click.dismiss.modal", $.proxy(this.hide, this));
    };
    Modal.prototype = {
        constructor: Modal,
        toggle: function() {
            return this[!this.isShown ? "show" : "hide"]();
        },
        show: function() {
            var that = this;
            if (this.isShown) return;
            $("body").addClass("modal-open");
            this.isShown = true;
            this.$element.trigger("show");
            escape.call(this);
            backdrop.call(this, function() {
                var transition = $.support.transition && that.$element.hasClass("fade");
                !that.$element.parent().length && that.$element.appendTo(document.body);
                that.$element.show();
                if (transition) {
                    that.$element[0].offsetWidth;
                }
                that.$element.addClass("in");
                transition ? that.$element.one($.support.transition.end, function() {
                    that.$element.trigger("shown");
                }) : that.$element.trigger("shown");
            });
        },
        hide: function(e) {
            e && e.preventDefault();
            if (!this.isShown) return;
            var that = this;
            this.isShown = false;
            $("body").removeClass("modal-open");
            escape.call(this);
            this.$element.trigger("hide").removeClass("in");
            $.support.transition && this.$element.hasClass("fade") ? hideWithTransition.call(this) : hideModal.call(this);
        }
    };
    function hideWithTransition() {
        var that = this, timeout = setTimeout(function() {
            that.$element.off($.support.transition.end);
            hideModal.call(that);
        }, 500);
        this.$element.one($.support.transition.end, function() {
            clearTimeout(timeout);
            hideModal.call(that);
        });
    }
    function hideModal(that) {
        this.$element.hide().trigger("hidden");
        backdrop.call(this);
    }
    function backdrop(callback) {
        var that = this, animate = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate;
            this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />').appendTo(document.body);
            if (this.options.backdrop != "static") {
                this.$backdrop.click($.proxy(this.hide, this));
            }
            if (doAnimate) this.$backdrop[0].offsetWidth;
            this.$backdrop.addClass("in");
            doAnimate ? this.$backdrop.one($.support.transition.end, callback) : callback();
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one($.support.transition.end, $.proxy(removeBackdrop, this)) : removeBackdrop.call(this);
        } else if (callback) {
            callback();
        }
    }
    function removeBackdrop() {
        this.$backdrop.remove();
        this.$backdrop = null;
    }
    function escape() {
        var that = this;
        if (this.isShown && this.options.keyboard) {
            $(document).on("keyup.dismiss.modal", function(e) {
                e.which == 27 && that.hide();
            });
        } else if (!this.isShown) {
            $(document).off("keyup.dismiss.modal");
        }
    }
    $.fn.modal = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("modal"), options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == "object" && option);
            if (!data) $this.data("modal", data = new Modal(this, options));
            if (typeof option == "string") data[option](); else if (options.show) data.show();
        });
    };
    $.fn.modal.defaults = {
        backdrop: true,
        keyboard: true,
        show: true
    };
    $.fn.modal.Constructor = Modal;
    $(function() {
        $("body").on("click.modal.data-api", '[data-toggle="modal"]', function(e) {
            var $this = $(this), href, $target = $($this.attr("data-target") || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "")), option = $target.data("modal") ? "toggle" : $.extend({}, $target.data(), $this.data());
            e.preventDefault();
            $target.modal(option);
        });
    });
}(window.jQuery);

!function($) {
    "use strict";
    var Tooltip = function(element, options) {
        this.init("tooltip", element, options);
    };
    Tooltip.prototype = {
        constructor: Tooltip,
        init: function(type, element, options) {
            var eventIn, eventOut;
            this.type = type;
            this.$element = $(element);
            this.options = this.getOptions(options);
            this.enabled = true;
            if (this.options.trigger != "manual") {
                eventIn = this.options.trigger == "hover" ? "mouseenter" : "focus";
                eventOut = this.options.trigger == "hover" ? "mouseleave" : "blur";
                this.$element.on(eventIn, this.options.selector, $.proxy(this.enter, this));
                this.$element.on(eventOut, this.options.selector, $.proxy(this.leave, this));
            }
            this.options.selector ? this._options = $.extend({}, this.options, {
                trigger: "manual",
                selector: ""
            }) : this.fixTitle();
        },
        getOptions: function(options) {
            options = $.extend({}, $.fn[this.type].defaults, options, this.$element.data());
            if (options.delay && typeof options.delay == "number") {
                options.delay = {
                    show: options.delay,
                    hide: options.delay
                };
            }
            return options;
        },
        enter: function(e) {
            var self = $(e.currentTarget)[this.type](this._options).data(this.type);
            if (!self.options.delay || !self.options.delay.show) {
                self.show();
            } else {
                self.hoverState = "in";
                setTimeout(function() {
                    if (self.hoverState == "in") {
                        self.show();
                    }
                }, self.options.delay.show);
            }
        },
        leave: function(e) {
            var self = $(e.currentTarget)[this.type](this._options).data(this.type);
            if (!self.options.delay || !self.options.delay.hide) {
                self.hide();
            } else {
                self.hoverState = "out";
                setTimeout(function() {
                    if (self.hoverState == "out") {
                        self.hide();
                    }
                }, self.options.delay.hide);
            }
        },
        show: function() {
            var $tip, inside, pos, actualWidth, actualHeight, placement, tp;
            if (this.hasContent() && this.enabled) {
                $tip = this.tip();
                this.setContent();
                if (this.options.animation) {
                    $tip.addClass("fade");
                }
                placement = typeof this.options.placement == "function" ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
                inside = /in/.test(placement);
                $tip.remove().css({
                    top: 0,
                    left: 0,
                    display: "block"
                }).appendTo(inside ? this.$element : document.body);
                pos = this.getPosition(inside);
                actualWidth = $tip[0].offsetWidth;
                actualHeight = $tip[0].offsetHeight;
                switch (inside ? placement.split(" ")[1] : placement) {
                  case "bottom":
                    tp = {
                        top: pos.top + pos.height,
                        left: pos.left + pos.width / 2 - actualWidth / 2
                    };
                    break;

                  case "top":
                    tp = {
                        top: pos.top - actualHeight,
                        left: pos.left + pos.width / 2 - actualWidth / 2
                    };
                    break;

                  case "left":
                    tp = {
                        top: pos.top + pos.height / 2 - actualHeight / 2,
                        left: pos.left - actualWidth
                    };
                    break;

                  case "right":
                    tp = {
                        top: pos.top + pos.height / 2 - actualHeight / 2,
                        left: pos.left + pos.width
                    };
                    break;
                }
                $tip.css(tp).addClass(placement).addClass("in");
            }
        },
        setContent: function() {
            var $tip = this.tip();
            $tip.find(".tooltip-inner").html(this.getTitle());
            $tip.removeClass("fade in top bottom left right");
        },
        hide: function() {
            var that = this, $tip = this.tip();
            $tip.removeClass("in");
            function removeWithAnimation() {
                var timeout = setTimeout(function() {
                    $tip.off($.support.transition.end).remove();
                }, 500);
                $tip.one($.support.transition.end, function() {
                    clearTimeout(timeout);
                    $tip.remove();
                });
            }
            $.support.transition && this.$tip.hasClass("fade") ? removeWithAnimation() : $tip.remove();
        },
        fixTitle: function() {
            var $e = this.$element;
            if ($e.attr("title") || typeof $e.attr("data-original-title") != "string") {
                $e.attr("data-original-title", $e.attr("title") || "").removeAttr("title");
            }
        },
        hasContent: function() {
            return this.getTitle();
        },
        getPosition: function(inside) {
            return $.extend({}, inside ? {
                top: 0,
                left: 0
            } : this.$element.offset(), {
                width: this.$element[0].offsetWidth,
                height: this.$element[0].offsetHeight
            });
        },
        getTitle: function() {
            var title, $e = this.$element, o = this.options;
            title = $e.attr("data-original-title") || (typeof o.title == "function" ? o.title.call($e[0]) : o.title);
            title = (title || "").toString().replace(/(^\s*|\s*$)/, "");
            return title;
        },
        tip: function() {
            return this.$tip = this.$tip || $(this.options.template);
        },
        validate: function() {
            if (!this.$element[0].parentNode) {
                this.hide();
                this.$element = null;
                this.options = null;
            }
        },
        enable: function() {
            this.enabled = true;
        },
        disable: function() {
            this.enabled = false;
        },
        toggleEnabled: function() {
            this.enabled = !this.enabled;
        },
        toggle: function() {
            this[this.tip().hasClass("in") ? "hide" : "show"]();
        }
    };
    $.fn.tooltip = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("tooltip"), options = typeof option == "object" && option;
            if (!data) $this.data("tooltip", data = new Tooltip(this, options));
            if (typeof option == "string") data[option]();
        });
    };
    $.fn.tooltip.Constructor = Tooltip;
    $.fn.tooltip.defaults = {
        animation: true,
        delay: 0,
        selector: false,
        placement: "top",
        trigger: "hover",
        title: "",
        template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
    };
}(window.jQuery);

!function($) {
    "use strict";
    var Popover = function(element, options) {
        this.init("popover", element, options);
    };
    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype, {
        constructor: Popover,
        setContent: function() {
            var $tip = this.tip(), title = this.getTitle(), content = this.getContent();
            $tip.find(".popover-title")[$.type(title) == "object" ? "append" : "html"](title);
            $tip.find(".popover-content > *")[$.type(content) == "object" ? "append" : "html"](content);
            $tip.removeClass("fade top bottom left right in");
        },
        hasContent: function() {
            return this.getTitle() || this.getContent();
        },
        getContent: function() {
            var content, $e = this.$element, o = this.options;
            content = $e.attr("data-content") || (typeof o.content == "function" ? o.content.call($e[0]) : o.content);
            content = content.toString().replace(/(^\s*|\s*$)/, "");
            return content;
        },
        tip: function() {
            if (!this.$tip) {
                this.$tip = $(this.options.template);
            }
            return this.$tip;
        }
    });
    $.fn.popover = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("popover"), options = typeof option == "object" && option;
            if (!data) $this.data("popover", data = new Popover(this, options));
            if (typeof option == "string") data[option]();
        });
    };
    $.fn.popover.Constructor = Popover;
    $.fn.popover.defaults = $.extend({}, $.fn.tooltip.defaults, {
        placement: "right",
        content: "",
        template: '<div class="popover"><div class="arrow"></div><div class="popover-inner"><h3 class="popover-title"></h3><div class="popover-content"><p></p></div></div></div>'
    });
}(window.jQuery);

!function($) {
    "use strict";
    function ScrollSpy(element, options) {
        var process = $.proxy(this.process, this), $element = $(element).is("body") ? $(window) : $(element), href;
        this.options = $.extend({}, $.fn.scrollspy.defaults, options);
        this.$scrollElement = $element.on("scroll.scroll.data-api", process);
        this.selector = (this.options.target || (href = $(element).attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "") || "") + " .nav li > a";
        this.$body = $("body").on("click.scroll.data-api", this.selector, process);
        this.refresh();
        this.process();
    }
    ScrollSpy.prototype = {
        constructor: ScrollSpy,
        refresh: function() {
            this.targets = this.$body.find(this.selector).map(function() {
                var href = $(this).attr("href");
                return /^#\w/.test(href) && $(href).length ? href : null;
            });
            this.offsets = $.map(this.targets, function(id) {
                return $(id).position().top;
            });
        },
        process: function() {
            var scrollTop = this.$scrollElement.scrollTop() + this.options.offset, offsets = this.offsets, targets = this.targets, activeTarget = this.activeTarget, i;
            for (i = offsets.length; i--; ) {
                activeTarget != targets[i] && scrollTop >= offsets[i] && (!offsets[i + 1] || scrollTop <= offsets[i + 1]) && this.activate(targets[i]);
            }
        },
        activate: function(target) {
            var active;
            this.activeTarget = target;
            this.$body.find(this.selector).parent(".active").removeClass("active");
            active = this.$body.find(this.selector + '[href="' + target + '"]').parent("li").addClass("active");
            if (active.parent(".dropdown-menu")) {
                active.closest("li.dropdown").addClass("active");
            }
        }
    };
    $.fn.scrollspy = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("scrollspy"), options = typeof option == "object" && option;
            if (!data) $this.data("scrollspy", data = new ScrollSpy(this, options));
            if (typeof option == "string") data[option]();
        });
    };
    $.fn.scrollspy.Constructor = ScrollSpy;
    $.fn.scrollspy.defaults = {
        offset: 10
    };
    $(function() {
        $('[data-spy="scroll"]').each(function() {
            var $spy = $(this);
            $spy.scrollspy($spy.data());
        });
    });
}(window.jQuery);

!function($) {
    "use strict";
    var Tab = function(element) {
        this.element = $(element);
    };
    Tab.prototype = {
        constructor: Tab,
        show: function() {
            var $this = this.element, $ul = $this.closest("ul:not(.dropdown-menu)"), selector = $this.attr("data-target"), previous, $target;
            if (!selector) {
                selector = $this.attr("href");
                selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
            }
            if ($this.parent("li").hasClass("active")) return;
            previous = $ul.find(".active a").last()[0];
            $this.trigger({
                type: "show",
                relatedTarget: previous
            });
            $target = $(selector);
            this.activate($this.parent("li"), $ul);
            this.activate($target, $target.parent(), function() {
                $this.trigger({
                    type: "shown",
                    relatedTarget: previous
                });
            });
        },
        activate: function(element, container, callback) {
            var $active = container.find("> .active"), transition = callback && $.support.transition && $active.hasClass("fade");
            function next() {
                $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active");
                element.addClass("active");
                if (transition) {
                    element[0].offsetWidth;
                    element.addClass("in");
                } else {
                    element.removeClass("fade");
                }
                if (element.parent(".dropdown-menu")) {
                    element.closest("li.dropdown").addClass("active");
                }
                callback && callback();
            }
            transition ? $active.one($.support.transition.end, next) : next();
            $active.removeClass("in");
        }
    };
    $.fn.tab = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("tab");
            if (!data) $this.data("tab", data = new Tab(this));
            if (typeof option == "string") data[option]();
        });
    };
    $.fn.tab.Constructor = Tab;
    $(function() {
        $("body").on("click.tab.data-api", '[data-toggle="tab"], [data-toggle="pill"]', function(e) {
            e.preventDefault();
            $(this).tab("show");
        });
    });
}(window.jQuery);

!function($) {
    "use strict";
    var Typeahead = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, $.fn.typeahead.defaults, options);
        this.matcher = this.options.matcher || this.matcher;
        this.sorter = this.options.sorter || this.sorter;
        this.highlighter = this.options.highlighter || this.highlighter;
        this.$menu = $(this.options.menu).appendTo("body");
        this.source = this.options.source;
        this.shown = false;
        this.listen();
    };
    Typeahead.prototype = {
        constructor: Typeahead,
        select: function() {
            var val = this.$menu.find(".active").attr("data-value");
            this.$element.val(val);
            this.$element.change();
            return this.hide();
        },
        show: function() {
            var pos = $.extend({}, this.$element.offset(), {
                height: this.$element[0].offsetHeight
            });
            this.$menu.css({
                top: pos.top + pos.height,
                left: pos.left
            });
            this.$menu.show();
            this.shown = true;
            return this;
        },
        hide: function() {
            this.$menu.hide();
            this.shown = false;
            return this;
        },
        lookup: function(event) {
            var that = this, items, q;
            this.query = this.$element.val();
            if (!this.query) {
                return this.shown ? this.hide() : this;
            }
            items = $.grep(this.source, function(item) {
                if (that.matcher(item)) return item;
            });
            items = this.sorter(items);
            if (!items.length) {
                return this.shown ? this.hide() : this;
            }
            return this.render(items.slice(0, this.options.items)).show();
        },
        matcher: function(item) {
            return ~item.toLowerCase().indexOf(this.query.toLowerCase());
        },
        sorter: function(items) {
            var beginswith = [], caseSensitive = [], caseInsensitive = [], item;
            while (item = items.shift()) {
                if (!item.toLowerCase().indexOf(this.query.toLowerCase())) beginswith.push(item); else if (~item.indexOf(this.query)) caseSensitive.push(item); else caseInsensitive.push(item);
            }
            return beginswith.concat(caseSensitive, caseInsensitive);
        },
        highlighter: function(item) {
            return item.replace(new RegExp("(" + this.query + ")", "ig"), function($1, match) {
                return "<strong>" + match + "</strong>";
            });
        },
        render: function(items) {
            var that = this;
            items = $(items).map(function(i, item) {
                i = $(that.options.item).attr("data-value", item);
                i.find("a").html(that.highlighter(item));
                return i[0];
            });
            items.first().addClass("active");
            this.$menu.html(items);
            return this;
        },
        next: function(event) {
            var active = this.$menu.find(".active").removeClass("active"), next = active.next();
            if (!next.length) {
                next = $(this.$menu.find("li")[0]);
            }
            next.addClass("active");
        },
        prev: function(event) {
            var active = this.$menu.find(".active").removeClass("active"), prev = active.prev();
            if (!prev.length) {
                prev = this.$menu.find("li").last();
            }
            prev.addClass("active");
        },
        listen: function() {
            this.$element.on("blur", $.proxy(this.blur, this)).on("keypress", $.proxy(this.keypress, this)).on("keyup", $.proxy(this.keyup, this));
            if ($.browser.webkit || $.browser.msie) {
                this.$element.on("keydown", $.proxy(this.keypress, this));
            }
            this.$menu.on("click", $.proxy(this.click, this)).on("mouseenter", "li", $.proxy(this.mouseenter, this));
        },
        keyup: function(e) {
            switch (e.keyCode) {
              case 40:
              case 38:
                break;

              case 9:
              case 13:
                if (!this.shown) return;
                this.select();
                break;

              case 27:
                if (!this.shown) return;
                this.hide();
                break;

              default:
                this.lookup();
            }
            e.stopPropagation();
            e.preventDefault();
        },
        keypress: function(e) {
            if (!this.shown) return;
            switch (e.keyCode) {
              case 9:
              case 13:
              case 27:
                e.preventDefault();
                break;

              case 38:
                e.preventDefault();
                this.prev();
                break;

              case 40:
                e.preventDefault();
                this.next();
                break;
            }
            e.stopPropagation();
        },
        blur: function(e) {
            var that = this;
            setTimeout(function() {
                that.hide();
            }, 150);
        },
        click: function(e) {
            e.stopPropagation();
            e.preventDefault();
            this.select();
        },
        mouseenter: function(e) {
            this.$menu.find(".active").removeClass("active");
            $(e.currentTarget).addClass("active");
        }
    };
    $.fn.typeahead = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("typeahead"), options = typeof option == "object" && option;
            if (!data) $this.data("typeahead", data = new Typeahead(this, options));
            if (typeof option == "string") data[option]();
        });
    };
    $.fn.typeahead.defaults = {
        source: [],
        items: 8,
        menu: '<ul class="typeahead dropdown-menu"></ul>',
        item: '<li><a href="#"></a></li>'
    };
    $.fn.typeahead.Constructor = Typeahead;
    $(function() {
        $("body").on("focus.typeahead.data-api", '[data-provide="typeahead"]', function(e) {
            var $this = $(this);
            if ($this.data("typeahead")) return;
            e.preventDefault();
            $this.typeahead($this.data());
        });
    });
}(window.jQuery);

!function($) {
    "use strict";
    var Affix = function(element, options) {
        this.options = $.extend({}, $.fn.affix.defaults, options);
        this.$window = $(window).on("scroll.affix.data-api", $.proxy(this.checkPosition, this));
        this.$element = $(element);
        this.checkPosition();
    };
    Affix.prototype.checkPosition = function() {
        if (!this.$element.is(":visible")) return;
        var scrollHeight = $(document).height(), scrollTop = this.$window.scrollTop(), position = this.$element.offset(), offset = this.options.offset, offsetBottom = offset.bottom, offsetTop = offset.top, reset = "affix affix-top affix-bottom", affix;
        if (typeof offset != "object") offsetBottom = offsetTop = offset;
        if (typeof offsetTop == "function") offsetTop = offset.top();
        if (typeof offsetBottom == "function") offsetBottom = offset.bottom();
        affix = this.unpin != null && scrollTop + this.unpin <= position.top ? false : offsetBottom != null && position.top + this.$element.height() >= scrollHeight - offsetBottom ? "bottom" : offsetTop != null && scrollTop <= offsetTop ? "top" : false;
        if (this.affixed === affix) return;
        if (affix) {
            this.$element.trigger("unaffixed");
        } else {
            this.$element.trigger("affixed");
        }
        this.affixed = affix;
        this.unpin = affix == "bottom" ? position.top - scrollTop : null;
        this.$element.removeClass(reset).addClass("affix" + (affix ? "-" + affix : ""));
    };
    $.fn.affix = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("affix"), options = typeof option == "object" && option;
            if (!data) $this.data("affix", data = new Affix(this, options));
            if (typeof option == "string") data[option]();
        });
    };
    $.fn.affix.Constructor = Affix;
    $.fn.affix.defaults = {
        offset: 0
    };
    $(window).on("load", function() {
        $('[data-spy="affix"]').each(function() {
            var $spy = $(this), data = $spy.data();
            data.offset = data.offset || {};
            data.offsetBottom && (data.offset.bottom = data.offsetBottom);
            data.offsetTop && (data.offset.top = data.offsetTop);
            $spy.affix(data);
        });
    });
}(window.jQuery);

(function($, undefined) {
    var uuid = 0, runiqueId = /^ui-id-\d+$/;
    $.ui = $.ui || {};
    $.extend($.ui, {
        version: "1.10.3",
        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            NUMPAD_ADD: 107,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            NUMPAD_ENTER: 108,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_SUBTRACT: 109,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    });
    $.fn.extend({
        focus: function(orig) {
            return function(delay, fn) {
                return typeof delay === "number" ? this.each(function() {
                    var elem = this;
                    setTimeout(function() {
                        $(elem).focus();
                        if (fn) {
                            fn.call(elem);
                        }
                    }, delay);
                }) : orig.apply(this, arguments);
            };
        }($.fn.focus),
        scrollParent: function() {
            var scrollParent;
            if ($.ui.ie && /(static|relative)/.test(this.css("position")) || /absolute/.test(this.css("position"))) {
                scrollParent = this.parents().filter(function() {
                    return /(relative|absolute|fixed)/.test($.css(this, "position")) && /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
                }).eq(0);
            } else {
                scrollParent = this.parents().filter(function() {
                    return /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
                }).eq(0);
            }
            return /fixed/.test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
        },
        zIndex: function(zIndex) {
            if (zIndex !== undefined) {
                return this.css("zIndex", zIndex);
            }
            if (this.length) {
                var elem = $(this[0]), position, value;
                while (elem.length && elem[0] !== document) {
                    position = elem.css("position");
                    if (position === "absolute" || position === "relative" || position === "fixed") {
                        value = parseInt(elem.css("zIndex"), 10);
                        if (!isNaN(value) && value !== 0) {
                            return value;
                        }
                    }
                    elem = elem.parent();
                }
            }
            return 0;
        },
        uniqueId: function() {
            return this.each(function() {
                if (!this.id) {
                    this.id = "ui-id-" + ++uuid;
                }
            });
        },
        removeUniqueId: function() {
            return this.each(function() {
                if (runiqueId.test(this.id)) {
                    $(this).removeAttr("id");
                }
            });
        }
    });
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img, nodeName = element.nodeName.toLowerCase();
        if ("area" === nodeName) {
            map = element.parentNode;
            mapName = map.name;
            if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
                return false;
            }
            img = $("img[usemap=#" + mapName + "]")[0];
            return !!img && visible(img);
        }
        return (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element);
    }
    function visible(element) {
        return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function() {
            return $.css(this, "visibility") === "hidden";
        }).length;
    }
    $.extend($.expr[":"], {
        data: $.expr.createPseudo ? $.expr.createPseudo(function(dataName) {
            return function(elem) {
                return !!$.data(elem, dataName);
            };
        }) : function(elem, i, match) {
            return !!$.data(elem, match[3]);
        },
        focusable: function(element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")));
        },
        tabbable: function(element) {
            var tabIndex = $.attr(element, "tabindex"), isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    });
    if (!$("<a>").outerWidth(1).jquery) {
        $.each([ "Width", "Height" ], function(i, name) {
            var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ], type = name.toLowerCase(), orig = {
                innerWidth: $.fn.innerWidth,
                innerHeight: $.fn.innerHeight,
                outerWidth: $.fn.outerWidth,
                outerHeight: $.fn.outerHeight
            };
            function reduce(elem, size, border, margin) {
                $.each(side, function() {
                    size -= parseFloat($.css(elem, "padding" + this)) || 0;
                    if (border) {
                        size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
                    }
                    if (margin) {
                        size -= parseFloat($.css(elem, "margin" + this)) || 0;
                    }
                });
                return size;
            }
            $.fn["inner" + name] = function(size) {
                if (size === undefined) {
                    return orig["inner" + name].call(this);
                }
                return this.each(function() {
                    $(this).css(type, reduce(this, size) + "px");
                });
            };
            $.fn["outer" + name] = function(size, margin) {
                if (typeof size !== "number") {
                    return orig["outer" + name].call(this, size);
                }
                return this.each(function() {
                    $(this).css(type, reduce(this, size, true, margin) + "px");
                });
            };
        });
    }
    if (!$.fn.addBack) {
        $.fn.addBack = function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        };
    }
    if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
        $.fn.removeData = function(removeData) {
            return function(key) {
                if (arguments.length) {
                    return removeData.call(this, $.camelCase(key));
                } else {
                    return removeData.call(this);
                }
            };
        }($.fn.removeData);
    }
    $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
    $.support.selectstart = "onselectstart" in document.createElement("div");
    $.fn.extend({
        disableSelection: function() {
            return this.bind(($.support.selectstart ? "selectstart" : "mousedown") + ".ui-disableSelection", function(event) {
                event.preventDefault();
            });
        },
        enableSelection: function() {
            return this.unbind(".ui-disableSelection");
        }
    });
    $.extend($.ui, {
        plugin: {
            add: function(module, option, set) {
                var i, proto = $.ui[module].prototype;
                for (i in set) {
                    proto.plugins[i] = proto.plugins[i] || [];
                    proto.plugins[i].push([ option, set[i] ]);
                }
            },
            call: function(instance, name, args) {
                var i, set = instance.plugins[name];
                if (!set || !instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11) {
                    return;
                }
                for (i = 0; i < set.length; i++) {
                    if (instance.options[set[i][0]]) {
                        set[i][1].apply(instance.element, args);
                    }
                }
            }
        },
        hasScroll: function(el, a) {
            if ($(el).css("overflow") === "hidden") {
                return false;
            }
            var scroll = a && a === "left" ? "scrollLeft" : "scrollTop", has = false;
            if (el[scroll] > 0) {
                return true;
            }
            el[scroll] = 1;
            has = el[scroll] > 0;
            el[scroll] = 0;
            return has;
        }
    });
})(jQuery);

(function($, undefined) {
    var uuid = 0, slice = Array.prototype.slice, _cleanData = $.cleanData;
    $.cleanData = function(elems) {
        for (var i = 0, elem; (elem = elems[i]) != null; i++) {
            try {
                $(elem).triggerHandler("remove");
            } catch (e) {}
        }
        _cleanData(elems);
    };
    $.widget = function(name, base, prototype) {
        var fullName, existingConstructor, constructor, basePrototype, proxiedPrototype = {}, namespace = name.split(".")[0];
        name = name.split(".")[1];
        fullName = namespace + "-" + name;
        if (!prototype) {
            prototype = base;
            base = $.Widget;
        }
        $.expr[":"][fullName.toLowerCase()] = function(elem) {
            return !!$.data(elem, fullName);
        };
        $[namespace] = $[namespace] || {};
        existingConstructor = $[namespace][name];
        constructor = $[namespace][name] = function(options, element) {
            if (!this._createWidget) {
                return new constructor(options, element);
            }
            if (arguments.length) {
                this._createWidget(options, element);
            }
        };
        $.extend(constructor, existingConstructor, {
            version: prototype.version,
            _proto: $.extend({}, prototype),
            _childConstructors: []
        });
        basePrototype = new base();
        basePrototype.options = $.widget.extend({}, basePrototype.options);
        $.each(prototype, function(prop, value) {
            if (!$.isFunction(value)) {
                proxiedPrototype[prop] = value;
                return;
            }
            proxiedPrototype[prop] = function() {
                var _super = function() {
                    return base.prototype[prop].apply(this, arguments);
                }, _superApply = function(args) {
                    return base.prototype[prop].apply(this, args);
                };
                return function() {
                    var __super = this._super, __superApply = this._superApply, returnValue;
                    this._super = _super;
                    this._superApply = _superApply;
                    returnValue = value.apply(this, arguments);
                    this._super = __super;
                    this._superApply = __superApply;
                    return returnValue;
                };
            }();
        });
        constructor.prototype = $.widget.extend(basePrototype, {
            widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        });
        if (existingConstructor) {
            $.each(existingConstructor._childConstructors, function(i, child) {
                var childPrototype = child.prototype;
                $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
            });
            delete existingConstructor._childConstructors;
        } else {
            base._childConstructors.push(constructor);
        }
        $.widget.bridge(name, constructor);
    };
    $.widget.extend = function(target) {
        var input = slice.call(arguments, 1), inputIndex = 0, inputLength = input.length, key, value;
        for (;inputIndex < inputLength; inputIndex++) {
            for (key in input[inputIndex]) {
                value = input[inputIndex][key];
                if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
                    if ($.isPlainObject(value)) {
                        target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value);
                    } else {
                        target[key] = value;
                    }
                }
            }
        }
        return target;
    };
    $.widget.bridge = function(name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function(options) {
            var isMethodCall = typeof options === "string", args = slice.call(arguments, 1), returnValue = this;
            options = !isMethodCall && args.length ? $.widget.extend.apply(null, [ options ].concat(args)) : options;
            if (isMethodCall) {
                this.each(function() {
                    var methodValue, instance = $.data(this, fullName);
                    if (!instance) {
                        return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
                    }
                    if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                        return $.error("no such method '" + options + "' for " + name + " widget instance");
                    }
                    methodValue = instance[options].apply(instance, args);
                    if (methodValue !== instance && methodValue !== undefined) {
                        returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
                        return false;
                    }
                });
            } else {
                this.each(function() {
                    var instance = $.data(this, fullName);
                    if (instance) {
                        instance.option(options || {})._init();
                    } else {
                        $.data(this, fullName, new object(options, this));
                    }
                });
            }
            return returnValue;
        };
    };
    $.Widget = function() {};
    $.Widget._childConstructors = [];
    $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: false,
            create: null
        },
        _createWidget: function(options, element) {
            element = $(element || this.defaultElement || this)[0];
            this.element = $(element);
            this.uuid = uuid++;
            this.eventNamespace = "." + this.widgetName + this.uuid;
            this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();
            if (element !== this) {
                $.data(element, this.widgetFullName, this);
                this._on(true, this.element, {
                    remove: function(event) {
                        if (event.target === element) {
                            this.destroy();
                        }
                    }
                });
                this.document = $(element.style ? element.ownerDocument : element.document || element);
                this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
            }
            this._create();
            this._trigger("create", null, this._getCreateEventData());
            this._init();
        },
        _getCreateOptions: $.noop,
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,
        destroy: function() {
            this._destroy();
            this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName));
            this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled " + "ui-state-disabled");
            this.bindings.unbind(this.eventNamespace);
            this.hoverable.removeClass("ui-state-hover");
            this.focusable.removeClass("ui-state-focus");
        },
        _destroy: $.noop,
        widget: function() {
            return this.element;
        },
        option: function(key, value) {
            var options = key, parts, curOption, i;
            if (arguments.length === 0) {
                return $.widget.extend({}, this.options);
            }
            if (typeof key === "string") {
                options = {};
                parts = key.split(".");
                key = parts.shift();
                if (parts.length) {
                    curOption = options[key] = $.widget.extend({}, this.options[key]);
                    for (i = 0; i < parts.length - 1; i++) {
                        curOption[parts[i]] = curOption[parts[i]] || {};
                        curOption = curOption[parts[i]];
                    }
                    key = parts.pop();
                    if (value === undefined) {
                        return curOption[key] === undefined ? null : curOption[key];
                    }
                    curOption[key] = value;
                } else {
                    if (value === undefined) {
                        return this.options[key] === undefined ? null : this.options[key];
                    }
                    options[key] = value;
                }
            }
            this._setOptions(options);
            return this;
        },
        _setOptions: function(options) {
            var key;
            for (key in options) {
                this._setOption(key, options[key]);
            }
            return this;
        },
        _setOption: function(key, value) {
            this.options[key] = value;
            if (key === "disabled") {
                this.widget().toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!value).attr("aria-disabled", value);
                this.hoverable.removeClass("ui-state-hover");
                this.focusable.removeClass("ui-state-focus");
            }
            return this;
        },
        enable: function() {
            return this._setOption("disabled", false);
        },
        disable: function() {
            return this._setOption("disabled", true);
        },
        _on: function(suppressDisabledCheck, element, handlers) {
            var delegateElement, instance = this;
            if (typeof suppressDisabledCheck !== "boolean") {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false;
            }
            if (!handlers) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget();
            } else {
                element = delegateElement = $(element);
                this.bindings = this.bindings.add(element);
            }
            $.each(handlers, function(event, handler) {
                function handlerProxy() {
                    if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass("ui-state-disabled"))) {
                        return;
                    }
                    return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
                }
                if (typeof handler !== "string") {
                    handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
                }
                var match = event.match(/^(\w+)\s*(.*)$/), eventName = match[1] + instance.eventNamespace, selector = match[2];
                if (selector) {
                    delegateElement.delegate(selector, eventName, handlerProxy);
                } else {
                    element.bind(eventName, handlerProxy);
                }
            });
        },
        _off: function(element, eventName) {
            eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
            element.unbind(eventName).undelegate(eventName);
        },
        _delay: function(handler, delay) {
            function handlerProxy() {
                return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },
        _hoverable: function(element) {
            this.hoverable = this.hoverable.add(element);
            this._on(element, {
                mouseenter: function(event) {
                    $(event.currentTarget).addClass("ui-state-hover");
                },
                mouseleave: function(event) {
                    $(event.currentTarget).removeClass("ui-state-hover");
                }
            });
        },
        _focusable: function(element) {
            this.focusable = this.focusable.add(element);
            this._on(element, {
                focusin: function(event) {
                    $(event.currentTarget).addClass("ui-state-focus");
                },
                focusout: function(event) {
                    $(event.currentTarget).removeClass("ui-state-focus");
                }
            });
        },
        _trigger: function(type, event, data) {
            var prop, orig, callback = this.options[type];
            data = data || {};
            event = $.Event(event);
            event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
            event.target = this.element[0];
            orig = event.originalEvent;
            if (orig) {
                for (prop in orig) {
                    if (!(prop in event)) {
                        event[prop] = orig[prop];
                    }
                }
            }
            this.element.trigger(event, data);
            return !($.isFunction(callback) && callback.apply(this.element[0], [ event ].concat(data)) === false || event.isDefaultPrevented());
        }
    };
    $.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, function(method, defaultEffect) {
        $.Widget.prototype["_" + method] = function(element, options, callback) {
            if (typeof options === "string") {
                options = {
                    effect: options
                };
            }
            var hasOptions, effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect;
            options = options || {};
            if (typeof options === "number") {
                options = {
                    duration: options
                };
            }
            hasOptions = !$.isEmptyObject(options);
            options.complete = callback;
            if (options.delay) {
                element.delay(options.delay);
            }
            if (hasOptions && $.effects && $.effects.effect[effectName]) {
                element[method](options);
            } else if (effectName !== method && element[effectName]) {
                element[effectName](options.duration, options.easing, callback);
            } else {
                element.queue(function(next) {
                    $(this)[method]();
                    if (callback) {
                        callback.call(element[0]);
                    }
                    next();
                });
            }
        };
    });
})(jQuery);

(function($, undefined) {
    var mouseHandled = false;
    $(document).mouseup(function() {
        mouseHandled = false;
    });
    $.widget("ui.mouse", {
        version: "1.10.3",
        options: {
            cancel: "input,textarea,button,select,option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function() {
            var that = this;
            this.element.bind("mousedown." + this.widgetName, function(event) {
                return that._mouseDown(event);
            }).bind("click." + this.widgetName, function(event) {
                if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                    $.removeData(event.target, that.widgetName + ".preventClickEvent");
                    event.stopImmediatePropagation();
                    return false;
                }
            });
            this.started = false;
        },
        _mouseDestroy: function() {
            this.element.unbind("." + this.widgetName);
            if (this._mouseMoveDelegate) {
                $(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
            }
        },
        _mouseDown: function(event) {
            if (mouseHandled) {
                return;
            }
            this._mouseStarted && this._mouseUp(event);
            this._mouseDownEvent = event;
            var that = this, btnIsLeft = event.which === 1, elIsCancel = typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false;
            if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                return true;
            }
            this.mouseDelayMet = !this.options.delay;
            if (!this.mouseDelayMet) {
                this._mouseDelayTimer = setTimeout(function() {
                    that.mouseDelayMet = true;
                }, this.options.delay);
            }
            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted = this._mouseStart(event) !== false;
                if (!this._mouseStarted) {
                    event.preventDefault();
                    return true;
                }
            }
            if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
                $.removeData(event.target, this.widgetName + ".preventClickEvent");
            }
            this._mouseMoveDelegate = function(event) {
                return that._mouseMove(event);
            };
            this._mouseUpDelegate = function(event) {
                return that._mouseUp(event);
            };
            $(document).bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate);
            event.preventDefault();
            mouseHandled = true;
            return true;
        },
        _mouseMove: function(event) {
            if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
                return this._mouseUp(event);
            }
            if (this._mouseStarted) {
                this._mouseDrag(event);
                return event.preventDefault();
            }
            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== false;
                this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event);
            }
            return !this._mouseStarted;
        },
        _mouseUp: function(event) {
            $(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
            if (this._mouseStarted) {
                this._mouseStarted = false;
                if (event.target === this._mouseDownEvent.target) {
                    $.data(event.target, this.widgetName + ".preventClickEvent", true);
                }
                this._mouseStop(event);
            }
            return false;
        },
        _mouseDistanceMet: function(event) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;
        },
        _mouseDelayMet: function() {
            return this.mouseDelayMet;
        },
        _mouseStart: function() {},
        _mouseDrag: function() {},
        _mouseStop: function() {},
        _mouseCapture: function() {
            return true;
        }
    });
})(jQuery);

(function($, undefined) {
    $.widget("ui.draggable", $.ui.mouse, {
        version: "1.10.3",
        widgetEventPrefix: "drag",
        options: {
            addClasses: true,
            appendTo: "parent",
            axis: false,
            connectToSortable: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            grid: false,
            handle: false,
            helper: "original",
            iframeFix: false,
            opacity: false,
            refreshPositions: false,
            revert: false,
            revertDuration: 500,
            scope: "default",
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: false,
            snapMode: "both",
            snapTolerance: 20,
            stack: false,
            zIndex: false,
            drag: null,
            start: null,
            stop: null
        },
        _create: function() {
            if (this.options.helper === "original" && !/^(?:r|a|f)/.test(this.element.css("position"))) {
                this.element[0].style.position = "relative";
            }
            if (this.options.addClasses) {
                this.element.addClass("ui-draggable");
            }
            if (this.options.disabled) {
                this.element.addClass("ui-draggable-disabled");
            }
            this._mouseInit();
        },
        _destroy: function() {
            this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled");
            this._mouseDestroy();
        },
        _mouseCapture: function(event) {
            var o = this.options;
            if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
                return false;
            }
            this.handle = this._getHandle(event);
            if (!this.handle) {
                return false;
            }
            $(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
                $("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>").css({
                    width: this.offsetWidth + "px",
                    height: this.offsetHeight + "px",
                    position: "absolute",
                    opacity: "0.001",
                    zIndex: 1e3
                }).css($(this).offset()).appendTo("body");
            });
            return true;
        },
        _mouseStart: function(event) {
            var o = this.options;
            this.helper = this._createHelper(event);
            this.helper.addClass("ui-draggable-dragging");
            this._cacheHelperProportions();
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }
            this._cacheMargins();
            this.cssPosition = this.helper.css("position");
            this.scrollParent = this.helper.scrollParent();
            this.offsetParent = this.helper.offsetParent();
            this.offsetParentCssPosition = this.offsetParent.css("position");
            this.offset = this.positionAbs = this.element.offset();
            this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            };
            this.offset.scroll = false;
            $.extend(this.offset, {
                click: {
                    left: event.pageX - this.offset.left,
                    top: event.pageY - this.offset.top
                },
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            });
            this.originalPosition = this.position = this._generatePosition(event);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;
            o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
            this._setContainment();
            if (this._trigger("start", event) === false) {
                this._clear();
                return false;
            }
            this._cacheHelperProportions();
            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }
            this._mouseDrag(event, true);
            if ($.ui.ddmanager) {
                $.ui.ddmanager.dragStart(this, event);
            }
            return true;
        },
        _mouseDrag: function(event, noPropagation) {
            if (this.offsetParentCssPosition === "fixed") {
                this.offset.parent = this._getParentOffset();
            }
            this.position = this._generatePosition(event);
            this.positionAbs = this._convertPositionTo("absolute");
            if (!noPropagation) {
                var ui = this._uiHash();
                if (this._trigger("drag", event, ui) === false) {
                    this._mouseUp({});
                    return false;
                }
                this.position = ui.position;
            }
            if (!this.options.axis || this.options.axis !== "y") {
                this.helper[0].style.left = this.position.left + "px";
            }
            if (!this.options.axis || this.options.axis !== "x") {
                this.helper[0].style.top = this.position.top + "px";
            }
            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }
            return false;
        },
        _mouseStop: function(event) {
            var that = this, dropped = false;
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                dropped = $.ui.ddmanager.drop(this, event);
            }
            if (this.dropped) {
                dropped = this.dropped;
                this.dropped = false;
            }
            if (this.options.helper === "original" && !$.contains(this.element[0].ownerDocument, this.element[0])) {
                return false;
            }
            if (this.options.revert === "invalid" && !dropped || this.options.revert === "valid" && dropped || this.options.revert === true || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped)) {
                $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                    if (that._trigger("stop", event) !== false) {
                        that._clear();
                    }
                });
            } else {
                if (this._trigger("stop", event) !== false) {
                    this._clear();
                }
            }
            return false;
        },
        _mouseUp: function(event) {
            $("div.ui-draggable-iframeFix").each(function() {
                this.parentNode.removeChild(this);
            });
            if ($.ui.ddmanager) {
                $.ui.ddmanager.dragStop(this, event);
            }
            return $.ui.mouse.prototype._mouseUp.call(this, event);
        },
        cancel: function() {
            if (this.helper.is(".ui-draggable-dragging")) {
                this._mouseUp({});
            } else {
                this._clear();
            }
            return this;
        },
        _getHandle: function(event) {
            return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : true;
        },
        _createHelper: function(event) {
            var o = this.options, helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [ event ])) : o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element;
            if (!helper.parents("body").length) {
                helper.appendTo(o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo);
            }
            if (helper[0] !== this.element[0] && !/(fixed|absolute)/.test(helper.css("position"))) {
                helper.css("position", "absolute");
            }
            return helper;
        },
        _adjustOffsetFromHelper: function(obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if ($.isArray(obj)) {
                obj = {
                    left: +obj[0],
                    top: +obj[1] || 0
                };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },
        _getParentOffset: function() {
            var po = this.offsetParent.offset();
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }
            if (this.offsetParent[0] === document.body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie) {
                po = {
                    top: 0,
                    left: 0
                };
            }
            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };
        },
        _getRelativeOffset: function() {
            if (this.cssPosition === "relative") {
                var p = this.element.position();
                return {
                    top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                };
            } else {
                return {
                    top: 0,
                    left: 0
                };
            }
        },
        _cacheMargins: function() {
            this.margins = {
                left: parseInt(this.element.css("marginLeft"), 10) || 0,
                top: parseInt(this.element.css("marginTop"), 10) || 0,
                right: parseInt(this.element.css("marginRight"), 10) || 0,
                bottom: parseInt(this.element.css("marginBottom"), 10) || 0
            };
        },
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },
        _setContainment: function() {
            var over, c, ce, o = this.options;
            if (!o.containment) {
                this.containment = null;
                return;
            }
            if (o.containment === "window") {
                this.containment = [ $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left, $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ];
                return;
            }
            if (o.containment === "document") {
                this.containment = [ 0, 0, $(document).width() - this.helperProportions.width - this.margins.left, ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ];
                return;
            }
            if (o.containment.constructor === Array) {
                this.containment = o.containment;
                return;
            }
            if (o.containment === "parent") {
                o.containment = this.helper[0].parentNode;
            }
            c = $(o.containment);
            ce = c[0];
            if (!ce) {
                return;
            }
            over = c.css("overflow") !== "hidden";
            this.containment = [ (parseInt(c.css("borderLeftWidth"), 10) || 0) + (parseInt(c.css("paddingLeft"), 10) || 0), (parseInt(c.css("borderTopWidth"), 10) || 0) + (parseInt(c.css("paddingTop"), 10) || 0), (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css("borderRightWidth"), 10) || 0) - (parseInt(c.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css("borderBottomWidth"), 10) || 0) - (parseInt(c.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom ];
            this.relative_container = c;
        },
        _convertPositionTo: function(d, pos) {
            if (!pos) {
                pos = this.position;
            }
            var mod = d === "absolute" ? 1 : -1, scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent;
            if (!this.offset.scroll) {
                this.offset.scroll = {
                    top: scroll.scrollTop(),
                    left: scroll.scrollLeft()
                };
            }
            return {
                top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top) * mod,
                left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left) * mod
            };
        },
        _generatePosition: function(event) {
            var containment, co, top, left, o = this.options, scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, pageX = event.pageX, pageY = event.pageY;
            if (!this.offset.scroll) {
                this.offset.scroll = {
                    top: scroll.scrollTop(),
                    left: scroll.scrollLeft()
                };
            }
            if (this.originalPosition) {
                if (this.containment) {
                    if (this.relative_container) {
                        co = this.relative_container.offset();
                        containment = [ this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top ];
                    } else {
                        containment = this.containment;
                    }
                    if (event.pageX - this.offset.click.left < containment[0]) {
                        pageX = containment[0] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top < containment[1]) {
                        pageY = containment[1] + this.offset.click.top;
                    }
                    if (event.pageX - this.offset.click.left > containment[2]) {
                        pageX = containment[2] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top > containment[3]) {
                        pageY = containment[3] + this.offset.click.top;
                    }
                }
                if (o.grid) {
                    top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
                    pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
                    left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
                    pageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
                }
            }
            return {
                top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top),
                left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left)
            };
        },
        _clear: function() {
            this.helper.removeClass("ui-draggable-dragging");
            if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
                this.helper.remove();
            }
            this.helper = null;
            this.cancelHelperRemoval = false;
        },
        _trigger: function(type, event, ui) {
            ui = ui || this._uiHash();
            $.ui.plugin.call(this, type, [ event, ui ]);
            if (type === "drag") {
                this.positionAbs = this._convertPositionTo("absolute");
            }
            return $.Widget.prototype._trigger.call(this, type, event, ui);
        },
        plugins: {},
        _uiHash: function() {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            };
        }
    });
    $.ui.plugin.add("draggable", "connectToSortable", {
        start: function(event, ui) {
            var inst = $(this).data("ui-draggable"), o = inst.options, uiSortable = $.extend({}, ui, {
                item: inst.element
            });
            inst.sortables = [];
            $(o.connectToSortable).each(function() {
                var sortable = $.data(this, "ui-sortable");
                if (sortable && !sortable.options.disabled) {
                    inst.sortables.push({
                        instance: sortable,
                        shouldRevert: sortable.options.revert
                    });
                    sortable.refreshPositions();
                    sortable._trigger("activate", event, uiSortable);
                }
            });
        },
        stop: function(event, ui) {
            var inst = $(this).data("ui-draggable"), uiSortable = $.extend({}, ui, {
                item: inst.element
            });
            $.each(inst.sortables, function() {
                if (this.instance.isOver) {
                    this.instance.isOver = 0;
                    inst.cancelHelperRemoval = true;
                    this.instance.cancelHelperRemoval = false;
                    if (this.shouldRevert) {
                        this.instance.options.revert = this.shouldRevert;
                    }
                    this.instance._mouseStop(event);
                    this.instance.options.helper = this.instance.options._helper;
                    if (inst.options.helper === "original") {
                        this.instance.currentItem.css({
                            top: "auto",
                            left: "auto"
                        });
                    }
                } else {
                    this.instance.cancelHelperRemoval = false;
                    this.instance._trigger("deactivate", event, uiSortable);
                }
            });
        },
        drag: function(event, ui) {
            var inst = $(this).data("ui-draggable"), that = this;
            $.each(inst.sortables, function() {
                var innermostIntersecting = false, thisSortable = this;
                this.instance.positionAbs = inst.positionAbs;
                this.instance.helperProportions = inst.helperProportions;
                this.instance.offset.click = inst.offset.click;
                if (this.instance._intersectsWith(this.instance.containerCache)) {
                    innermostIntersecting = true;
                    $.each(inst.sortables, function() {
                        this.instance.positionAbs = inst.positionAbs;
                        this.instance.helperProportions = inst.helperProportions;
                        this.instance.offset.click = inst.offset.click;
                        if (this !== thisSortable && this.instance._intersectsWith(this.instance.containerCache) && $.contains(thisSortable.instance.element[0], this.instance.element[0])) {
                            innermostIntersecting = false;
                        }
                        return innermostIntersecting;
                    });
                }
                if (innermostIntersecting) {
                    if (!this.instance.isOver) {
                        this.instance.isOver = 1;
                        this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
                        this.instance.options._helper = this.instance.options.helper;
                        this.instance.options.helper = function() {
                            return ui.helper[0];
                        };
                        event.target = this.instance.currentItem[0];
                        this.instance._mouseCapture(event, true);
                        this.instance._mouseStart(event, true, true);
                        this.instance.offset.click.top = inst.offset.click.top;
                        this.instance.offset.click.left = inst.offset.click.left;
                        this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
                        this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;
                        inst._trigger("toSortable", event);
                        inst.dropped = this.instance.element;
                        inst.currentItem = inst.element;
                        this.instance.fromOutside = inst;
                    }
                    if (this.instance.currentItem) {
                        this.instance._mouseDrag(event);
                    }
                } else {
                    if (this.instance.isOver) {
                        this.instance.isOver = 0;
                        this.instance.cancelHelperRemoval = true;
                        this.instance.options.revert = false;
                        this.instance._trigger("out", event, this.instance._uiHash(this.instance));
                        this.instance._mouseStop(event, true);
                        this.instance.options.helper = this.instance.options._helper;
                        this.instance.currentItem.remove();
                        if (this.instance.placeholder) {
                            this.instance.placeholder.remove();
                        }
                        inst._trigger("fromSortable", event);
                        inst.dropped = false;
                    }
                }
            });
        }
    });
    $.ui.plugin.add("draggable", "cursor", {
        start: function() {
            var t = $("body"), o = $(this).data("ui-draggable").options;
            if (t.css("cursor")) {
                o._cursor = t.css("cursor");
            }
            t.css("cursor", o.cursor);
        },
        stop: function() {
            var o = $(this).data("ui-draggable").options;
            if (o._cursor) {
                $("body").css("cursor", o._cursor);
            }
        }
    });
    $.ui.plugin.add("draggable", "opacity", {
        start: function(event, ui) {
            var t = $(ui.helper), o = $(this).data("ui-draggable").options;
            if (t.css("opacity")) {
                o._opacity = t.css("opacity");
            }
            t.css("opacity", o.opacity);
        },
        stop: function(event, ui) {
            var o = $(this).data("ui-draggable").options;
            if (o._opacity) {
                $(ui.helper).css("opacity", o._opacity);
            }
        }
    });
    $.ui.plugin.add("draggable", "scroll", {
        start: function() {
            var i = $(this).data("ui-draggable");
            if (i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
                i.overflowOffset = i.scrollParent.offset();
            }
        },
        drag: function(event) {
            var i = $(this).data("ui-draggable"), o = i.options, scrolled = false;
            if (i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
                if (!o.axis || o.axis !== "x") {
                    if (i.overflowOffset.top + i.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
                        i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
                    } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
                        i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
                    }
                }
                if (!o.axis || o.axis !== "y") {
                    if (i.overflowOffset.left + i.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
                        i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
                    } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
                        i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
                    }
                }
            } else {
                if (!o.axis || o.axis !== "x") {
                    if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                    } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                    }
                }
                if (!o.axis || o.axis !== "y") {
                    if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                    } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                    }
                }
            }
            if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(i, event);
            }
        }
    });
    $.ui.plugin.add("draggable", "snap", {
        start: function() {
            var i = $(this).data("ui-draggable"), o = i.options;
            i.snapElements = [];
            $(o.snap.constructor !== String ? o.snap.items || ":data(ui-draggable)" : o.snap).each(function() {
                var $t = $(this), $o = $t.offset();
                if (this !== i.element[0]) {
                    i.snapElements.push({
                        item: this,
                        width: $t.outerWidth(),
                        height: $t.outerHeight(),
                        top: $o.top,
                        left: $o.left
                    });
                }
            });
        },
        drag: function(event, ui) {
            var ts, bs, ls, rs, l, r, t, b, i, first, inst = $(this).data("ui-draggable"), o = inst.options, d = o.snapTolerance, x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width, y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
            for (i = inst.snapElements.length - 1; i >= 0; i--) {
                l = inst.snapElements[i].left;
                r = l + inst.snapElements[i].width;
                t = inst.snapElements[i].top;
                b = t + inst.snapElements[i].height;
                if (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {
                    if (inst.snapElements[i].snapping) {
                        inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {
                            snapItem: inst.snapElements[i].item
                        }));
                    }
                    inst.snapElements[i].snapping = false;
                    continue;
                }
                if (o.snapMode !== "inner") {
                    ts = Math.abs(t - y2) <= d;
                    bs = Math.abs(b - y1) <= d;
                    ls = Math.abs(l - x2) <= d;
                    rs = Math.abs(r - x1) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: t - inst.helperProportions.height,
                            left: 0
                        }).top - inst.margins.top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: b,
                            left: 0
                        }).top - inst.margins.top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: l - inst.helperProportions.width
                        }).left - inst.margins.left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: r
                        }).left - inst.margins.left;
                    }
                }
                first = ts || bs || ls || rs;
                if (o.snapMode !== "outer") {
                    ts = Math.abs(t - y1) <= d;
                    bs = Math.abs(b - y2) <= d;
                    ls = Math.abs(l - x1) <= d;
                    rs = Math.abs(r - x2) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: t,
                            left: 0
                        }).top - inst.margins.top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: b - inst.helperProportions.height,
                            left: 0
                        }).top - inst.margins.top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: l
                        }).left - inst.margins.left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: r - inst.helperProportions.width
                        }).left - inst.margins.left;
                    }
                }
                if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
                    inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {
                        snapItem: inst.snapElements[i].item
                    }));
                }
                inst.snapElements[i].snapping = ts || bs || ls || rs || first;
            }
        }
    });
    $.ui.plugin.add("draggable", "stack", {
        start: function() {
            var min, o = this.data("ui-draggable").options, group = $.makeArray($(o.stack)).sort(function(a, b) {
                return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
            });
            if (!group.length) {
                return;
            }
            min = parseInt($(group[0]).css("zIndex"), 10) || 0;
            $(group).each(function(i) {
                $(this).css("zIndex", min + i);
            });
            this.css("zIndex", min + group.length);
        }
    });
    $.ui.plugin.add("draggable", "zIndex", {
        start: function(event, ui) {
            var t = $(ui.helper), o = $(this).data("ui-draggable").options;
            if (t.css("zIndex")) {
                o._zIndex = t.css("zIndex");
            }
            t.css("zIndex", o.zIndex);
        },
        stop: function(event, ui) {
            var o = $(this).data("ui-draggable").options;
            if (o._zIndex) {
                $(ui.helper).css("zIndex", o._zIndex);
            }
        }
    });
})(jQuery);

(function($, undefined) {
    function isOverAxis(x, reference, size) {
        return x > reference && x < reference + size;
    }
    $.widget("ui.droppable", {
        version: "1.10.3",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            activeClass: false,
            addClasses: true,
            greedy: false,
            hoverClass: false,
            scope: "default",
            tolerance: "intersect",
            activate: null,
            deactivate: null,
            drop: null,
            out: null,
            over: null
        },
        _create: function() {
            var o = this.options, accept = o.accept;
            this.isover = false;
            this.isout = true;
            this.accept = $.isFunction(accept) ? accept : function(d) {
                return d.is(accept);
            };
            this.proportions = {
                width: this.element[0].offsetWidth,
                height: this.element[0].offsetHeight
            };
            $.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
            $.ui.ddmanager.droppables[o.scope].push(this);
            o.addClasses && this.element.addClass("ui-droppable");
        },
        _destroy: function() {
            var i = 0, drop = $.ui.ddmanager.droppables[this.options.scope];
            for (;i < drop.length; i++) {
                if (drop[i] === this) {
                    drop.splice(i, 1);
                }
            }
            this.element.removeClass("ui-droppable ui-droppable-disabled");
        },
        _setOption: function(key, value) {
            if (key === "accept") {
                this.accept = $.isFunction(value) ? value : function(d) {
                    return d.is(value);
                };
            }
            $.Widget.prototype._setOption.apply(this, arguments);
        },
        _activate: function(event) {
            var draggable = $.ui.ddmanager.current;
            if (this.options.activeClass) {
                this.element.addClass(this.options.activeClass);
            }
            if (draggable) {
                this._trigger("activate", event, this.ui(draggable));
            }
        },
        _deactivate: function(event) {
            var draggable = $.ui.ddmanager.current;
            if (this.options.activeClass) {
                this.element.removeClass(this.options.activeClass);
            }
            if (draggable) {
                this._trigger("deactivate", event, this.ui(draggable));
            }
        },
        _over: function(event) {
            var draggable = $.ui.ddmanager.current;
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                return;
            }
            if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                if (this.options.hoverClass) {
                    this.element.addClass(this.options.hoverClass);
                }
                this._trigger("over", event, this.ui(draggable));
            }
        },
        _out: function(event) {
            var draggable = $.ui.ddmanager.current;
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                return;
            }
            if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                if (this.options.hoverClass) {
                    this.element.removeClass(this.options.hoverClass);
                }
                this._trigger("out", event, this.ui(draggable));
            }
        },
        _drop: function(event, custom) {
            var draggable = custom || $.ui.ddmanager.current, childrenIntersection = false;
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                return false;
            }
            this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
                var inst = $.data(this, "ui-droppable");
                if (inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], draggable.currentItem || draggable.element) && $.ui.intersect(draggable, $.extend(inst, {
                    offset: inst.element.offset()
                }), inst.options.tolerance)) {
                    childrenIntersection = true;
                    return false;
                }
            });
            if (childrenIntersection) {
                return false;
            }
            if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                if (this.options.activeClass) {
                    this.element.removeClass(this.options.activeClass);
                }
                if (this.options.hoverClass) {
                    this.element.removeClass(this.options.hoverClass);
                }
                this._trigger("drop", event, this.ui(draggable));
                return this.element;
            }
            return false;
        },
        ui: function(c) {
            return {
                draggable: c.currentItem || c.element,
                helper: c.helper,
                position: c.position,
                offset: c.positionAbs
            };
        }
    });
    $.ui.intersect = function(draggable, droppable, toleranceMode) {
        if (!droppable.offset) {
            return false;
        }
        var draggableLeft, draggableTop, x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width, y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height, l = droppable.offset.left, r = l + droppable.proportions.width, t = droppable.offset.top, b = t + droppable.proportions.height;
        switch (toleranceMode) {
          case "fit":
            return l <= x1 && x2 <= r && t <= y1 && y2 <= b;

          case "intersect":
            return l < x1 + draggable.helperProportions.width / 2 && x2 - draggable.helperProportions.width / 2 < r && t < y1 + draggable.helperProportions.height / 2 && y2 - draggable.helperProportions.height / 2 < b;

          case "pointer":
            draggableLeft = (draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left;
            draggableTop = (draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top;
            return isOverAxis(draggableTop, t, droppable.proportions.height) && isOverAxis(draggableLeft, l, droppable.proportions.width);

          case "touch":
            return (y1 >= t && y1 <= b || y2 >= t && y2 <= b || y1 < t && y2 > b) && (x1 >= l && x1 <= r || x2 >= l && x2 <= r || x1 < l && x2 > r);

          default:
            return false;
        }
    };
    $.ui.ddmanager = {
        current: null,
        droppables: {
            "default": []
        },
        prepareOffsets: function(t, event) {
            var i, j, m = $.ui.ddmanager.droppables[t.options.scope] || [], type = event ? event.type : null, list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
            droppablesLoop: for (i = 0; i < m.length; i++) {
                if (m[i].options.disabled || t && !m[i].accept.call(m[i].element[0], t.currentItem || t.element)) {
                    continue;
                }
                for (j = 0; j < list.length; j++) {
                    if (list[j] === m[i].element[0]) {
                        m[i].proportions.height = 0;
                        continue droppablesLoop;
                    }
                }
                m[i].visible = m[i].element.css("display") !== "none";
                if (!m[i].visible) {
                    continue;
                }
                if (type === "mousedown") {
                    m[i]._activate.call(m[i], event);
                }
                m[i].offset = m[i].element.offset();
                m[i].proportions = {
                    width: m[i].element[0].offsetWidth,
                    height: m[i].element[0].offsetHeight
                };
            }
        },
        drop: function(draggable, event) {
            var dropped = false;
            $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {
                if (!this.options) {
                    return;
                }
                if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {
                    dropped = this._drop.call(this, event) || dropped;
                }
                if (!this.options.disabled && this.visible && this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                    this.isout = true;
                    this.isover = false;
                    this._deactivate.call(this, event);
                }
            });
            return dropped;
        },
        dragStart: function(draggable, event) {
            draggable.element.parentsUntil("body").bind("scroll.droppable", function() {
                if (!draggable.options.refreshPositions) {
                    $.ui.ddmanager.prepareOffsets(draggable, event);
                }
            });
        },
        drag: function(draggable, event) {
            if (draggable.options.refreshPositions) {
                $.ui.ddmanager.prepareOffsets(draggable, event);
            }
            $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
                if (this.options.disabled || this.greedyChild || !this.visible) {
                    return;
                }
                var parentInstance, scope, parent, intersects = $.ui.intersect(draggable, this, this.options.tolerance), c = !intersects && this.isover ? "isout" : intersects && !this.isover ? "isover" : null;
                if (!c) {
                    return;
                }
                if (this.options.greedy) {
                    scope = this.options.scope;
                    parent = this.element.parents(":data(ui-droppable)").filter(function() {
                        return $.data(this, "ui-droppable").options.scope === scope;
                    });
                    if (parent.length) {
                        parentInstance = $.data(parent[0], "ui-droppable");
                        parentInstance.greedyChild = c === "isover";
                    }
                }
                if (parentInstance && c === "isover") {
                    parentInstance.isover = false;
                    parentInstance.isout = true;
                    parentInstance._out.call(parentInstance, event);
                }
                this[c] = true;
                this[c === "isout" ? "isover" : "isout"] = false;
                this[c === "isover" ? "_over" : "_out"].call(this, event);
                if (parentInstance && c === "isout") {
                    parentInstance.isout = false;
                    parentInstance.isover = true;
                    parentInstance._over.call(parentInstance, event);
                }
            });
        },
        dragStop: function(draggable, event) {
            draggable.element.parentsUntil("body").unbind("scroll.droppable");
            if (!draggable.options.refreshPositions) {
                $.ui.ddmanager.prepareOffsets(draggable, event);
            }
        }
    };
})(jQuery);

(function($, undefined) {
    function num(v) {
        return parseInt(v, 10) || 0;
    }
    function isNumber(value) {
        return !isNaN(parseInt(value, 10));
    }
    $.widget("ui.resizable", $.ui.mouse, {
        version: "1.10.3",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: false,
            animate: false,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: false,
            autoHide: false,
            containment: false,
            ghost: false,
            grid: false,
            handles: "e,s,se",
            helper: false,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,
            zIndex: 90,
            resize: null,
            start: null,
            stop: null
        },
        _create: function() {
            var n, i, handle, axis, hname, that = this, o = this.options;
            this.element.addClass("ui-resizable");
            $.extend(this, {
                _aspectRatio: !!o.aspectRatio,
                aspectRatio: o.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
            });
            if (this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {
                this.element.wrap($("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                    position: this.element.css("position"),
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight(),
                    top: this.element.css("top"),
                    left: this.element.css("left")
                }));
                this.element = this.element.parent().data("ui-resizable", this.element.data("ui-resizable"));
                this.elementIsWrapper = true;
                this.element.css({
                    marginLeft: this.originalElement.css("marginLeft"),
                    marginTop: this.originalElement.css("marginTop"),
                    marginRight: this.originalElement.css("marginRight"),
                    marginBottom: this.originalElement.css("marginBottom")
                });
                this.originalElement.css({
                    marginLeft: 0,
                    marginTop: 0,
                    marginRight: 0,
                    marginBottom: 0
                });
                this.originalResizeStyle = this.originalElement.css("resize");
                this.originalElement.css("resize", "none");
                this._proportionallyResizeElements.push(this.originalElement.css({
                    position: "static",
                    zoom: 1,
                    display: "block"
                }));
                this.originalElement.css({
                    margin: this.originalElement.css("margin")
                });
                this._proportionallyResize();
            }
            this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : {
                n: ".ui-resizable-n",
                e: ".ui-resizable-e",
                s: ".ui-resizable-s",
                w: ".ui-resizable-w",
                se: ".ui-resizable-se",
                sw: ".ui-resizable-sw",
                ne: ".ui-resizable-ne",
                nw: ".ui-resizable-nw"
            });
            if (this.handles.constructor === String) {
                if (this.handles === "all") {
                    this.handles = "n,e,s,w,se,sw,ne,nw";
                }
                n = this.handles.split(",");
                this.handles = {};
                for (i = 0; i < n.length; i++) {
                    handle = $.trim(n[i]);
                    hname = "ui-resizable-" + handle;
                    axis = $("<div class='ui-resizable-handle " + hname + "'></div>");
                    axis.css({
                        zIndex: o.zIndex
                    });
                    if ("se" === handle) {
                        axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
                    }
                    this.handles[handle] = ".ui-resizable-" + handle;
                    this.element.append(axis);
                }
            }
            this._renderAxis = function(target) {
                var i, axis, padPos, padWrapper;
                target = target || this.element;
                for (i in this.handles) {
                    if (this.handles[i].constructor === String) {
                        this.handles[i] = $(this.handles[i], this.element).show();
                    }
                    if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {
                        axis = $(this.handles[i], this.element);
                        padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
                        padPos = [ "padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left" ].join("");
                        target.css(padPos, padWrapper);
                        this._proportionallyResize();
                    }
                    if (!$(this.handles[i]).length) {
                        continue;
                    }
                }
            };
            this._renderAxis(this.element);
            this._handles = $(".ui-resizable-handle", this.element).disableSelection();
            this._handles.mouseover(function() {
                if (!that.resizing) {
                    if (this.className) {
                        axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
                    }
                    that.axis = axis && axis[1] ? axis[1] : "se";
                }
            });
            if (o.autoHide) {
                this._handles.hide();
                $(this.element).addClass("ui-resizable-autohide").mouseenter(function() {
                    if (o.disabled) {
                        return;
                    }
                    $(this).removeClass("ui-resizable-autohide");
                    that._handles.show();
                }).mouseleave(function() {
                    if (o.disabled) {
                        return;
                    }
                    if (!that.resizing) {
                        $(this).addClass("ui-resizable-autohide");
                        that._handles.hide();
                    }
                });
            }
            this._mouseInit();
        },
        _destroy: function() {
            this._mouseDestroy();
            var wrapper, _destroy = function(exp) {
                $(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
            };
            if (this.elementIsWrapper) {
                _destroy(this.element);
                wrapper = this.element;
                this.originalElement.css({
                    position: wrapper.css("position"),
                    width: wrapper.outerWidth(),
                    height: wrapper.outerHeight(),
                    top: wrapper.css("top"),
                    left: wrapper.css("left")
                }).insertAfter(wrapper);
                wrapper.remove();
            }
            this.originalElement.css("resize", this.originalResizeStyle);
            _destroy(this.originalElement);
            return this;
        },
        _mouseCapture: function(event) {
            var i, handle, capture = false;
            for (i in this.handles) {
                handle = $(this.handles[i])[0];
                if (handle === event.target || $.contains(handle, event.target)) {
                    capture = true;
                }
            }
            return !this.options.disabled && capture;
        },
        _mouseStart: function(event) {
            var curleft, curtop, cursor, o = this.options, iniPos = this.element.position(), el = this.element;
            this.resizing = true;
            if (/absolute/.test(el.css("position"))) {
                el.css({
                    position: "absolute",
                    top: el.css("top"),
                    left: el.css("left")
                });
            } else if (el.is(".ui-draggable")) {
                el.css({
                    position: "absolute",
                    top: iniPos.top,
                    left: iniPos.left
                });
            }
            this._renderProxy();
            curleft = num(this.helper.css("left"));
            curtop = num(this.helper.css("top"));
            if (o.containment) {
                curleft += $(o.containment).scrollLeft() || 0;
                curtop += $(o.containment).scrollTop() || 0;
            }
            this.offset = this.helper.offset();
            this.position = {
                left: curleft,
                top: curtop
            };
            this.size = this._helper ? {
                width: el.outerWidth(),
                height: el.outerHeight()
            } : {
                width: el.width(),
                height: el.height()
            };
            this.originalSize = this._helper ? {
                width: el.outerWidth(),
                height: el.outerHeight()
            } : {
                width: el.width(),
                height: el.height()
            };
            this.originalPosition = {
                left: curleft,
                top: curtop
            };
            this.sizeDiff = {
                width: el.outerWidth() - el.width(),
                height: el.outerHeight() - el.height()
            };
            this.originalMousePosition = {
                left: event.pageX,
                top: event.pageY
            };
            this.aspectRatio = typeof o.aspectRatio === "number" ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1;
            cursor = $(".ui-resizable-" + this.axis).css("cursor");
            $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);
            el.addClass("ui-resizable-resizing");
            this._propagate("start", event);
            return true;
        },
        _mouseDrag: function(event) {
            var data, el = this.helper, props = {}, smp = this.originalMousePosition, a = this.axis, prevTop = this.position.top, prevLeft = this.position.left, prevWidth = this.size.width, prevHeight = this.size.height, dx = event.pageX - smp.left || 0, dy = event.pageY - smp.top || 0, trigger = this._change[a];
            if (!trigger) {
                return false;
            }
            data = trigger.apply(this, [ event, dx, dy ]);
            this._updateVirtualBoundaries(event.shiftKey);
            if (this._aspectRatio || event.shiftKey) {
                data = this._updateRatio(data, event);
            }
            data = this._respectSize(data, event);
            this._updateCache(data);
            this._propagate("resize", event);
            if (this.position.top !== prevTop) {
                props.top = this.position.top + "px";
            }
            if (this.position.left !== prevLeft) {
                props.left = this.position.left + "px";
            }
            if (this.size.width !== prevWidth) {
                props.width = this.size.width + "px";
            }
            if (this.size.height !== prevHeight) {
                props.height = this.size.height + "px";
            }
            el.css(props);
            if (!this._helper && this._proportionallyResizeElements.length) {
                this._proportionallyResize();
            }
            if (!$.isEmptyObject(props)) {
                this._trigger("resize", event, this.ui());
            }
            return false;
        },
        _mouseStop: function(event) {
            this.resizing = false;
            var pr, ista, soffseth, soffsetw, s, left, top, o = this.options, that = this;
            if (this._helper) {
                pr = this._proportionallyResizeElements;
                ista = pr.length && /textarea/i.test(pr[0].nodeName);
                soffseth = ista && $.ui.hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
                soffsetw = ista ? 0 : that.sizeDiff.width;
                s = {
                    width: that.helper.width() - soffsetw,
                    height: that.helper.height() - soffseth
                };
                left = parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left) || null;
                top = parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top) || null;
                if (!o.animate) {
                    this.element.css($.extend(s, {
                        top: top,
                        left: left
                    }));
                }
                that.helper.height(that.size.height);
                that.helper.width(that.size.width);
                if (this._helper && !o.animate) {
                    this._proportionallyResize();
                }
            }
            $("body").css("cursor", "auto");
            this.element.removeClass("ui-resizable-resizing");
            this._propagate("stop", event);
            if (this._helper) {
                this.helper.remove();
            }
            return false;
        },
        _updateVirtualBoundaries: function(forceAspectRatio) {
            var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b, o = this.options;
            b = {
                minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
                maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
                minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
                maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
            };
            if (this._aspectRatio || forceAspectRatio) {
                pMinWidth = b.minHeight * this.aspectRatio;
                pMinHeight = b.minWidth / this.aspectRatio;
                pMaxWidth = b.maxHeight * this.aspectRatio;
                pMaxHeight = b.maxWidth / this.aspectRatio;
                if (pMinWidth > b.minWidth) {
                    b.minWidth = pMinWidth;
                }
                if (pMinHeight > b.minHeight) {
                    b.minHeight = pMinHeight;
                }
                if (pMaxWidth < b.maxWidth) {
                    b.maxWidth = pMaxWidth;
                }
                if (pMaxHeight < b.maxHeight) {
                    b.maxHeight = pMaxHeight;
                }
            }
            this._vBoundaries = b;
        },
        _updateCache: function(data) {
            this.offset = this.helper.offset();
            if (isNumber(data.left)) {
                this.position.left = data.left;
            }
            if (isNumber(data.top)) {
                this.position.top = data.top;
            }
            if (isNumber(data.height)) {
                this.size.height = data.height;
            }
            if (isNumber(data.width)) {
                this.size.width = data.width;
            }
        },
        _updateRatio: function(data) {
            var cpos = this.position, csize = this.size, a = this.axis;
            if (isNumber(data.height)) {
                data.width = data.height * this.aspectRatio;
            } else if (isNumber(data.width)) {
                data.height = data.width / this.aspectRatio;
            }
            if (a === "sw") {
                data.left = cpos.left + (csize.width - data.width);
                data.top = null;
            }
            if (a === "nw") {
                data.top = cpos.top + (csize.height - data.height);
                data.left = cpos.left + (csize.width - data.width);
            }
            return data;
        },
        _respectSize: function(data) {
            var o = this._vBoundaries, a = this.axis, ismaxw = isNumber(data.width) && o.maxWidth && o.maxWidth < data.width, ismaxh = isNumber(data.height) && o.maxHeight && o.maxHeight < data.height, isminw = isNumber(data.width) && o.minWidth && o.minWidth > data.width, isminh = isNumber(data.height) && o.minHeight && o.minHeight > data.height, dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height, cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
            if (isminw) {
                data.width = o.minWidth;
            }
            if (isminh) {
                data.height = o.minHeight;
            }
            if (ismaxw) {
                data.width = o.maxWidth;
            }
            if (ismaxh) {
                data.height = o.maxHeight;
            }
            if (isminw && cw) {
                data.left = dw - o.minWidth;
            }
            if (ismaxw && cw) {
                data.left = dw - o.maxWidth;
            }
            if (isminh && ch) {
                data.top = dh - o.minHeight;
            }
            if (ismaxh && ch) {
                data.top = dh - o.maxHeight;
            }
            if (!data.width && !data.height && !data.left && data.top) {
                data.top = null;
            } else if (!data.width && !data.height && !data.top && data.left) {
                data.left = null;
            }
            return data;
        },
        _proportionallyResize: function() {
            if (!this._proportionallyResizeElements.length) {
                return;
            }
            var i, j, borders, paddings, prel, element = this.helper || this.element;
            for (i = 0; i < this._proportionallyResizeElements.length; i++) {
                prel = this._proportionallyResizeElements[i];
                if (!this.borderDif) {
                    this.borderDif = [];
                    borders = [ prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth") ];
                    paddings = [ prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft") ];
                    for (j = 0; j < borders.length; j++) {
                        this.borderDif[j] = (parseInt(borders[j], 10) || 0) + (parseInt(paddings[j], 10) || 0);
                    }
                }
                prel.css({
                    height: element.height() - this.borderDif[0] - this.borderDif[2] || 0,
                    width: element.width() - this.borderDif[1] - this.borderDif[3] || 0
                });
            }
        },
        _renderProxy: function() {
            var el = this.element, o = this.options;
            this.elementOffset = el.offset();
            if (this._helper) {
                this.helper = this.helper || $("<div style='overflow:hidden;'></div>");
                this.helper.addClass(this._helper).css({
                    width: this.element.outerWidth() - 1,
                    height: this.element.outerHeight() - 1,
                    position: "absolute",
                    left: this.elementOffset.left + "px",
                    top: this.elementOffset.top + "px",
                    zIndex: ++o.zIndex
                });
                this.helper.appendTo("body").disableSelection();
            } else {
                this.helper = this.element;
            }
        },
        _change: {
            e: function(event, dx) {
                return {
                    width: this.originalSize.width + dx
                };
            },
            w: function(event, dx) {
                var cs = this.originalSize, sp = this.originalPosition;
                return {
                    left: sp.left + dx,
                    width: cs.width - dx
                };
            },
            n: function(event, dx, dy) {
                var cs = this.originalSize, sp = this.originalPosition;
                return {
                    top: sp.top + dy,
                    height: cs.height - dy
                };
            },
            s: function(event, dx, dy) {
                return {
                    height: this.originalSize.height + dy
                };
            },
            se: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [ event, dx, dy ]));
            },
            sw: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [ event, dx, dy ]));
            },
            ne: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [ event, dx, dy ]));
            },
            nw: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [ event, dx, dy ]));
            }
        },
        _propagate: function(n, event) {
            $.ui.plugin.call(this, n, [ event, this.ui() ]);
            n !== "resize" && this._trigger(n, event, this.ui());
        },
        plugins: {},
        ui: function() {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            };
        }
    });
    $.ui.plugin.add("resizable", "animate", {
        stop: function(event) {
            var that = $(this).data("ui-resizable"), o = that.options, pr = that._proportionallyResizeElements, ista = pr.length && /textarea/i.test(pr[0].nodeName), soffseth = ista && $.ui.hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height, soffsetw = ista ? 0 : that.sizeDiff.width, style = {
                width: that.size.width - soffsetw,
                height: that.size.height - soffseth
            }, left = parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left) || null, top = parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top) || null;
            that.element.animate($.extend(style, top && left ? {
                top: top,
                left: left
            } : {}), {
                duration: o.animateDuration,
                easing: o.animateEasing,
                step: function() {
                    var data = {
                        width: parseInt(that.element.css("width"), 10),
                        height: parseInt(that.element.css("height"), 10),
                        top: parseInt(that.element.css("top"), 10),
                        left: parseInt(that.element.css("left"), 10)
                    };
                    if (pr && pr.length) {
                        $(pr[0]).css({
                            width: data.width,
                            height: data.height
                        });
                    }
                    that._updateCache(data);
                    that._propagate("resize", event);
                }
            });
        }
    });
    $.ui.plugin.add("resizable", "containment", {
        start: function() {
            var element, p, co, ch, cw, width, height, that = $(this).data("ui-resizable"), o = that.options, el = that.element, oc = o.containment, ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;
            if (!ce) {
                return;
            }
            that.containerElement = $(ce);
            if (/document/.test(oc) || oc === document) {
                that.containerOffset = {
                    left: 0,
                    top: 0
                };
                that.containerPosition = {
                    left: 0,
                    top: 0
                };
                that.parentData = {
                    element: $(document),
                    left: 0,
                    top: 0,
                    width: $(document).width(),
                    height: $(document).height() || document.body.parentNode.scrollHeight
                };
            } else {
                element = $(ce);
                p = [];
                $([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) {
                    p[i] = num(element.css("padding" + name));
                });
                that.containerOffset = element.offset();
                that.containerPosition = element.position();
                that.containerSize = {
                    height: element.innerHeight() - p[3],
                    width: element.innerWidth() - p[1]
                };
                co = that.containerOffset;
                ch = that.containerSize.height;
                cw = that.containerSize.width;
                width = $.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw;
                height = $.ui.hasScroll(ce) ? ce.scrollHeight : ch;
                that.parentData = {
                    element: ce,
                    left: co.left,
                    top: co.top,
                    width: width,
                    height: height
                };
            }
        },
        resize: function(event) {
            var woset, hoset, isParent, isOffsetRelative, that = $(this).data("ui-resizable"), o = that.options, co = that.containerOffset, cp = that.position, pRatio = that._aspectRatio || event.shiftKey, cop = {
                top: 0,
                left: 0
            }, ce = that.containerElement;
            if (ce[0] !== document && /static/.test(ce.css("position"))) {
                cop = co;
            }
            if (cp.left < (that._helper ? co.left : 0)) {
                that.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left);
                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                }
                that.position.left = o.helper ? co.left : 0;
            }
            if (cp.top < (that._helper ? co.top : 0)) {
                that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top);
                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                }
                that.position.top = that._helper ? co.top : 0;
            }
            that.offset.left = that.parentData.left + that.position.left;
            that.offset.top = that.parentData.top + that.position.top;
            woset = Math.abs((that._helper ? that.offset.left - cop.left : that.offset.left - cop.left) + that.sizeDiff.width);
            hoset = Math.abs((that._helper ? that.offset.top - cop.top : that.offset.top - co.top) + that.sizeDiff.height);
            isParent = that.containerElement.get(0) === that.element.parent().get(0);
            isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));
            if (isParent && isOffsetRelative) {
                woset -= that.parentData.left;
            }
            if (woset + that.size.width >= that.parentData.width) {
                that.size.width = that.parentData.width - woset;
                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                }
            }
            if (hoset + that.size.height >= that.parentData.height) {
                that.size.height = that.parentData.height - hoset;
                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                }
            }
        },
        stop: function() {
            var that = $(this).data("ui-resizable"), o = that.options, co = that.containerOffset, cop = that.containerPosition, ce = that.containerElement, helper = $(that.helper), ho = helper.offset(), w = helper.outerWidth() - that.sizeDiff.width, h = helper.outerHeight() - that.sizeDiff.height;
            if (that._helper && !o.animate && /relative/.test(ce.css("position"))) {
                $(this).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                });
            }
            if (that._helper && !o.animate && /static/.test(ce.css("position"))) {
                $(this).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                });
            }
        }
    });
    $.ui.plugin.add("resizable", "alsoResize", {
        start: function() {
            var that = $(this).data("ui-resizable"), o = that.options, _store = function(exp) {
                $(exp).each(function() {
                    var el = $(this);
                    el.data("ui-resizable-alsoresize", {
                        width: parseInt(el.width(), 10),
                        height: parseInt(el.height(), 10),
                        left: parseInt(el.css("left"), 10),
                        top: parseInt(el.css("top"), 10)
                    });
                });
            };
            if (typeof o.alsoResize === "object" && !o.alsoResize.parentNode) {
                if (o.alsoResize.length) {
                    o.alsoResize = o.alsoResize[0];
                    _store(o.alsoResize);
                } else {
                    $.each(o.alsoResize, function(exp) {
                        _store(exp);
                    });
                }
            } else {
                _store(o.alsoResize);
            }
        },
        resize: function(event, ui) {
            var that = $(this).data("ui-resizable"), o = that.options, os = that.originalSize, op = that.originalPosition, delta = {
                height: that.size.height - os.height || 0,
                width: that.size.width - os.width || 0,
                top: that.position.top - op.top || 0,
                left: that.position.left - op.left || 0
            }, _alsoResize = function(exp, c) {
                $(exp).each(function() {
                    var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {}, css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? [ "width", "height" ] : [ "width", "height", "top", "left" ];
                    $.each(css, function(i, prop) {
                        var sum = (start[prop] || 0) + (delta[prop] || 0);
                        if (sum && sum >= 0) {
                            style[prop] = sum || null;
                        }
                    });
                    el.css(style);
                });
            };
            if (typeof o.alsoResize === "object" && !o.alsoResize.nodeType) {
                $.each(o.alsoResize, function(exp, c) {
                    _alsoResize(exp, c);
                });
            } else {
                _alsoResize(o.alsoResize);
            }
        },
        stop: function() {
            $(this).removeData("resizable-alsoresize");
        }
    });
    $.ui.plugin.add("resizable", "ghost", {
        start: function() {
            var that = $(this).data("ui-resizable"), o = that.options, cs = that.size;
            that.ghost = that.originalElement.clone();
            that.ghost.css({
                opacity: .25,
                display: "block",
                position: "relative",
                height: cs.height,
                width: cs.width,
                margin: 0,
                left: 0,
                top: 0
            }).addClass("ui-resizable-ghost").addClass(typeof o.ghost === "string" ? o.ghost : "");
            that.ghost.appendTo(that.helper);
        },
        resize: function() {
            var that = $(this).data("ui-resizable");
            if (that.ghost) {
                that.ghost.css({
                    position: "relative",
                    height: that.size.height,
                    width: that.size.width
                });
            }
        },
        stop: function() {
            var that = $(this).data("ui-resizable");
            if (that.ghost && that.helper) {
                that.helper.get(0).removeChild(that.ghost.get(0));
            }
        }
    });
    $.ui.plugin.add("resizable", "grid", {
        resize: function() {
            var that = $(this).data("ui-resizable"), o = that.options, cs = that.size, os = that.originalSize, op = that.originalPosition, a = that.axis, grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid, gridX = grid[0] || 1, gridY = grid[1] || 1, ox = Math.round((cs.width - os.width) / gridX) * gridX, oy = Math.round((cs.height - os.height) / gridY) * gridY, newWidth = os.width + ox, newHeight = os.height + oy, isMaxWidth = o.maxWidth && o.maxWidth < newWidth, isMaxHeight = o.maxHeight && o.maxHeight < newHeight, isMinWidth = o.minWidth && o.minWidth > newWidth, isMinHeight = o.minHeight && o.minHeight > newHeight;
            o.grid = grid;
            if (isMinWidth) {
                newWidth = newWidth + gridX;
            }
            if (isMinHeight) {
                newHeight = newHeight + gridY;
            }
            if (isMaxWidth) {
                newWidth = newWidth - gridX;
            }
            if (isMaxHeight) {
                newHeight = newHeight - gridY;
            }
            if (/^(se|s|e)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
            } else if (/^(ne)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.top = op.top - oy;
            } else if (/^(sw)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.left = op.left - ox;
            } else {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.top = op.top - oy;
                that.position.left = op.left - ox;
            }
        }
    });
})(jQuery);

(function($, undefined) {
    $.widget("ui.selectable", $.ui.mouse, {
        version: "1.10.3",
        options: {
            appendTo: "body",
            autoRefresh: true,
            distance: 0,
            filter: "*",
            tolerance: "touch",
            selected: null,
            selecting: null,
            start: null,
            stop: null,
            unselected: null,
            unselecting: null
        },
        _create: function() {
            var selectees, that = this;
            this.element.addClass("ui-selectable");
            this.dragged = false;
            this.refresh = function() {
                selectees = $(that.options.filter, that.element[0]);
                selectees.addClass("ui-selectee");
                selectees.each(function() {
                    var $this = $(this), pos = $this.offset();
                    $.data(this, "selectable-item", {
                        element: this,
                        $element: $this,
                        left: pos.left,
                        top: pos.top,
                        right: pos.left + $this.outerWidth(),
                        bottom: pos.top + $this.outerHeight(),
                        startselected: false,
                        selected: $this.hasClass("ui-selected"),
                        selecting: $this.hasClass("ui-selecting"),
                        unselecting: $this.hasClass("ui-unselecting")
                    });
                });
            };
            this.refresh();
            this.selectees = selectees.addClass("ui-selectee");
            this._mouseInit();
            this.helper = $("<div class='ui-selectable-helper'></div>");
        },
        _destroy: function() {
            this.selectees.removeClass("ui-selectee").removeData("selectable-item");
            this.element.removeClass("ui-selectable ui-selectable-disabled");
            this._mouseDestroy();
        },
        _mouseStart: function(event) {
            var that = this, options = this.options;
            this.opos = [ event.pageX, event.pageY ];
            if (this.options.disabled) {
                return;
            }
            this.selectees = $(options.filter, this.element[0]);
            this._trigger("start", event);
            $(options.appendTo).append(this.helper);
            this.helper.css({
                left: event.pageX,
                top: event.pageY,
                width: 0,
                height: 0
            });
            if (options.autoRefresh) {
                this.refresh();
            }
            this.selectees.filter(".ui-selected").each(function() {
                var selectee = $.data(this, "selectable-item");
                selectee.startselected = true;
                if (!event.metaKey && !event.ctrlKey) {
                    selectee.$element.removeClass("ui-selected");
                    selectee.selected = false;
                    selectee.$element.addClass("ui-unselecting");
                    selectee.unselecting = true;
                    that._trigger("unselecting", event, {
                        unselecting: selectee.element
                    });
                }
            });
            $(event.target).parents().addBack().each(function() {
                var doSelect, selectee = $.data(this, "selectable-item");
                if (selectee) {
                    doSelect = !event.metaKey && !event.ctrlKey || !selectee.$element.hasClass("ui-selected");
                    selectee.$element.removeClass(doSelect ? "ui-unselecting" : "ui-selected").addClass(doSelect ? "ui-selecting" : "ui-unselecting");
                    selectee.unselecting = !doSelect;
                    selectee.selecting = doSelect;
                    selectee.selected = doSelect;
                    if (doSelect) {
                        that._trigger("selecting", event, {
                            selecting: selectee.element
                        });
                    } else {
                        that._trigger("unselecting", event, {
                            unselecting: selectee.element
                        });
                    }
                    return false;
                }
            });
        },
        _mouseDrag: function(event) {
            this.dragged = true;
            if (this.options.disabled) {
                return;
            }
            var tmp, that = this, options = this.options, x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
            if (x1 > x2) {
                tmp = x2;
                x2 = x1;
                x1 = tmp;
            }
            if (y1 > y2) {
                tmp = y2;
                y2 = y1;
                y1 = tmp;
            }
            this.helper.css({
                left: x1,
                top: y1,
                width: x2 - x1,
                height: y2 - y1
            });
            this.selectees.each(function() {
                var selectee = $.data(this, "selectable-item"), hit = false;
                if (!selectee || selectee.element === that.element[0]) {
                    return;
                }
                if (options.tolerance === "touch") {
                    hit = !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1);
                } else if (options.tolerance === "fit") {
                    hit = selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2;
                }
                if (hit) {
                    if (selectee.selected) {
                        selectee.$element.removeClass("ui-selected");
                        selectee.selected = false;
                    }
                    if (selectee.unselecting) {
                        selectee.$element.removeClass("ui-unselecting");
                        selectee.unselecting = false;
                    }
                    if (!selectee.selecting) {
                        selectee.$element.addClass("ui-selecting");
                        selectee.selecting = true;
                        that._trigger("selecting", event, {
                            selecting: selectee.element
                        });
                    }
                } else {
                    if (selectee.selecting) {
                        if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
                            selectee.$element.removeClass("ui-selecting");
                            selectee.selecting = false;
                            selectee.$element.addClass("ui-selected");
                            selectee.selected = true;
                        } else {
                            selectee.$element.removeClass("ui-selecting");
                            selectee.selecting = false;
                            if (selectee.startselected) {
                                selectee.$element.addClass("ui-unselecting");
                                selectee.unselecting = true;
                            }
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                    }
                    if (selectee.selected) {
                        if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
                            selectee.$element.removeClass("ui-selected");
                            selectee.selected = false;
                            selectee.$element.addClass("ui-unselecting");
                            selectee.unselecting = true;
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                    }
                }
            });
            return false;
        },
        _mouseStop: function(event) {
            var that = this;
            this.dragged = false;
            $(".ui-unselecting", this.element[0]).each(function() {
                var selectee = $.data(this, "selectable-item");
                selectee.$element.removeClass("ui-unselecting");
                selectee.unselecting = false;
                selectee.startselected = false;
                that._trigger("unselected", event, {
                    unselected: selectee.element
                });
            });
            $(".ui-selecting", this.element[0]).each(function() {
                var selectee = $.data(this, "selectable-item");
                selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
                selectee.selecting = false;
                selectee.selected = true;
                selectee.startselected = true;
                that._trigger("selected", event, {
                    selected: selectee.element
                });
            });
            this._trigger("stop", event);
            this.helper.remove();
            return false;
        }
    });
})(jQuery);

(function($, undefined) {
    function isOverAxis(x, reference, size) {
        return x > reference && x < reference + size;
    }
    function isFloating(item) {
        return /left|right/.test(item.css("float")) || /inline|table-cell/.test(item.css("display"));
    }
    $.widget("ui.sortable", $.ui.mouse, {
        version: "1.10.3",
        widgetEventPrefix: "sort",
        ready: false,
        options: {
            appendTo: "parent",
            axis: false,
            connectWith: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            dropOnEmpty: true,
            forcePlaceholderSize: false,
            forceHelperSize: false,
            grid: false,
            handle: false,
            helper: "original",
            items: "> *",
            opacity: false,
            placeholder: false,
            revert: false,
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1e3,
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null
        },
        _create: function() {
            var o = this.options;
            this.containerCache = {};
            this.element.addClass("ui-sortable");
            this.refresh();
            this.floating = this.items.length ? o.axis === "x" || isFloating(this.items[0].item) : false;
            this.offset = this.element.offset();
            this._mouseInit();
            this.ready = true;
        },
        _destroy: function() {
            this.element.removeClass("ui-sortable ui-sortable-disabled");
            this._mouseDestroy();
            for (var i = this.items.length - 1; i >= 0; i--) {
                this.items[i].item.removeData(this.widgetName + "-item");
            }
            return this;
        },
        _setOption: function(key, value) {
            if (key === "disabled") {
                this.options[key] = value;
                this.widget().toggleClass("ui-sortable-disabled", !!value);
            } else {
                $.Widget.prototype._setOption.apply(this, arguments);
            }
        },
        _mouseCapture: function(event, overrideHandle) {
            var currentItem = null, validHandle = false, that = this;
            if (this.reverting) {
                return false;
            }
            if (this.options.disabled || this.options.type === "static") {
                return false;
            }
            this._refreshItems(event);
            $(event.target).parents().each(function() {
                if ($.data(this, that.widgetName + "-item") === that) {
                    currentItem = $(this);
                    return false;
                }
            });
            if ($.data(event.target, that.widgetName + "-item") === that) {
                currentItem = $(event.target);
            }
            if (!currentItem) {
                return false;
            }
            if (this.options.handle && !overrideHandle) {
                $(this.options.handle, currentItem).find("*").addBack().each(function() {
                    if (this === event.target) {
                        validHandle = true;
                    }
                });
                if (!validHandle) {
                    return false;
                }
            }
            this.currentItem = currentItem;
            this._removeCurrentsFromItems();
            return true;
        },
        _mouseStart: function(event, overrideHandle, noActivation) {
            var i, body, o = this.options;
            this.currentContainer = this;
            this.refreshPositions();
            this.helper = this._createHelper(event);
            this._cacheHelperProportions();
            this._cacheMargins();
            this.scrollParent = this.helper.scrollParent();
            this.offset = this.currentItem.offset();
            this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            };
            $.extend(this.offset, {
                click: {
                    left: event.pageX - this.offset.left,
                    top: event.pageY - this.offset.top
                },
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            });
            this.helper.css("position", "absolute");
            this.cssPosition = this.helper.css("position");
            this.originalPosition = this._generatePosition(event);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;
            o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
            this.domPosition = {
                prev: this.currentItem.prev()[0],
                parent: this.currentItem.parent()[0]
            };
            if (this.helper[0] !== this.currentItem[0]) {
                this.currentItem.hide();
            }
            this._createPlaceholder();
            if (o.containment) {
                this._setContainment();
            }
            if (o.cursor && o.cursor !== "auto") {
                body = this.document.find("body");
                this.storedCursor = body.css("cursor");
                body.css("cursor", o.cursor);
                this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body);
            }
            if (o.opacity) {
                if (this.helper.css("opacity")) {
                    this._storedOpacity = this.helper.css("opacity");
                }
                this.helper.css("opacity", o.opacity);
            }
            if (o.zIndex) {
                if (this.helper.css("zIndex")) {
                    this._storedZIndex = this.helper.css("zIndex");
                }
                this.helper.css("zIndex", o.zIndex);
            }
            if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
                this.overflowOffset = this.scrollParent.offset();
            }
            this._trigger("start", event, this._uiHash());
            if (!this._preserveHelperProportions) {
                this._cacheHelperProportions();
            }
            if (!noActivation) {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger("activate", event, this._uiHash(this));
                }
            }
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }
            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }
            this.dragging = true;
            this.helper.addClass("ui-sortable-helper");
            this._mouseDrag(event);
            return true;
        },
        _mouseDrag: function(event) {
            var i, item, itemElement, intersection, o = this.options, scrolled = false;
            this.position = this._generatePosition(event);
            this.positionAbs = this._convertPositionTo("absolute");
            if (!this.lastPositionAbs) {
                this.lastPositionAbs = this.positionAbs;
            }
            if (this.options.scroll) {
                if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
                    if (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
                    } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
                    }
                    if (this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
                    } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
                    }
                } else {
                    if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                    } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                    }
                    if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                    } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                    }
                }
                if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(this, event);
                }
            }
            this.positionAbs = this._convertPositionTo("absolute");
            if (!this.options.axis || this.options.axis !== "y") {
                this.helper[0].style.left = this.position.left + "px";
            }
            if (!this.options.axis || this.options.axis !== "x") {
                this.helper[0].style.top = this.position.top + "px";
            }
            for (i = this.items.length - 1; i >= 0; i--) {
                item = this.items[i];
                itemElement = item.item[0];
                intersection = this._intersectsWithPointer(item);
                if (!intersection) {
                    continue;
                }
                if (item.instance !== this.currentContainer) {
                    continue;
                }
                if (itemElement !== this.currentItem[0] && this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)) {
                    this.direction = intersection === 1 ? "down" : "up";
                    if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
                        this._rearrange(event, item);
                    } else {
                        break;
                    }
                    this._trigger("change", event, this._uiHash());
                    break;
                }
            }
            this._contactContainers(event);
            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }
            this._trigger("sort", event, this._uiHash());
            this.lastPositionAbs = this.positionAbs;
            return false;
        },
        _mouseStop: function(event, noPropagation) {
            if (!event) {
                return;
            }
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                $.ui.ddmanager.drop(this, event);
            }
            if (this.options.revert) {
                var that = this, cur = this.placeholder.offset(), axis = this.options.axis, animation = {};
                if (!axis || axis === "x") {
                    animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
                }
                if (!axis || axis === "y") {
                    animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
                }
                this.reverting = true;
                $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function() {
                    that._clear(event);
                });
            } else {
                this._clear(event, noPropagation);
            }
            return false;
        },
        cancel: function() {
            if (this.dragging) {
                this._mouseUp({
                    target: null
                });
                if (this.options.helper === "original") {
                    this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
                } else {
                    this.currentItem.show();
                }
                for (var i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger("deactivate", null, this._uiHash(this));
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger("out", null, this._uiHash(this));
                        this.containers[i].containerCache.over = 0;
                    }
                }
            }
            if (this.placeholder) {
                if (this.placeholder[0].parentNode) {
                    this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                }
                if (this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
                    this.helper.remove();
                }
                $.extend(this, {
                    helper: null,
                    dragging: false,
                    reverting: false,
                    _noFinalSort: null
                });
                if (this.domPosition.prev) {
                    $(this.domPosition.prev).after(this.currentItem);
                } else {
                    $(this.domPosition.parent).prepend(this.currentItem);
                }
            }
            return this;
        },
        serialize: function(o) {
            var items = this._getItemsAsjQuery(o && o.connected), str = [];
            o = o || {};
            $(items).each(function() {
                var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || /(.+)[\-=_](.+)/);
                if (res) {
                    str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]));
                }
            });
            if (!str.length && o.key) {
                str.push(o.key + "=");
            }
            return str.join("&");
        },
        toArray: function(o) {
            var items = this._getItemsAsjQuery(o && o.connected), ret = [];
            o = o || {};
            items.each(function() {
                ret.push($(o.item || this).attr(o.attribute || "id") || "");
            });
            return ret;
        },
        _intersectsWith: function(item) {
            var x1 = this.positionAbs.left, x2 = x1 + this.helperProportions.width, y1 = this.positionAbs.top, y2 = y1 + this.helperProportions.height, l = item.left, r = l + item.width, t = item.top, b = t + item.height, dyClick = this.offset.click.top, dxClick = this.offset.click.left, isOverElementHeight = this.options.axis === "x" || y1 + dyClick > t && y1 + dyClick < b, isOverElementWidth = this.options.axis === "y" || x1 + dxClick > l && x1 + dxClick < r, isOverElement = isOverElementHeight && isOverElementWidth;
            if (this.options.tolerance === "pointer" || this.options.forcePointerForContainers || this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"]) {
                return isOverElement;
            } else {
                return l < x1 + this.helperProportions.width / 2 && x2 - this.helperProportions.width / 2 < r && t < y1 + this.helperProportions.height / 2 && y2 - this.helperProportions.height / 2 < b;
            }
        },
        _intersectsWithPointer: function(item) {
            var isOverElementHeight = this.options.axis === "x" || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height), isOverElementWidth = this.options.axis === "y" || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width), isOverElement = isOverElementHeight && isOverElementWidth, verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
            if (!isOverElement) {
                return false;
            }
            return this.floating ? horizontalDirection && horizontalDirection === "right" || verticalDirection === "down" ? 2 : 1 : verticalDirection && (verticalDirection === "down" ? 2 : 1);
        },
        _intersectsWithSides: function(item) {
            var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height), isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width), verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
            if (this.floating && horizontalDirection) {
                return horizontalDirection === "right" && isOverRightHalf || horizontalDirection === "left" && !isOverRightHalf;
            } else {
                return verticalDirection && (verticalDirection === "down" && isOverBottomHalf || verticalDirection === "up" && !isOverBottomHalf);
            }
        },
        _getDragVerticalDirection: function() {
            var delta = this.positionAbs.top - this.lastPositionAbs.top;
            return delta !== 0 && (delta > 0 ? "down" : "up");
        },
        _getDragHorizontalDirection: function() {
            var delta = this.positionAbs.left - this.lastPositionAbs.left;
            return delta !== 0 && (delta > 0 ? "right" : "left");
        },
        refresh: function(event) {
            this._refreshItems(event);
            this.refreshPositions();
            return this;
        },
        _connectWith: function() {
            var options = this.options;
            return options.connectWith.constructor === String ? [ options.connectWith ] : options.connectWith;
        },
        _getItemsAsjQuery: function(connected) {
            var i, j, cur, inst, items = [], queries = [], connectWith = this._connectWith();
            if (connectWith && connected) {
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([ $.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst ]);
                        }
                    }
                }
            }
            queries.push([ $.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
                options: this.options,
                item: this.currentItem
            }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this ]);
            for (i = queries.length - 1; i >= 0; i--) {
                queries[i][0].each(function() {
                    items.push(this);
                });
            }
            return $(items);
        },
        _removeCurrentsFromItems: function() {
            var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
            this.items = $.grep(this.items, function(item) {
                for (var j = 0; j < list.length; j++) {
                    if (list[j] === item.item[0]) {
                        return false;
                    }
                }
                return true;
            });
        },
        _refreshItems: function(event) {
            this.items = [];
            this.containers = [ this ];
            var i, j, cur, inst, targetData, _queries, item, queriesLength, items = this.items, queries = [ [ $.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, {
                item: this.currentItem
            }) : $(this.options.items, this.element), this ] ], connectWith = this._connectWith();
            if (connectWith && this.ready) {
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([ $.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, {
                                item: this.currentItem
                            }) : $(inst.options.items, inst.element), inst ]);
                            this.containers.push(inst);
                        }
                    }
                }
            }
            for (i = queries.length - 1; i >= 0; i--) {
                targetData = queries[i][1];
                _queries = queries[i][0];
                for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
                    item = $(_queries[j]);
                    item.data(this.widgetName + "-item", targetData);
                    items.push({
                        item: item,
                        instance: targetData,
                        width: 0,
                        height: 0,
                        left: 0,
                        top: 0
                    });
                }
            }
        },
        refreshPositions: function(fast) {
            if (this.offsetParent && this.helper) {
                this.offset.parent = this._getParentOffset();
            }
            var i, item, t, p;
            for (i = this.items.length - 1; i >= 0; i--) {
                item = this.items[i];
                if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
                    continue;
                }
                t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
                if (!fast) {
                    item.width = t.outerWidth();
                    item.height = t.outerHeight();
                }
                p = t.offset();
                item.left = p.left;
                item.top = p.top;
            }
            if (this.options.custom && this.options.custom.refreshContainers) {
                this.options.custom.refreshContainers.call(this);
            } else {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    p = this.containers[i].element.offset();
                    this.containers[i].containerCache.left = p.left;
                    this.containers[i].containerCache.top = p.top;
                    this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
                    this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
                }
            }
            return this;
        },
        _createPlaceholder: function(that) {
            that = that || this;
            var className, o = that.options;
            if (!o.placeholder || o.placeholder.constructor === String) {
                className = o.placeholder;
                o.placeholder = {
                    element: function() {
                        var nodeName = that.currentItem[0].nodeName.toLowerCase(), element = $("<" + nodeName + ">", that.document[0]).addClass(className || that.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper");
                        if (nodeName === "tr") {
                            that.currentItem.children().each(function() {
                                $("<td>&#160;</td>", that.document[0]).attr("colspan", $(this).attr("colspan") || 1).appendTo(element);
                            });
                        } else if (nodeName === "img") {
                            element.attr("src", that.currentItem.attr("src"));
                        }
                        if (!className) {
                            element.css("visibility", "hidden");
                        }
                        return element;
                    },
                    update: function(container, p) {
                        if (className && !o.forcePlaceholderSize) {
                            return;
                        }
                        if (!p.height()) {
                            p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10));
                        }
                        if (!p.width()) {
                            p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10));
                        }
                    }
                };
            }
            that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
            that.currentItem.after(that.placeholder);
            o.placeholder.update(that, that.placeholder);
        },
        _contactContainers: function(event) {
            var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating, innermostContainer = null, innermostIndex = null;
            for (i = this.containers.length - 1; i >= 0; i--) {
                if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
                    continue;
                }
                if (this._intersectsWith(this.containers[i].containerCache)) {
                    if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
                        continue;
                    }
                    innermostContainer = this.containers[i];
                    innermostIndex = i;
                } else {
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger("out", event, this._uiHash(this));
                        this.containers[i].containerCache.over = 0;
                    }
                }
            }
            if (!innermostContainer) {
                return;
            }
            if (this.containers.length === 1) {
                if (!this.containers[innermostIndex].containerCache.over) {
                    this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                    this.containers[innermostIndex].containerCache.over = 1;
                }
            } else {
                dist = 1e4;
                itemWithLeastDistance = null;
                floating = innermostContainer.floating || isFloating(this.currentItem);
                posProperty = floating ? "left" : "top";
                sizeProperty = floating ? "width" : "height";
                base = this.positionAbs[posProperty] + this.offset.click[posProperty];
                for (j = this.items.length - 1; j >= 0; j--) {
                    if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
                        continue;
                    }
                    if (this.items[j].item[0] === this.currentItem[0]) {
                        continue;
                    }
                    if (floating && !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) {
                        continue;
                    }
                    cur = this.items[j].item.offset()[posProperty];
                    nearBottom = false;
                    if (Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)) {
                        nearBottom = true;
                        cur += this.items[j][sizeProperty];
                    }
                    if (Math.abs(cur - base) < dist) {
                        dist = Math.abs(cur - base);
                        itemWithLeastDistance = this.items[j];
                        this.direction = nearBottom ? "up" : "down";
                    }
                }
                if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
                    return;
                }
                if (this.currentContainer === this.containers[innermostIndex]) {
                    return;
                }
                itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
                this._trigger("change", event, this._uiHash());
                this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
                this.currentContainer = this.containers[innermostIndex];
                this.options.placeholder.update(this.currentContainer, this.placeholder);
                this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                this.containers[innermostIndex].containerCache.over = 1;
            }
        },
        _createHelper: function(event) {
            var o = this.options, helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [ event, this.currentItem ])) : o.helper === "clone" ? this.currentItem.clone() : this.currentItem;
            if (!helper.parents("body").length) {
                $(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
            }
            if (helper[0] === this.currentItem[0]) {
                this._storedCSS = {
                    width: this.currentItem[0].style.width,
                    height: this.currentItem[0].style.height,
                    position: this.currentItem.css("position"),
                    top: this.currentItem.css("top"),
                    left: this.currentItem.css("left")
                };
            }
            if (!helper[0].style.width || o.forceHelperSize) {
                helper.width(this.currentItem.width());
            }
            if (!helper[0].style.height || o.forceHelperSize) {
                helper.height(this.currentItem.height());
            }
            return helper;
        },
        _adjustOffsetFromHelper: function(obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if ($.isArray(obj)) {
                obj = {
                    left: +obj[0],
                    top: +obj[1] || 0
                };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },
        _getParentOffset: function() {
            this.offsetParent = this.helper.offsetParent();
            var po = this.offsetParent.offset();
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }
            if (this.offsetParent[0] === document.body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie) {
                po = {
                    top: 0,
                    left: 0
                };
            }
            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };
        },
        _getRelativeOffset: function() {
            if (this.cssPosition === "relative") {
                var p = this.currentItem.position();
                return {
                    top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                };
            } else {
                return {
                    top: 0,
                    left: 0
                };
            }
        },
        _cacheMargins: function() {
            this.margins = {
                left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                top: parseInt(this.currentItem.css("marginTop"), 10) || 0
            };
        },
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },
        _setContainment: function() {
            var ce, co, over, o = this.options;
            if (o.containment === "parent") {
                o.containment = this.helper[0].parentNode;
            }
            if (o.containment === "document" || o.containment === "window") {
                this.containment = [ 0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, $(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left, ($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ];
            }
            if (!/^(document|window|parent)$/.test(o.containment)) {
                ce = $(o.containment)[0];
                co = $(o.containment).offset();
                over = $(ce).css("overflow") !== "hidden";
                this.containment = [ co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top ];
            }
        },
        _convertPositionTo: function(d, pos) {
            if (!pos) {
                pos = this.position;
            }
            var mod = d === "absolute" ? 1 : -1, scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
            return {
                top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
                left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
            };
        },
        _generatePosition: function(event) {
            var top, left, o = this.options, pageX = event.pageX, pageY = event.pageY, scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
            if (this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
                this.offset.relative = this._getRelativeOffset();
            }
            if (this.originalPosition) {
                if (this.containment) {
                    if (event.pageX - this.offset.click.left < this.containment[0]) {
                        pageX = this.containment[0] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top < this.containment[1]) {
                        pageY = this.containment[1] + this.offset.click.top;
                    }
                    if (event.pageX - this.offset.click.left > this.containment[2]) {
                        pageX = this.containment[2] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top > this.containment[3]) {
                        pageY = this.containment[3] + this.offset.click.top;
                    }
                }
                if (o.grid) {
                    top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
                    pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
                    left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
                    pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
                }
            }
            return {
                top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
                left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
            };
        },
        _rearrange: function(event, i, a, hardRefresh) {
            a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], this.direction === "down" ? i.item[0] : i.item[0].nextSibling);
            this.counter = this.counter ? ++this.counter : 1;
            var counter = this.counter;
            this._delay(function() {
                if (counter === this.counter) {
                    this.refreshPositions(!hardRefresh);
                }
            });
        },
        _clear: function(event, noPropagation) {
            this.reverting = false;
            var i, delayedTriggers = [];
            if (!this._noFinalSort && this.currentItem.parent().length) {
                this.placeholder.before(this.currentItem);
            }
            this._noFinalSort = null;
            if (this.helper[0] === this.currentItem[0]) {
                for (i in this._storedCSS) {
                    if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
                        this._storedCSS[i] = "";
                    }
                }
                this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
            } else {
                this.currentItem.show();
            }
            if (this.fromOutside && !noPropagation) {
                delayedTriggers.push(function(event) {
                    this._trigger("receive", event, this._uiHash(this.fromOutside));
                });
            }
            if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
                delayedTriggers.push(function(event) {
                    this._trigger("update", event, this._uiHash());
                });
            }
            if (this !== this.currentContainer) {
                if (!noPropagation) {
                    delayedTriggers.push(function(event) {
                        this._trigger("remove", event, this._uiHash());
                    });
                    delayedTriggers.push(function(c) {
                        return function(event) {
                            c._trigger("receive", event, this._uiHash(this));
                        };
                    }.call(this, this.currentContainer));
                    delayedTriggers.push(function(c) {
                        return function(event) {
                            c._trigger("update", event, this._uiHash(this));
                        };
                    }.call(this, this.currentContainer));
                }
            }
            for (i = this.containers.length - 1; i >= 0; i--) {
                if (!noPropagation) {
                    delayedTriggers.push(function(c) {
                        return function(event) {
                            c._trigger("deactivate", event, this._uiHash(this));
                        };
                    }.call(this, this.containers[i]));
                }
                if (this.containers[i].containerCache.over) {
                    delayedTriggers.push(function(c) {
                        return function(event) {
                            c._trigger("out", event, this._uiHash(this));
                        };
                    }.call(this, this.containers[i]));
                    this.containers[i].containerCache.over = 0;
                }
            }
            if (this.storedCursor) {
                this.document.find("body").css("cursor", this.storedCursor);
                this.storedStylesheet.remove();
            }
            if (this._storedOpacity) {
                this.helper.css("opacity", this._storedOpacity);
            }
            if (this._storedZIndex) {
                this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
            }
            this.dragging = false;
            if (this.cancelHelperRemoval) {
                if (!noPropagation) {
                    this._trigger("beforeStop", event, this._uiHash());
                    for (i = 0; i < delayedTriggers.length; i++) {
                        delayedTriggers[i].call(this, event);
                    }
                    this._trigger("stop", event, this._uiHash());
                }
                this.fromOutside = false;
                return false;
            }
            if (!noPropagation) {
                this._trigger("beforeStop", event, this._uiHash());
            }
            this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
            if (this.helper[0] !== this.currentItem[0]) {
                this.helper.remove();
            }
            this.helper = null;
            if (!noPropagation) {
                for (i = 0; i < delayedTriggers.length; i++) {
                    delayedTriggers[i].call(this, event);
                }
                this._trigger("stop", event, this._uiHash());
            }
            this.fromOutside = false;
            return true;
        },
        _trigger: function() {
            if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
                this.cancel();
            }
        },
        _uiHash: function(_inst) {
            var inst = _inst || this;
            return {
                helper: inst.helper,
                placeholder: inst.placeholder || $([]),
                position: inst.position,
                originalPosition: inst.originalPosition,
                offset: inst.positionAbs,
                item: inst.currentItem,
                sender: _inst ? _inst.element : null
            };
        }
    });
})(jQuery);

(function($, undefined) {
    var dataSpace = "ui-effects-";
    $.effects = {
        effect: {}
    };
    (function(jQuery, undefined) {
        var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor", rplusequals = /^([\-+])=\s*(\d+\.?\d*)/, stringParsers = [ {
            re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse: function(execResult) {
                return [ execResult[1], execResult[2], execResult[3], execResult[4] ];
            }
        }, {
            re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse: function(execResult) {
                return [ execResult[1] * 2.55, execResult[2] * 2.55, execResult[3] * 2.55, execResult[4] ];
            }
        }, {
            re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
            parse: function(execResult) {
                return [ parseInt(execResult[1], 16), parseInt(execResult[2], 16), parseInt(execResult[3], 16) ];
            }
        }, {
            re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
            parse: function(execResult) {
                return [ parseInt(execResult[1] + execResult[1], 16), parseInt(execResult[2] + execResult[2], 16), parseInt(execResult[3] + execResult[3], 16) ];
            }
        }, {
            re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            space: "hsla",
            parse: function(execResult) {
                return [ execResult[1], execResult[2] / 100, execResult[3] / 100, execResult[4] ];
            }
        } ], color = jQuery.Color = function(color, green, blue, alpha) {
            return new jQuery.Color.fn.parse(color, green, blue, alpha);
        }, spaces = {
            rgba: {
                props: {
                    red: {
                        idx: 0,
                        type: "byte"
                    },
                    green: {
                        idx: 1,
                        type: "byte"
                    },
                    blue: {
                        idx: 2,
                        type: "byte"
                    }
                }
            },
            hsla: {
                props: {
                    hue: {
                        idx: 0,
                        type: "degrees"
                    },
                    saturation: {
                        idx: 1,
                        type: "percent"
                    },
                    lightness: {
                        idx: 2,
                        type: "percent"
                    }
                }
            }
        }, propTypes = {
            "byte": {
                floor: true,
                max: 255
            },
            percent: {
                max: 1
            },
            degrees: {
                mod: 360,
                floor: true
            }
        }, support = color.support = {}, supportElem = jQuery("<p>")[0], colors, each = jQuery.each;
        supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
        support.rgba = supportElem.style.backgroundColor.indexOf("rgba") > -1;
        each(spaces, function(spaceName, space) {
            space.cache = "_" + spaceName;
            space.props.alpha = {
                idx: 3,
                type: "percent",
                def: 1
            };
        });
        function clamp(value, prop, allowEmpty) {
            var type = propTypes[prop.type] || {};
            if (value == null) {
                return allowEmpty || !prop.def ? null : prop.def;
            }
            value = type.floor ? ~~value : parseFloat(value);
            if (isNaN(value)) {
                return prop.def;
            }
            if (type.mod) {
                return (value + type.mod) % type.mod;
            }
            return 0 > value ? 0 : type.max < value ? type.max : value;
        }
        function stringParse(string) {
            var inst = color(), rgba = inst._rgba = [];
            string = string.toLowerCase();
            each(stringParsers, function(i, parser) {
                var parsed, match = parser.re.exec(string), values = match && parser.parse(match), spaceName = parser.space || "rgba";
                if (values) {
                    parsed = inst[spaceName](values);
                    inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
                    rgba = inst._rgba = parsed._rgba;
                    return false;
                }
            });
            if (rgba.length) {
                if (rgba.join() === "0,0,0,0") {
                    jQuery.extend(rgba, colors.transparent);
                }
                return inst;
            }
            return colors[string];
        }
        color.fn = jQuery.extend(color.prototype, {
            parse: function(red, green, blue, alpha) {
                if (red === undefined) {
                    this._rgba = [ null, null, null, null ];
                    return this;
                }
                if (red.jquery || red.nodeType) {
                    red = jQuery(red).css(green);
                    green = undefined;
                }
                var inst = this, type = jQuery.type(red), rgba = this._rgba = [];
                if (green !== undefined) {
                    red = [ red, green, blue, alpha ];
                    type = "array";
                }
                if (type === "string") {
                    return this.parse(stringParse(red) || colors._default);
                }
                if (type === "array") {
                    each(spaces.rgba.props, function(key, prop) {
                        rgba[prop.idx] = clamp(red[prop.idx], prop);
                    });
                    return this;
                }
                if (type === "object") {
                    if (red instanceof color) {
                        each(spaces, function(spaceName, space) {
                            if (red[space.cache]) {
                                inst[space.cache] = red[space.cache].slice();
                            }
                        });
                    } else {
                        each(spaces, function(spaceName, space) {
                            var cache = space.cache;
                            each(space.props, function(key, prop) {
                                if (!inst[cache] && space.to) {
                                    if (key === "alpha" || red[key] == null) {
                                        return;
                                    }
                                    inst[cache] = space.to(inst._rgba);
                                }
                                inst[cache][prop.idx] = clamp(red[key], prop, true);
                            });
                            if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {
                                inst[cache][3] = 1;
                                if (space.from) {
                                    inst._rgba = space.from(inst[cache]);
                                }
                            }
                        });
                    }
                    return this;
                }
            },
            is: function(compare) {
                var is = color(compare), same = true, inst = this;
                each(spaces, function(_, space) {
                    var localCache, isCache = is[space.cache];
                    if (isCache) {
                        localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];
                        each(space.props, function(_, prop) {
                            if (isCache[prop.idx] != null) {
                                same = isCache[prop.idx] === localCache[prop.idx];
                                return same;
                            }
                        });
                    }
                    return same;
                });
                return same;
            },
            _space: function() {
                var used = [], inst = this;
                each(spaces, function(spaceName, space) {
                    if (inst[space.cache]) {
                        used.push(spaceName);
                    }
                });
                return used.pop();
            },
            transition: function(other, distance) {
                var end = color(other), spaceName = end._space(), space = spaces[spaceName], startColor = this.alpha() === 0 ? color("transparent") : this, start = startColor[space.cache] || space.to(startColor._rgba), result = start.slice();
                end = end[space.cache];
                each(space.props, function(key, prop) {
                    var index = prop.idx, startValue = start[index], endValue = end[index], type = propTypes[prop.type] || {};
                    if (endValue === null) {
                        return;
                    }
                    if (startValue === null) {
                        result[index] = endValue;
                    } else {
                        if (type.mod) {
                            if (endValue - startValue > type.mod / 2) {
                                startValue += type.mod;
                            } else if (startValue - endValue > type.mod / 2) {
                                startValue -= type.mod;
                            }
                        }
                        result[index] = clamp((endValue - startValue) * distance + startValue, prop);
                    }
                });
                return this[spaceName](result);
            },
            blend: function(opaque) {
                if (this._rgba[3] === 1) {
                    return this;
                }
                var rgb = this._rgba.slice(), a = rgb.pop(), blend = color(opaque)._rgba;
                return color(jQuery.map(rgb, function(v, i) {
                    return (1 - a) * blend[i] + a * v;
                }));
            },
            toRgbaString: function() {
                var prefix = "rgba(", rgba = jQuery.map(this._rgba, function(v, i) {
                    return v == null ? i > 2 ? 1 : 0 : v;
                });
                if (rgba[3] === 1) {
                    rgba.pop();
                    prefix = "rgb(";
                }
                return prefix + rgba.join() + ")";
            },
            toHslaString: function() {
                var prefix = "hsla(", hsla = jQuery.map(this.hsla(), function(v, i) {
                    if (v == null) {
                        v = i > 2 ? 1 : 0;
                    }
                    if (i && i < 3) {
                        v = Math.round(v * 100) + "%";
                    }
                    return v;
                });
                if (hsla[3] === 1) {
                    hsla.pop();
                    prefix = "hsl(";
                }
                return prefix + hsla.join() + ")";
            },
            toHexString: function(includeAlpha) {
                var rgba = this._rgba.slice(), alpha = rgba.pop();
                if (includeAlpha) {
                    rgba.push(~~(alpha * 255));
                }
                return "#" + jQuery.map(rgba, function(v) {
                    v = (v || 0).toString(16);
                    return v.length === 1 ? "0" + v : v;
                }).join("");
            },
            toString: function() {
                return this._rgba[3] === 0 ? "transparent" : this.toRgbaString();
            }
        });
        color.fn.parse.prototype = color.fn;
        function hue2rgb(p, q, h) {
            h = (h + 1) % 1;
            if (h * 6 < 1) {
                return p + (q - p) * h * 6;
            }
            if (h * 2 < 1) {
                return q;
            }
            if (h * 3 < 2) {
                return p + (q - p) * (2 / 3 - h) * 6;
            }
            return p;
        }
        spaces.hsla.to = function(rgba) {
            if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
                return [ null, null, null, rgba[3] ];
            }
            var r = rgba[0] / 255, g = rgba[1] / 255, b = rgba[2] / 255, a = rgba[3], max = Math.max(r, g, b), min = Math.min(r, g, b), diff = max - min, add = max + min, l = add * .5, h, s;
            if (min === max) {
                h = 0;
            } else if (r === max) {
                h = 60 * (g - b) / diff + 360;
            } else if (g === max) {
                h = 60 * (b - r) / diff + 120;
            } else {
                h = 60 * (r - g) / diff + 240;
            }
            if (diff === 0) {
                s = 0;
            } else if (l <= .5) {
                s = diff / add;
            } else {
                s = diff / (2 - add);
            }
            return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
        };
        spaces.hsla.from = function(hsla) {
            if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
                return [ null, null, null, hsla[3] ];
            }
            var h = hsla[0] / 360, s = hsla[1], l = hsla[2], a = hsla[3], q = l <= .5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
            return [ Math.round(hue2rgb(p, q, h + 1 / 3) * 255), Math.round(hue2rgb(p, q, h) * 255), Math.round(hue2rgb(p, q, h - 1 / 3) * 255), a ];
        };
        each(spaces, function(spaceName, space) {
            var props = space.props, cache = space.cache, to = space.to, from = space.from;
            color.fn[spaceName] = function(value) {
                if (to && !this[cache]) {
                    this[cache] = to(this._rgba);
                }
                if (value === undefined) {
                    return this[cache].slice();
                }
                var ret, type = jQuery.type(value), arr = type === "array" || type === "object" ? value : arguments, local = this[cache].slice();
                each(props, function(key, prop) {
                    var val = arr[type === "object" ? key : prop.idx];
                    if (val == null) {
                        val = local[prop.idx];
                    }
                    local[prop.idx] = clamp(val, prop);
                });
                if (from) {
                    ret = color(from(local));
                    ret[cache] = local;
                    return ret;
                } else {
                    return color(local);
                }
            };
            each(props, function(key, prop) {
                if (color.fn[key]) {
                    return;
                }
                color.fn[key] = function(value) {
                    var vtype = jQuery.type(value), fn = key === "alpha" ? this._hsla ? "hsla" : "rgba" : spaceName, local = this[fn](), cur = local[prop.idx], match;
                    if (vtype === "undefined") {
                        return cur;
                    }
                    if (vtype === "function") {
                        value = value.call(this, cur);
                        vtype = jQuery.type(value);
                    }
                    if (value == null && prop.empty) {
                        return this;
                    }
                    if (vtype === "string") {
                        match = rplusequals.exec(value);
                        if (match) {
                            value = cur + parseFloat(match[2]) * (match[1] === "+" ? 1 : -1);
                        }
                    }
                    local[prop.idx] = value;
                    return this[fn](local);
                };
            });
        });
        color.hook = function(hook) {
            var hooks = hook.split(" ");
            each(hooks, function(i, hook) {
                jQuery.cssHooks[hook] = {
                    set: function(elem, value) {
                        var parsed, curElem, backgroundColor = "";
                        if (value !== "transparent" && (jQuery.type(value) !== "string" || (parsed = stringParse(value)))) {
                            value = color(parsed || value);
                            if (!support.rgba && value._rgba[3] !== 1) {
                                curElem = hook === "backgroundColor" ? elem.parentNode : elem;
                                while ((backgroundColor === "" || backgroundColor === "transparent") && curElem && curElem.style) {
                                    try {
                                        backgroundColor = jQuery.css(curElem, "backgroundColor");
                                        curElem = curElem.parentNode;
                                    } catch (e) {}
                                }
                                value = value.blend(backgroundColor && backgroundColor !== "transparent" ? backgroundColor : "_default");
                            }
                            value = value.toRgbaString();
                        }
                        try {
                            elem.style[hook] = value;
                        } catch (e) {}
                    }
                };
                jQuery.fx.step[hook] = function(fx) {
                    if (!fx.colorInit) {
                        fx.start = color(fx.elem, hook);
                        fx.end = color(fx.end);
                        fx.colorInit = true;
                    }
                    jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
                };
            });
        };
        color.hook(stepHooks);
        jQuery.cssHooks.borderColor = {
            expand: function(value) {
                var expanded = {};
                each([ "Top", "Right", "Bottom", "Left" ], function(i, part) {
                    expanded["border" + part + "Color"] = value;
                });
                return expanded;
            }
        };
        colors = jQuery.Color.names = {
            aqua: "#00ffff",
            black: "#000000",
            blue: "#0000ff",
            fuchsia: "#ff00ff",
            gray: "#808080",
            green: "#008000",
            lime: "#00ff00",
            maroon: "#800000",
            navy: "#000080",
            olive: "#808000",
            purple: "#800080",
            red: "#ff0000",
            silver: "#c0c0c0",
            teal: "#008080",
            white: "#ffffff",
            yellow: "#ffff00",
            transparent: [ null, null, null, 0 ],
            _default: "#ffffff"
        };
    })(jQuery);
    (function() {
        var classAnimationActions = [ "add", "remove", "toggle" ], shorthandStyles = {
            border: 1,
            borderBottom: 1,
            borderColor: 1,
            borderLeft: 1,
            borderRight: 1,
            borderTop: 1,
            borderWidth: 1,
            margin: 1,
            padding: 1
        };
        $.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function(_, prop) {
            $.fx.step[prop] = function(fx) {
                if (fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {
                    jQuery.style(fx.elem, prop, fx.end);
                    fx.setAttr = true;
                }
            };
        });
        function getElementStyles(elem) {
            var key, len, style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle, styles = {};
            if (style && style.length && style[0] && style[style[0]]) {
                len = style.length;
                while (len--) {
                    key = style[len];
                    if (typeof style[key] === "string") {
                        styles[$.camelCase(key)] = style[key];
                    }
                }
            } else {
                for (key in style) {
                    if (typeof style[key] === "string") {
                        styles[key] = style[key];
                    }
                }
            }
            return styles;
        }
        function styleDifference(oldStyle, newStyle) {
            var diff = {}, name, value;
            for (name in newStyle) {
                value = newStyle[name];
                if (oldStyle[name] !== value) {
                    if (!shorthandStyles[name]) {
                        if ($.fx.step[name] || !isNaN(parseFloat(value))) {
                            diff[name] = value;
                        }
                    }
                }
            }
            return diff;
        }
        if (!$.fn.addBack) {
            $.fn.addBack = function(selector) {
                return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
            };
        }
        $.effects.animateClass = function(value, duration, easing, callback) {
            var o = $.speed(duration, easing, callback);
            return this.queue(function() {
                var animated = $(this), baseClass = animated.attr("class") || "", applyClassChange, allAnimations = o.children ? animated.find("*").addBack() : animated;
                allAnimations = allAnimations.map(function() {
                    var el = $(this);
                    return {
                        el: el,
                        start: getElementStyles(this)
                    };
                });
                applyClassChange = function() {
                    $.each(classAnimationActions, function(i, action) {
                        if (value[action]) {
                            animated[action + "Class"](value[action]);
                        }
                    });
                };
                applyClassChange();
                allAnimations = allAnimations.map(function() {
                    this.end = getElementStyles(this.el[0]);
                    this.diff = styleDifference(this.start, this.end);
                    return this;
                });
                animated.attr("class", baseClass);
                allAnimations = allAnimations.map(function() {
                    var styleInfo = this, dfd = $.Deferred(), opts = $.extend({}, o, {
                        queue: false,
                        complete: function() {
                            dfd.resolve(styleInfo);
                        }
                    });
                    this.el.animate(this.diff, opts);
                    return dfd.promise();
                });
                $.when.apply($, allAnimations.get()).done(function() {
                    applyClassChange();
                    $.each(arguments, function() {
                        var el = this.el;
                        $.each(this.diff, function(key) {
                            el.css(key, "");
                        });
                    });
                    o.complete.call(animated[0]);
                });
            });
        };
        $.fn.extend({
            addClass: function(orig) {
                return function(classNames, speed, easing, callback) {
                    return speed ? $.effects.animateClass.call(this, {
                        add: classNames
                    }, speed, easing, callback) : orig.apply(this, arguments);
                };
            }($.fn.addClass),
            removeClass: function(orig) {
                return function(classNames, speed, easing, callback) {
                    return arguments.length > 1 ? $.effects.animateClass.call(this, {
                        remove: classNames
                    }, speed, easing, callback) : orig.apply(this, arguments);
                };
            }($.fn.removeClass),
            toggleClass: function(orig) {
                return function(classNames, force, speed, easing, callback) {
                    if (typeof force === "boolean" || force === undefined) {
                        if (!speed) {
                            return orig.apply(this, arguments);
                        } else {
                            return $.effects.animateClass.call(this, force ? {
                                add: classNames
                            } : {
                                remove: classNames
                            }, speed, easing, callback);
                        }
                    } else {
                        return $.effects.animateClass.call(this, {
                            toggle: classNames
                        }, force, speed, easing);
                    }
                };
            }($.fn.toggleClass),
            switchClass: function(remove, add, speed, easing, callback) {
                return $.effects.animateClass.call(this, {
                    add: add,
                    remove: remove
                }, speed, easing, callback);
            }
        });
    })();
    (function() {
        $.extend($.effects, {
            version: "1.10.3",
            save: function(element, set) {
                for (var i = 0; i < set.length; i++) {
                    if (set[i] !== null) {
                        element.data(dataSpace + set[i], element[0].style[set[i]]);
                    }
                }
            },
            restore: function(element, set) {
                var val, i;
                for (i = 0; i < set.length; i++) {
                    if (set[i] !== null) {
                        val = element.data(dataSpace + set[i]);
                        if (val === undefined) {
                            val = "";
                        }
                        element.css(set[i], val);
                    }
                }
            },
            setMode: function(el, mode) {
                if (mode === "toggle") {
                    mode = el.is(":hidden") ? "show" : "hide";
                }
                return mode;
            },
            getBaseline: function(origin, original) {
                var y, x;
                switch (origin[0]) {
                  case "top":
                    y = 0;
                    break;

                  case "middle":
                    y = .5;
                    break;

                  case "bottom":
                    y = 1;
                    break;

                  default:
                    y = origin[0] / original.height;
                }
                switch (origin[1]) {
                  case "left":
                    x = 0;
                    break;

                  case "center":
                    x = .5;
                    break;

                  case "right":
                    x = 1;
                    break;

                  default:
                    x = origin[1] / original.width;
                }
                return {
                    x: x,
                    y: y
                };
            },
            createWrapper: function(element) {
                if (element.parent().is(".ui-effects-wrapper")) {
                    return element.parent();
                }
                var props = {
                    width: element.outerWidth(true),
                    height: element.outerHeight(true),
                    "float": element.css("float")
                }, wrapper = $("<div></div>").addClass("ui-effects-wrapper").css({
                    fontSize: "100%",
                    background: "transparent",
                    border: "none",
                    margin: 0,
                    padding: 0
                }), size = {
                    width: element.width(),
                    height: element.height()
                }, active = document.activeElement;
                try {
                    active.id;
                } catch (e) {
                    active = document.body;
                }
                element.wrap(wrapper);
                if (element[0] === active || $.contains(element[0], active)) {
                    $(active).focus();
                }
                wrapper = element.parent();
                if (element.css("position") === "static") {
                    wrapper.css({
                        position: "relative"
                    });
                    element.css({
                        position: "relative"
                    });
                } else {
                    $.extend(props, {
                        position: element.css("position"),
                        zIndex: element.css("z-index")
                    });
                    $.each([ "top", "left", "bottom", "right" ], function(i, pos) {
                        props[pos] = element.css(pos);
                        if (isNaN(parseInt(props[pos], 10))) {
                            props[pos] = "auto";
                        }
                    });
                    element.css({
                        position: "relative",
                        top: 0,
                        left: 0,
                        right: "auto",
                        bottom: "auto"
                    });
                }
                element.css(size);
                return wrapper.css(props).show();
            },
            removeWrapper: function(element) {
                var active = document.activeElement;
                if (element.parent().is(".ui-effects-wrapper")) {
                    element.parent().replaceWith(element);
                    if (element[0] === active || $.contains(element[0], active)) {
                        $(active).focus();
                    }
                }
                return element;
            },
            setTransition: function(element, list, factor, value) {
                value = value || {};
                $.each(list, function(i, x) {
                    var unit = element.cssUnit(x);
                    if (unit[0] > 0) {
                        value[x] = unit[0] * factor + unit[1];
                    }
                });
                return value;
            }
        });
        function _normalizeArguments(effect, options, speed, callback) {
            if ($.isPlainObject(effect)) {
                options = effect;
                effect = effect.effect;
            }
            effect = {
                effect: effect
            };
            if (options == null) {
                options = {};
            }
            if ($.isFunction(options)) {
                callback = options;
                speed = null;
                options = {};
            }
            if (typeof options === "number" || $.fx.speeds[options]) {
                callback = speed;
                speed = options;
                options = {};
            }
            if ($.isFunction(speed)) {
                callback = speed;
                speed = null;
            }
            if (options) {
                $.extend(effect, options);
            }
            speed = speed || options.duration;
            effect.duration = $.fx.off ? 0 : typeof speed === "number" ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;
            effect.complete = callback || options.complete;
            return effect;
        }
        function standardAnimationOption(option) {
            if (!option || typeof option === "number" || $.fx.speeds[option]) {
                return true;
            }
            if (typeof option === "string" && !$.effects.effect[option]) {
                return true;
            }
            if ($.isFunction(option)) {
                return true;
            }
            if (typeof option === "object" && !option.effect) {
                return true;
            }
            return false;
        }
        $.fn.extend({
            effect: function() {
                var args = _normalizeArguments.apply(this, arguments), mode = args.mode, queue = args.queue, effectMethod = $.effects.effect[args.effect];
                if ($.fx.off || !effectMethod) {
                    if (mode) {
                        return this[mode](args.duration, args.complete);
                    } else {
                        return this.each(function() {
                            if (args.complete) {
                                args.complete.call(this);
                            }
                        });
                    }
                }
                function run(next) {
                    var elem = $(this), complete = args.complete, mode = args.mode;
                    function done() {
                        if ($.isFunction(complete)) {
                            complete.call(elem[0]);
                        }
                        if ($.isFunction(next)) {
                            next();
                        }
                    }
                    if (elem.is(":hidden") ? mode === "hide" : mode === "show") {
                        elem[mode]();
                        done();
                    } else {
                        effectMethod.call(elem[0], args, done);
                    }
                }
                return queue === false ? this.each(run) : this.queue(queue || "fx", run);
            },
            show: function(orig) {
                return function(option) {
                    if (standardAnimationOption(option)) {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "show";
                        return this.effect.call(this, args);
                    }
                };
            }($.fn.show),
            hide: function(orig) {
                return function(option) {
                    if (standardAnimationOption(option)) {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "hide";
                        return this.effect.call(this, args);
                    }
                };
            }($.fn.hide),
            toggle: function(orig) {
                return function(option) {
                    if (standardAnimationOption(option) || typeof option === "boolean") {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "toggle";
                        return this.effect.call(this, args);
                    }
                };
            }($.fn.toggle),
            cssUnit: function(key) {
                var style = this.css(key), val = [];
                $.each([ "em", "px", "%", "pt" ], function(i, unit) {
                    if (style.indexOf(unit) > 0) {
                        val = [ parseFloat(style), unit ];
                    }
                });
                return val;
            }
        });
    })();
    (function() {
        var baseEasings = {};
        $.each([ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function(i, name) {
            baseEasings[name] = function(p) {
                return Math.pow(p, i + 2);
            };
        });
        $.extend(baseEasings, {
            Sine: function(p) {
                return 1 - Math.cos(p * Math.PI / 2);
            },
            Circ: function(p) {
                return 1 - Math.sqrt(1 - p * p);
            },
            Elastic: function(p) {
                return p === 0 || p === 1 ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);
            },
            Back: function(p) {
                return p * p * (3 * p - 2);
            },
            Bounce: function(p) {
                var pow2, bounce = 4;
                while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}
                return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);
            }
        });
        $.each(baseEasings, function(name, easeIn) {
            $.easing["easeIn" + name] = easeIn;
            $.easing["easeOut" + name] = function(p) {
                return 1 - easeIn(1 - p);
            };
            $.easing["easeInOut" + name] = function(p) {
                return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;
            };
        });
    })();
})(jQuery);

(function($, undefined) {
    var uid = 0, hideProps = {}, showProps = {};
    hideProps.height = hideProps.paddingTop = hideProps.paddingBottom = hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide";
    showProps.height = showProps.paddingTop = showProps.paddingBottom = showProps.borderTopWidth = showProps.borderBottomWidth = "show";
    $.widget("ui.accordion", {
        version: "1.10.3",
        options: {
            active: 0,
            animate: {},
            collapsible: false,
            event: "click",
            header: "> li > :first-child,> :not(li):even",
            heightStyle: "auto",
            icons: {
                activeHeader: "ui-icon-triangle-1-s",
                header: "ui-icon-triangle-1-e"
            },
            activate: null,
            beforeActivate: null
        },
        _create: function() {
            var options = this.options;
            this.prevShow = this.prevHide = $();
            this.element.addClass("ui-accordion ui-widget ui-helper-reset").attr("role", "tablist");
            if (!options.collapsible && (options.active === false || options.active == null)) {
                options.active = 0;
            }
            this._processPanels();
            if (options.active < 0) {
                options.active += this.headers.length;
            }
            this._refresh();
        },
        _getCreateEventData: function() {
            return {
                header: this.active,
                panel: !this.active.length ? $() : this.active.next(),
                content: !this.active.length ? $() : this.active.next()
            };
        },
        _createIcons: function() {
            var icons = this.options.icons;
            if (icons) {
                $("<span>").addClass("ui-accordion-header-icon ui-icon " + icons.header).prependTo(this.headers);
                this.active.children(".ui-accordion-header-icon").removeClass(icons.header).addClass(icons.activeHeader);
                this.headers.addClass("ui-accordion-icons");
            }
        },
        _destroyIcons: function() {
            this.headers.removeClass("ui-accordion-icons").children(".ui-accordion-header-icon").remove();
        },
        _destroy: function() {
            var contents;
            this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role");
            this.headers.removeClass("ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-selected").removeAttr("aria-controls").removeAttr("tabIndex").each(function() {
                if (/^ui-accordion/.test(this.id)) {
                    this.removeAttribute("id");
                }
            });
            this._destroyIcons();
            contents = this.headers.next().css("display", "").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-labelledby").removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled").each(function() {
                if (/^ui-accordion/.test(this.id)) {
                    this.removeAttribute("id");
                }
            });
            if (this.options.heightStyle !== "content") {
                contents.css("height", "");
            }
        },
        _setOption: function(key, value) {
            if (key === "active") {
                this._activate(value);
                return;
            }
            if (key === "event") {
                if (this.options.event) {
                    this._off(this.headers, this.options.event);
                }
                this._setupEvents(value);
            }
            this._super(key, value);
            if (key === "collapsible" && !value && this.options.active === false) {
                this._activate(0);
            }
            if (key === "icons") {
                this._destroyIcons();
                if (value) {
                    this._createIcons();
                }
            }
            if (key === "disabled") {
                this.headers.add(this.headers.next()).toggleClass("ui-state-disabled", !!value);
            }
        },
        _keydown: function(event) {
            if (event.altKey || event.ctrlKey) {
                return;
            }
            var keyCode = $.ui.keyCode, length = this.headers.length, currentIndex = this.headers.index(event.target), toFocus = false;
            switch (event.keyCode) {
              case keyCode.RIGHT:
              case keyCode.DOWN:
                toFocus = this.headers[(currentIndex + 1) % length];
                break;

              case keyCode.LEFT:
              case keyCode.UP:
                toFocus = this.headers[(currentIndex - 1 + length) % length];
                break;

              case keyCode.SPACE:
              case keyCode.ENTER:
                this._eventHandler(event);
                break;

              case keyCode.HOME:
                toFocus = this.headers[0];
                break;

              case keyCode.END:
                toFocus = this.headers[length - 1];
                break;
            }
            if (toFocus) {
                $(event.target).attr("tabIndex", -1);
                $(toFocus).attr("tabIndex", 0);
                toFocus.focus();
                event.preventDefault();
            }
        },
        _panelKeyDown: function(event) {
            if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
                $(event.currentTarget).prev().focus();
            }
        },
        refresh: function() {
            var options = this.options;
            this._processPanels();
            if (options.active === false && options.collapsible === true || !this.headers.length) {
                options.active = false;
                this.active = $();
            } else if (options.active === false) {
                this._activate(0);
            } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {
                if (this.headers.length === this.headers.find(".ui-state-disabled").length) {
                    options.active = false;
                    this.active = $();
                } else {
                    this._activate(Math.max(0, options.active - 1));
                }
            } else {
                options.active = this.headers.index(this.active);
            }
            this._destroyIcons();
            this._refresh();
        },
        _processPanels: function() {
            this.headers = this.element.find(this.options.header).addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-all");
            this.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").filter(":not(.ui-accordion-content-active)").hide();
        },
        _refresh: function() {
            var maxHeight, options = this.options, heightStyle = options.heightStyle, parent = this.element.parent(), accordionId = this.accordionId = "ui-accordion-" + (this.element.attr("id") || ++uid);
            this.active = this._findActive(options.active).addClass("ui-accordion-header-active ui-state-active ui-corner-top").removeClass("ui-corner-all");
            this.active.next().addClass("ui-accordion-content-active").show();
            this.headers.attr("role", "tab").each(function(i) {
                var header = $(this), headerId = header.attr("id"), panel = header.next(), panelId = panel.attr("id");
                if (!headerId) {
                    headerId = accordionId + "-header-" + i;
                    header.attr("id", headerId);
                }
                if (!panelId) {
                    panelId = accordionId + "-panel-" + i;
                    panel.attr("id", panelId);
                }
                header.attr("aria-controls", panelId);
                panel.attr("aria-labelledby", headerId);
            }).next().attr("role", "tabpanel");
            this.headers.not(this.active).attr({
                "aria-selected": "false",
                tabIndex: -1
            }).next().attr({
                "aria-expanded": "false",
                "aria-hidden": "true"
            }).hide();
            if (!this.active.length) {
                this.headers.eq(0).attr("tabIndex", 0);
            } else {
                this.active.attr({
                    "aria-selected": "true",
                    tabIndex: 0
                }).next().attr({
                    "aria-expanded": "true",
                    "aria-hidden": "false"
                });
            }
            this._createIcons();
            this._setupEvents(options.event);
            if (heightStyle === "fill") {
                maxHeight = parent.height();
                this.element.siblings(":visible").each(function() {
                    var elem = $(this), position = elem.css("position");
                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });
                this.headers.each(function() {
                    maxHeight -= $(this).outerHeight(true);
                });
                this.headers.next().each(function() {
                    $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
                }).css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.headers.next().each(function() {
                    maxHeight = Math.max(maxHeight, $(this).css("height", "").height());
                }).height(maxHeight);
            }
        },
        _activate: function(index) {
            var active = this._findActive(index)[0];
            if (active === this.active[0]) {
                return;
            }
            active = active || this.active[0];
            this._eventHandler({
                target: active,
                currentTarget: active,
                preventDefault: $.noop
            });
        },
        _findActive: function(selector) {
            return typeof selector === "number" ? this.headers.eq(selector) : $();
        },
        _setupEvents: function(event) {
            var events = {
                keydown: "_keydown"
            };
            if (event) {
                $.each(event.split(" "), function(index, eventName) {
                    events[eventName] = "_eventHandler";
                });
            }
            this._off(this.headers.add(this.headers.next()));
            this._on(this.headers, events);
            this._on(this.headers.next(), {
                keydown: "_panelKeyDown"
            });
            this._hoverable(this.headers);
            this._focusable(this.headers);
        },
        _eventHandler: function(event) {
            var options = this.options, active = this.active, clicked = $(event.currentTarget), clickedIsActive = clicked[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : clicked.next(), toHide = active.next(), eventData = {
                oldHeader: active,
                oldPanel: toHide,
                newHeader: collapsing ? $() : clicked,
                newPanel: toShow
            };
            event.preventDefault();
            if (clickedIsActive && !options.collapsible || this._trigger("beforeActivate", event, eventData) === false) {
                return;
            }
            options.active = collapsing ? false : this.headers.index(clicked);
            this.active = clickedIsActive ? $() : clicked;
            this._toggle(eventData);
            active.removeClass("ui-accordion-header-active ui-state-active");
            if (options.icons) {
                active.children(".ui-accordion-header-icon").removeClass(options.icons.activeHeader).addClass(options.icons.header);
            }
            if (!clickedIsActive) {
                clicked.removeClass("ui-corner-all").addClass("ui-accordion-header-active ui-state-active ui-corner-top");
                if (options.icons) {
                    clicked.children(".ui-accordion-header-icon").removeClass(options.icons.header).addClass(options.icons.activeHeader);
                }
                clicked.next().addClass("ui-accordion-content-active");
            }
        },
        _toggle: function(data) {
            var toShow = data.newPanel, toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
            this.prevShow.add(this.prevHide).stop(true, true);
            this.prevShow = toShow;
            this.prevHide = toHide;
            if (this.options.animate) {
                this._animate(toShow, toHide, data);
            } else {
                toHide.hide();
                toShow.show();
                this._toggleComplete(data);
            }
            toHide.attr({
                "aria-expanded": "false",
                "aria-hidden": "true"
            });
            toHide.prev().attr("aria-selected", "false");
            if (toShow.length && toHide.length) {
                toHide.prev().attr("tabIndex", -1);
            } else if (toShow.length) {
                this.headers.filter(function() {
                    return $(this).attr("tabIndex") === 0;
                }).attr("tabIndex", -1);
            }
            toShow.attr({
                "aria-expanded": "true",
                "aria-hidden": "false"
            }).prev().attr({
                "aria-selected": "true",
                tabIndex: 0
            });
        },
        _animate: function(toShow, toHide, data) {
            var total, easing, duration, that = this, adjust = 0, down = toShow.length && (!toHide.length || toShow.index() < toHide.index()), animate = this.options.animate || {}, options = down && animate.down || animate, complete = function() {
                that._toggleComplete(data);
            };
            if (typeof options === "number") {
                duration = options;
            }
            if (typeof options === "string") {
                easing = options;
            }
            easing = easing || options.easing || animate.easing;
            duration = duration || options.duration || animate.duration;
            if (!toHide.length) {
                return toShow.animate(showProps, duration, easing, complete);
            }
            if (!toShow.length) {
                return toHide.animate(hideProps, duration, easing, complete);
            }
            total = toShow.show().outerHeight();
            toHide.animate(hideProps, {
                duration: duration,
                easing: easing,
                step: function(now, fx) {
                    fx.now = Math.round(now);
                }
            });
            toShow.hide().animate(showProps, {
                duration: duration,
                easing: easing,
                complete: complete,
                step: function(now, fx) {
                    fx.now = Math.round(now);
                    if (fx.prop !== "height") {
                        adjust += fx.now;
                    } else if (that.options.heightStyle !== "content") {
                        fx.now = Math.round(total - toHide.outerHeight() - adjust);
                        adjust = 0;
                    }
                }
            });
        },
        _toggleComplete: function(data) {
            var toHide = data.oldPanel;
            toHide.removeClass("ui-accordion-content-active").prev().removeClass("ui-corner-top").addClass("ui-corner-all");
            if (toHide.length) {
                toHide.parent()[0].className = toHide.parent()[0].className;
            }
            this._trigger("activate", null, data);
        }
    });
})(jQuery);

(function($, undefined) {
    var requestIndex = 0;
    $.widget("ui.autocomplete", {
        version: "1.10.3",
        defaultElement: "<input>",
        options: {
            appendTo: null,
            autoFocus: false,
            delay: 300,
            minLength: 1,
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            source: null,
            change: null,
            close: null,
            focus: null,
            open: null,
            response: null,
            search: null,
            select: null
        },
        pending: 0,
        _create: function() {
            var suppressKeyPress, suppressKeyPressRepeat, suppressInput, nodeName = this.element[0].nodeName.toLowerCase(), isTextarea = nodeName === "textarea", isInput = nodeName === "input";
            this.isMultiLine = isTextarea ? true : isInput ? false : this.element.prop("isContentEditable");
            this.valueMethod = this.element[isTextarea || isInput ? "val" : "text"];
            this.isNewMenu = true;
            this.element.addClass("ui-autocomplete-input").attr("autocomplete", "off");
            this._on(this.element, {
                keydown: function(event) {
                    if (this.element.prop("readOnly")) {
                        suppressKeyPress = true;
                        suppressInput = true;
                        suppressKeyPressRepeat = true;
                        return;
                    }
                    suppressKeyPress = false;
                    suppressInput = false;
                    suppressKeyPressRepeat = false;
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                      case keyCode.PAGE_UP:
                        suppressKeyPress = true;
                        this._move("previousPage", event);
                        break;

                      case keyCode.PAGE_DOWN:
                        suppressKeyPress = true;
                        this._move("nextPage", event);
                        break;

                      case keyCode.UP:
                        suppressKeyPress = true;
                        this._keyEvent("previous", event);
                        break;

                      case keyCode.DOWN:
                        suppressKeyPress = true;
                        this._keyEvent("next", event);
                        break;

                      case keyCode.ENTER:
                      case keyCode.NUMPAD_ENTER:
                        if (this.menu.active) {
                            suppressKeyPress = true;
                            event.preventDefault();
                            this.menu.select(event);
                        }
                        break;

                      case keyCode.TAB:
                        if (this.menu.active) {
                            this.menu.select(event);
                        }
                        break;

                      case keyCode.ESCAPE:
                        if (this.menu.element.is(":visible")) {
                            this._value(this.term);
                            this.close(event);
                            event.preventDefault();
                        }
                        break;

                      default:
                        suppressKeyPressRepeat = true;
                        this._searchTimeout(event);
                        break;
                    }
                },
                keypress: function(event) {
                    if (suppressKeyPress) {
                        suppressKeyPress = false;
                        if (!this.isMultiLine || this.menu.element.is(":visible")) {
                            event.preventDefault();
                        }
                        return;
                    }
                    if (suppressKeyPressRepeat) {
                        return;
                    }
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                      case keyCode.PAGE_UP:
                        this._move("previousPage", event);
                        break;

                      case keyCode.PAGE_DOWN:
                        this._move("nextPage", event);
                        break;

                      case keyCode.UP:
                        this._keyEvent("previous", event);
                        break;

                      case keyCode.DOWN:
                        this._keyEvent("next", event);
                        break;
                    }
                },
                input: function(event) {
                    if (suppressInput) {
                        suppressInput = false;
                        event.preventDefault();
                        return;
                    }
                    this._searchTimeout(event);
                },
                focus: function() {
                    this.selectedItem = null;
                    this.previous = this._value();
                },
                blur: function(event) {
                    if (this.cancelBlur) {
                        delete this.cancelBlur;
                        return;
                    }
                    clearTimeout(this.searching);
                    this.close(event);
                    this._change(event);
                }
            });
            this._initSource();
            this.menu = $("<ul>").addClass("ui-autocomplete ui-front").appendTo(this._appendTo()).menu({
                role: null
            }).hide().data("ui-menu");
            this._on(this.menu.element, {
                mousedown: function(event) {
                    event.preventDefault();
                    this.cancelBlur = true;
                    this._delay(function() {
                        delete this.cancelBlur;
                    });
                    var menuElement = this.menu.element[0];
                    if (!$(event.target).closest(".ui-menu-item").length) {
                        this._delay(function() {
                            var that = this;
                            this.document.one("mousedown", function(event) {
                                if (event.target !== that.element[0] && event.target !== menuElement && !$.contains(menuElement, event.target)) {
                                    that.close();
                                }
                            });
                        });
                    }
                },
                menufocus: function(event, ui) {
                    if (this.isNewMenu) {
                        this.isNewMenu = false;
                        if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
                            this.menu.blur();
                            this.document.one("mousemove", function() {
                                $(event.target).trigger(event.originalEvent);
                            });
                            return;
                        }
                    }
                    var item = ui.item.data("ui-autocomplete-item");
                    if (false !== this._trigger("focus", event, {
                        item: item
                    })) {
                        if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
                            this._value(item.value);
                        }
                    } else {
                        this.liveRegion.text(item.value);
                    }
                },
                menuselect: function(event, ui) {
                    var item = ui.item.data("ui-autocomplete-item"), previous = this.previous;
                    if (this.element[0] !== this.document[0].activeElement) {
                        this.element.focus();
                        this.previous = previous;
                        this._delay(function() {
                            this.previous = previous;
                            this.selectedItem = item;
                        });
                    }
                    if (false !== this._trigger("select", event, {
                        item: item
                    })) {
                        this._value(item.value);
                    }
                    this.term = this._value();
                    this.close(event);
                    this.selectedItem = item;
                }
            });
            this.liveRegion = $("<span>", {
                role: "status",
                "aria-live": "polite"
            }).addClass("ui-helper-hidden-accessible").insertBefore(this.element);
            this._on(this.window, {
                beforeunload: function() {
                    this.element.removeAttr("autocomplete");
                }
            });
        },
        _destroy: function() {
            clearTimeout(this.searching);
            this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete");
            this.menu.element.remove();
            this.liveRegion.remove();
        },
        _setOption: function(key, value) {
            this._super(key, value);
            if (key === "source") {
                this._initSource();
            }
            if (key === "appendTo") {
                this.menu.element.appendTo(this._appendTo());
            }
            if (key === "disabled" && value && this.xhr) {
                this.xhr.abort();
            }
        },
        _appendTo: function() {
            var element = this.options.appendTo;
            if (element) {
                element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
            }
            if (!element) {
                element = this.element.closest(".ui-front");
            }
            if (!element.length) {
                element = this.document[0].body;
            }
            return element;
        },
        _initSource: function() {
            var array, url, that = this;
            if ($.isArray(this.options.source)) {
                array = this.options.source;
                this.source = function(request, response) {
                    response($.ui.autocomplete.filter(array, request.term));
                };
            } else if (typeof this.options.source === "string") {
                url = this.options.source;
                this.source = function(request, response) {
                    if (that.xhr) {
                        that.xhr.abort();
                    }
                    that.xhr = $.ajax({
                        url: url,
                        data: request,
                        dataType: "json",
                        success: function(data) {
                            response(data);
                        },
                        error: function() {
                            response([]);
                        }
                    });
                };
            } else {
                this.source = this.options.source;
            }
        },
        _searchTimeout: function(event) {
            clearTimeout(this.searching);
            this.searching = this._delay(function() {
                if (this.term !== this._value()) {
                    this.selectedItem = null;
                    this.search(null, event);
                }
            }, this.options.delay);
        },
        search: function(value, event) {
            value = value != null ? value : this._value();
            this.term = this._value();
            if (value.length < this.options.minLength) {
                return this.close(event);
            }
            if (this._trigger("search", event) === false) {
                return;
            }
            return this._search(value);
        },
        _search: function(value) {
            this.pending++;
            this.element.addClass("ui-autocomplete-loading");
            this.cancelSearch = false;
            this.source({
                term: value
            }, this._response());
        },
        _response: function() {
            var that = this, index = ++requestIndex;
            return function(content) {
                if (index === requestIndex) {
                    that.__response(content);
                }
                that.pending--;
                if (!that.pending) {
                    that.element.removeClass("ui-autocomplete-loading");
                }
            };
        },
        __response: function(content) {
            if (content) {
                content = this._normalize(content);
            }
            this._trigger("response", null, {
                content: content
            });
            if (!this.options.disabled && content && content.length && !this.cancelSearch) {
                this._suggest(content);
                this._trigger("open");
            } else {
                this._close();
            }
        },
        close: function(event) {
            this.cancelSearch = true;
            this._close(event);
        },
        _close: function(event) {
            if (this.menu.element.is(":visible")) {
                this.menu.element.hide();
                this.menu.blur();
                this.isNewMenu = true;
                this._trigger("close", event);
            }
        },
        _change: function(event) {
            if (this.previous !== this._value()) {
                this._trigger("change", event, {
                    item: this.selectedItem
                });
            }
        },
        _normalize: function(items) {
            if (items.length && items[0].label && items[0].value) {
                return items;
            }
            return $.map(items, function(item) {
                if (typeof item === "string") {
                    return {
                        label: item,
                        value: item
                    };
                }
                return $.extend({
                    label: item.label || item.value,
                    value: item.value || item.label
                }, item);
            });
        },
        _suggest: function(items) {
            var ul = this.menu.element.empty();
            this._renderMenu(ul, items);
            this.isNewMenu = true;
            this.menu.refresh();
            ul.show();
            this._resizeMenu();
            ul.position($.extend({
                of: this.element
            }, this.options.position));
            if (this.options.autoFocus) {
                this.menu.next();
            }
        },
        _resizeMenu: function() {
            var ul = this.menu.element;
            ul.outerWidth(Math.max(ul.width("").outerWidth() + 1, this.element.outerWidth()));
        },
        _renderMenu: function(ul, items) {
            var that = this;
            $.each(items, function(index, item) {
                that._renderItemData(ul, item);
            });
        },
        _renderItemData: function(ul, item) {
            return this._renderItem(ul, item).data("ui-autocomplete-item", item);
        },
        _renderItem: function(ul, item) {
            return $("<li>").append($("<a>").text(item.label)).appendTo(ul);
        },
        _move: function(direction, event) {
            if (!this.menu.element.is(":visible")) {
                this.search(null, event);
                return;
            }
            if (this.menu.isFirstItem() && /^previous/.test(direction) || this.menu.isLastItem() && /^next/.test(direction)) {
                this._value(this.term);
                this.menu.blur();
                return;
            }
            this.menu[direction](event);
        },
        widget: function() {
            return this.menu.element;
        },
        _value: function() {
            return this.valueMethod.apply(this.element, arguments);
        },
        _keyEvent: function(keyEvent, event) {
            if (!this.isMultiLine || this.menu.element.is(":visible")) {
                this._move(keyEvent, event);
                event.preventDefault();
            }
        }
    });
    $.extend($.ui.autocomplete, {
        escapeRegex: function(value) {
            return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
        },
        filter: function(array, term) {
            var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
            return $.grep(array, function(value) {
                return matcher.test(value.label || value.value || value);
            });
        }
    });
    $.widget("ui.autocomplete", $.ui.autocomplete, {
        options: {
            messages: {
                noResults: "No search results.",
                results: function(amount) {
                    return amount + (amount > 1 ? " results are" : " result is") + " available, use up and down arrow keys to navigate.";
                }
            }
        },
        __response: function(content) {
            var message;
            this._superApply(arguments);
            if (this.options.disabled || this.cancelSearch) {
                return;
            }
            if (content && content.length) {
                message = this.options.messages.results(content.length);
            } else {
                message = this.options.messages.noResults;
            }
            this.liveRegion.text(message);
        }
    });
})(jQuery);

(function($, undefined) {
    var lastActive, startXPos, startYPos, clickDragged, baseClasses = "ui-button ui-widget ui-state-default ui-corner-all", stateClasses = "ui-state-hover ui-state-active ", typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only", formResetHandler = function() {
        var form = $(this);
        setTimeout(function() {
            form.find(":ui-button").button("refresh");
        }, 1);
    }, radioGroup = function(radio) {
        var name = radio.name, form = radio.form, radios = $([]);
        if (name) {
            name = name.replace(/'/g, "\\'");
            if (form) {
                radios = $(form).find("[name='" + name + "']");
            } else {
                radios = $("[name='" + name + "']", radio.ownerDocument).filter(function() {
                    return !this.form;
                });
            }
        }
        return radios;
    };
    $.widget("ui.button", {
        version: "1.10.3",
        defaultElement: "<button>",
        options: {
            disabled: null,
            text: true,
            label: null,
            icons: {
                primary: null,
                secondary: null
            }
        },
        _create: function() {
            this.element.closest("form").unbind("reset" + this.eventNamespace).bind("reset" + this.eventNamespace, formResetHandler);
            if (typeof this.options.disabled !== "boolean") {
                this.options.disabled = !!this.element.prop("disabled");
            } else {
                this.element.prop("disabled", this.options.disabled);
            }
            this._determineButtonType();
            this.hasTitle = !!this.buttonElement.attr("title");
            var that = this, options = this.options, toggleButton = this.type === "checkbox" || this.type === "radio", activeClass = !toggleButton ? "ui-state-active" : "", focusClass = "ui-state-focus";
            if (options.label === null) {
                options.label = this.type === "input" ? this.buttonElement.val() : this.buttonElement.html();
            }
            this._hoverable(this.buttonElement);
            this.buttonElement.addClass(baseClasses).attr("role", "button").bind("mouseenter" + this.eventNamespace, function() {
                if (options.disabled) {
                    return;
                }
                if (this === lastActive) {
                    $(this).addClass("ui-state-active");
                }
            }).bind("mouseleave" + this.eventNamespace, function() {
                if (options.disabled) {
                    return;
                }
                $(this).removeClass(activeClass);
            }).bind("click" + this.eventNamespace, function(event) {
                if (options.disabled) {
                    event.preventDefault();
                    event.stopImmediatePropagation();
                }
            });
            this.element.bind("focus" + this.eventNamespace, function() {
                that.buttonElement.addClass(focusClass);
            }).bind("blur" + this.eventNamespace, function() {
                that.buttonElement.removeClass(focusClass);
            });
            if (toggleButton) {
                this.element.bind("change" + this.eventNamespace, function() {
                    if (clickDragged) {
                        return;
                    }
                    that.refresh();
                });
                this.buttonElement.bind("mousedown" + this.eventNamespace, function(event) {
                    if (options.disabled) {
                        return;
                    }
                    clickDragged = false;
                    startXPos = event.pageX;
                    startYPos = event.pageY;
                }).bind("mouseup" + this.eventNamespace, function(event) {
                    if (options.disabled) {
                        return;
                    }
                    if (startXPos !== event.pageX || startYPos !== event.pageY) {
                        clickDragged = true;
                    }
                });
            }
            if (this.type === "checkbox") {
                this.buttonElement.bind("click" + this.eventNamespace, function() {
                    if (options.disabled || clickDragged) {
                        return false;
                    }
                });
            } else if (this.type === "radio") {
                this.buttonElement.bind("click" + this.eventNamespace, function() {
                    if (options.disabled || clickDragged) {
                        return false;
                    }
                    $(this).addClass("ui-state-active");
                    that.buttonElement.attr("aria-pressed", "true");
                    var radio = that.element[0];
                    radioGroup(radio).not(radio).map(function() {
                        return $(this).button("widget")[0];
                    }).removeClass("ui-state-active").attr("aria-pressed", "false");
                });
            } else {
                this.buttonElement.bind("mousedown" + this.eventNamespace, function() {
                    if (options.disabled) {
                        return false;
                    }
                    $(this).addClass("ui-state-active");
                    lastActive = this;
                    that.document.one("mouseup", function() {
                        lastActive = null;
                    });
                }).bind("mouseup" + this.eventNamespace, function() {
                    if (options.disabled) {
                        return false;
                    }
                    $(this).removeClass("ui-state-active");
                }).bind("keydown" + this.eventNamespace, function(event) {
                    if (options.disabled) {
                        return false;
                    }
                    if (event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) {
                        $(this).addClass("ui-state-active");
                    }
                }).bind("keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
                    $(this).removeClass("ui-state-active");
                });
                if (this.buttonElement.is("a")) {
                    this.buttonElement.keyup(function(event) {
                        if (event.keyCode === $.ui.keyCode.SPACE) {
                            $(this).click();
                        }
                    });
                }
            }
            this._setOption("disabled", options.disabled);
            this._resetButton();
        },
        _determineButtonType: function() {
            var ancestor, labelSelector, checked;
            if (this.element.is("[type=checkbox]")) {
                this.type = "checkbox";
            } else if (this.element.is("[type=radio]")) {
                this.type = "radio";
            } else if (this.element.is("input")) {
                this.type = "input";
            } else {
                this.type = "button";
            }
            if (this.type === "checkbox" || this.type === "radio") {
                ancestor = this.element.parents().last();
                labelSelector = "label[for='" + this.element.attr("id") + "']";
                this.buttonElement = ancestor.find(labelSelector);
                if (!this.buttonElement.length) {
                    ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
                    this.buttonElement = ancestor.filter(labelSelector);
                    if (!this.buttonElement.length) {
                        this.buttonElement = ancestor.find(labelSelector);
                    }
                }
                this.element.addClass("ui-helper-hidden-accessible");
                checked = this.element.is(":checked");
                if (checked) {
                    this.buttonElement.addClass("ui-state-active");
                }
                this.buttonElement.prop("aria-pressed", checked);
            } else {
                this.buttonElement = this.element;
            }
        },
        widget: function() {
            return this.buttonElement;
        },
        _destroy: function() {
            this.element.removeClass("ui-helper-hidden-accessible");
            this.buttonElement.removeClass(baseClasses + " " + stateClasses + " " + typeClasses).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html());
            if (!this.hasTitle) {
                this.buttonElement.removeAttr("title");
            }
        },
        _setOption: function(key, value) {
            this._super(key, value);
            if (key === "disabled") {
                if (value) {
                    this.element.prop("disabled", true);
                } else {
                    this.element.prop("disabled", false);
                }
                return;
            }
            this._resetButton();
        },
        refresh: function() {
            var isDisabled = this.element.is("input, button") ? this.element.is(":disabled") : this.element.hasClass("ui-button-disabled");
            if (isDisabled !== this.options.disabled) {
                this._setOption("disabled", isDisabled);
            }
            if (this.type === "radio") {
                radioGroup(this.element[0]).each(function() {
                    if ($(this).is(":checked")) {
                        $(this).button("widget").addClass("ui-state-active").attr("aria-pressed", "true");
                    } else {
                        $(this).button("widget").removeClass("ui-state-active").attr("aria-pressed", "false");
                    }
                });
            } else if (this.type === "checkbox") {
                if (this.element.is(":checked")) {
                    this.buttonElement.addClass("ui-state-active").attr("aria-pressed", "true");
                } else {
                    this.buttonElement.removeClass("ui-state-active").attr("aria-pressed", "false");
                }
            }
        },
        _resetButton: function() {
            if (this.type === "input") {
                if (this.options.label) {
                    this.element.val(this.options.label);
                }
                return;
            }
            var buttonElement = this.buttonElement.removeClass(typeClasses), buttonText = $("<span></span>", this.document[0]).addClass("ui-button-text").html(this.options.label).appendTo(buttonElement.empty()).text(), icons = this.options.icons, multipleIcons = icons.primary && icons.secondary, buttonClasses = [];
            if (icons.primary || icons.secondary) {
                if (this.options.text) {
                    buttonClasses.push("ui-button-text-icon" + (multipleIcons ? "s" : icons.primary ? "-primary" : "-secondary"));
                }
                if (icons.primary) {
                    buttonElement.prepend("<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>");
                }
                if (icons.secondary) {
                    buttonElement.append("<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>");
                }
                if (!this.options.text) {
                    buttonClasses.push(multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only");
                    if (!this.hasTitle) {
                        buttonElement.attr("title", $.trim(buttonText));
                    }
                }
            } else {
                buttonClasses.push("ui-button-text-only");
            }
            buttonElement.addClass(buttonClasses.join(" "));
        }
    });
    $.widget("ui.buttonset", {
        version: "1.10.3",
        options: {
            items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
        },
        _create: function() {
            this.element.addClass("ui-buttonset");
        },
        _init: function() {
            this.refresh();
        },
        _setOption: function(key, value) {
            if (key === "disabled") {
                this.buttons.button("option", key, value);
            }
            this._super(key, value);
        },
        refresh: function() {
            var rtl = this.element.css("direction") === "rtl";
            this.buttons = this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function() {
                return $(this).button("widget")[0];
            }).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(rtl ? "ui-corner-right" : "ui-corner-left").end().filter(":last").addClass(rtl ? "ui-corner-left" : "ui-corner-right").end().end();
        },
        _destroy: function() {
            this.element.removeClass("ui-buttonset");
            this.buttons.map(function() {
                return $(this).button("widget")[0];
            }).removeClass("ui-corner-left ui-corner-right").end().button("destroy");
        }
    });
})(jQuery);

(function($, undefined) {
    $.extend($.ui, {
        datepicker: {
            version: "1.10.3"
        }
    });
    var PROP_NAME = "datepicker", instActive;
    function Datepicker() {
        this._curInst = null;
        this._keyEvent = false;
        this._disabledInputs = [];
        this._datepickerShowing = false;
        this._inDialog = false;
        this._mainDivId = "ui-datepicker-div";
        this._inlineClass = "ui-datepicker-inline";
        this._appendClass = "ui-datepicker-append";
        this._triggerClass = "ui-datepicker-trigger";
        this._dialogClass = "ui-datepicker-dialog";
        this._disableClass = "ui-datepicker-disabled";
        this._unselectableClass = "ui-datepicker-unselectable";
        this._currentClass = "ui-datepicker-current-day";
        this._dayOverClass = "ui-datepicker-days-cell-over";
        this.regional = [];
        this.regional[""] = {
            closeText: "Done",
            prevText: "Prev",
            nextText: "Next",
            currentText: "Today",
            monthNames: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
            monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
            dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
            dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
            dayNamesMin: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ],
            weekHeader: "Wk",
            dateFormat: "mm/dd/yy",
            firstDay: 0,
            isRTL: false,
            showMonthAfterYear: false,
            yearSuffix: ""
        };
        this._defaults = {
            showOn: "focus",
            showAnim: "fadeIn",
            showOptions: {},
            defaultDate: null,
            appendText: "",
            buttonText: "...",
            buttonImage: "",
            buttonImageOnly: false,
            hideIfNoPrevNext: false,
            navigationAsDateFormat: false,
            gotoCurrent: false,
            changeMonth: false,
            changeYear: false,
            yearRange: "c-10:c+10",
            showOtherMonths: false,
            selectOtherMonths: false,
            showWeek: false,
            calculateWeek: this.iso8601Week,
            shortYearCutoff: "+10",
            minDate: null,
            maxDate: null,
            duration: "fast",
            beforeShowDay: null,
            beforeShow: null,
            onSelect: null,
            onChangeMonthYear: null,
            onClose: null,
            numberOfMonths: 1,
            showCurrentAtPos: 0,
            stepMonths: 1,
            stepBigMonths: 12,
            altField: "",
            altFormat: "",
            constrainInput: true,
            showButtonPanel: false,
            autoSize: false,
            disabled: false
        };
        $.extend(this._defaults, this.regional[""]);
        this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
    }
    $.extend(Datepicker.prototype, {
        markerClassName: "hasDatepicker",
        maxRows: 4,
        _widgetDatepicker: function() {
            return this.dpDiv;
        },
        setDefaults: function(settings) {
            extendRemove(this._defaults, settings || {});
            return this;
        },
        _attachDatepicker: function(target, settings) {
            var nodeName, inline, inst;
            nodeName = target.nodeName.toLowerCase();
            inline = nodeName === "div" || nodeName === "span";
            if (!target.id) {
                this.uuid += 1;
                target.id = "dp" + this.uuid;
            }
            inst = this._newInst($(target), inline);
            inst.settings = $.extend({}, settings || {});
            if (nodeName === "input") {
                this._connectDatepicker(target, inst);
            } else if (inline) {
                this._inlineDatepicker(target, inst);
            }
        },
        _newInst: function(target, inline) {
            var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1");
            return {
                id: id,
                input: target,
                selectedDay: 0,
                selectedMonth: 0,
                selectedYear: 0,
                drawMonth: 0,
                drawYear: 0,
                inline: inline,
                dpDiv: !inline ? this.dpDiv : bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))
            };
        },
        _connectDatepicker: function(target, inst) {
            var input = $(target);
            inst.append = $([]);
            inst.trigger = $([]);
            if (input.hasClass(this.markerClassName)) {
                return;
            }
            this._attachments(input, inst);
            input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp);
            this._autoSize(inst);
            $.data(target, PROP_NAME, inst);
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
        },
        _attachments: function(input, inst) {
            var showOn, buttonText, buttonImage, appendText = this._get(inst, "appendText"), isRTL = this._get(inst, "isRTL");
            if (inst.append) {
                inst.append.remove();
            }
            if (appendText) {
                inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
                input[isRTL ? "before" : "after"](inst.append);
            }
            input.unbind("focus", this._showDatepicker);
            if (inst.trigger) {
                inst.trigger.remove();
            }
            showOn = this._get(inst, "showOn");
            if (showOn === "focus" || showOn === "both") {
                input.focus(this._showDatepicker);
            }
            if (showOn === "button" || showOn === "both") {
                buttonText = this._get(inst, "buttonText");
                buttonImage = this._get(inst, "buttonImage");
                inst.trigger = $(this._get(inst, "buttonImageOnly") ? $("<img/>").addClass(this._triggerClass).attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                }) : $("<button type='button'></button>").addClass(this._triggerClass).html(!buttonImage ? buttonText : $("<img/>").attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                })));
                input[isRTL ? "before" : "after"](inst.trigger);
                inst.trigger.click(function() {
                    if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                        $.datepicker._hideDatepicker();
                    } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                        $.datepicker._hideDatepicker();
                        $.datepicker._showDatepicker(input[0]);
                    } else {
                        $.datepicker._showDatepicker(input[0]);
                    }
                    return false;
                });
            }
        },
        _autoSize: function(inst) {
            if (this._get(inst, "autoSize") && !inst.inline) {
                var findMax, max, maxI, i, date = new Date(2009, 12 - 1, 20), dateFormat = this._get(inst, "dateFormat");
                if (dateFormat.match(/[DM]/)) {
                    findMax = function(names) {
                        max = 0;
                        maxI = 0;
                        for (i = 0; i < names.length; i++) {
                            if (names[i].length > max) {
                                max = names[i].length;
                                maxI = i;
                            }
                        }
                        return maxI;
                    };
                    date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? "monthNames" : "monthNamesShort")));
                    date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - date.getDay());
                }
                inst.input.attr("size", this._formatDate(inst, date).length);
            }
        },
        _inlineDatepicker: function(target, inst) {
            var divSpan = $(target);
            if (divSpan.hasClass(this.markerClassName)) {
                return;
            }
            divSpan.addClass(this.markerClassName).append(inst.dpDiv);
            $.data(target, PROP_NAME, inst);
            this._setDate(inst, this._getDefaultDate(inst), true);
            this._updateDatepicker(inst);
            this._updateAlternate(inst);
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
            inst.dpDiv.css("display", "block");
        },
        _dialogDatepicker: function(input, date, onSelect, settings, pos) {
            var id, browserWidth, browserHeight, scrollX, scrollY, inst = this._dialogInst;
            if (!inst) {
                this.uuid += 1;
                id = "dp" + this.uuid;
                this._dialogInput = $("<input type='text' id='" + id + "' style='position: absolute; top: -100px; width: 0px;'/>");
                this._dialogInput.keydown(this._doKeyDown);
                $("body").append(this._dialogInput);
                inst = this._dialogInst = this._newInst(this._dialogInput, false);
                inst.settings = {};
                $.data(this._dialogInput[0], PROP_NAME, inst);
            }
            extendRemove(inst.settings, settings || {});
            date = date && date.constructor === Date ? this._formatDate(inst, date) : date;
            this._dialogInput.val(date);
            this._pos = pos ? pos.length ? pos : [ pos.pageX, pos.pageY ] : null;
            if (!this._pos) {
                browserWidth = document.documentElement.clientWidth;
                browserHeight = document.documentElement.clientHeight;
                scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                this._pos = [ browserWidth / 2 - 100 + scrollX, browserHeight / 2 - 150 + scrollY ];
            }
            this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px");
            inst.settings.onSelect = onSelect;
            this._inDialog = true;
            this.dpDiv.addClass(this._dialogClass);
            this._showDatepicker(this._dialogInput[0]);
            if ($.blockUI) {
                $.blockUI(this.dpDiv);
            }
            $.data(this._dialogInput[0], PROP_NAME, inst);
            return this;
        },
        _destroyDatepicker: function(target) {
            var nodeName, $target = $(target), inst = $.data(target, PROP_NAME);
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            $.removeData(target, PROP_NAME);
            if (nodeName === "input") {
                inst.append.remove();
                inst.trigger.remove();
                $target.removeClass(this.markerClassName).unbind("focus", this._showDatepicker).unbind("keydown", this._doKeyDown).unbind("keypress", this._doKeyPress).unbind("keyup", this._doKeyUp);
            } else if (nodeName === "div" || nodeName === "span") {
                $target.removeClass(this.markerClassName).empty();
            }
        },
        _enableDatepicker: function(target) {
            var nodeName, inline, $target = $(target), inst = $.data(target, PROP_NAME);
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = false;
                inst.trigger.filter("button").each(function() {
                    this.disabled = false;
                }).end().filter("img").css({
                    opacity: "1.0",
                    cursor: ""
                });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().removeClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", false);
            }
            this._disabledInputs = $.map(this._disabledInputs, function(value) {
                return value === target ? null : value;
            });
        },
        _disableDatepicker: function(target) {
            var nodeName, inline, $target = $(target), inst = $.data(target, PROP_NAME);
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = true;
                inst.trigger.filter("button").each(function() {
                    this.disabled = true;
                }).end().filter("img").css({
                    opacity: "0.5",
                    cursor: "default"
                });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().addClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", true);
            }
            this._disabledInputs = $.map(this._disabledInputs, function(value) {
                return value === target ? null : value;
            });
            this._disabledInputs[this._disabledInputs.length] = target;
        },
        _isDisabledDatepicker: function(target) {
            if (!target) {
                return false;
            }
            for (var i = 0; i < this._disabledInputs.length; i++) {
                if (this._disabledInputs[i] === target) {
                    return true;
                }
            }
            return false;
        },
        _getInst: function(target) {
            try {
                return $.data(target, PROP_NAME);
            } catch (err) {
                throw "Missing instance data for this datepicker";
            }
        },
        _optionDatepicker: function(target, name, value) {
            var settings, date, minDate, maxDate, inst = this._getInst(target);
            if (arguments.length === 2 && typeof name === "string") {
                return name === "defaults" ? $.extend({}, $.datepicker._defaults) : inst ? name === "all" ? $.extend({}, inst.settings) : this._get(inst, name) : null;
            }
            settings = name || {};
            if (typeof name === "string") {
                settings = {};
                settings[name] = value;
            }
            if (inst) {
                if (this._curInst === inst) {
                    this._hideDatepicker();
                }
                date = this._getDateDatepicker(target, true);
                minDate = this._getMinMaxDate(inst, "min");
                maxDate = this._getMinMaxDate(inst, "max");
                extendRemove(inst.settings, settings);
                if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                    inst.settings.minDate = this._formatDate(inst, minDate);
                }
                if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                    inst.settings.maxDate = this._formatDate(inst, maxDate);
                }
                if ("disabled" in settings) {
                    if (settings.disabled) {
                        this._disableDatepicker(target);
                    } else {
                        this._enableDatepicker(target);
                    }
                }
                this._attachments($(target), inst);
                this._autoSize(inst);
                this._setDate(inst, date);
                this._updateAlternate(inst);
                this._updateDatepicker(inst);
            }
        },
        _changeDatepicker: function(target, name, value) {
            this._optionDatepicker(target, name, value);
        },
        _refreshDatepicker: function(target) {
            var inst = this._getInst(target);
            if (inst) {
                this._updateDatepicker(inst);
            }
        },
        _setDateDatepicker: function(target, date) {
            var inst = this._getInst(target);
            if (inst) {
                this._setDate(inst, date);
                this._updateDatepicker(inst);
                this._updateAlternate(inst);
            }
        },
        _getDateDatepicker: function(target, noDefault) {
            var inst = this._getInst(target);
            if (inst && !inst.inline) {
                this._setDateFromField(inst, noDefault);
            }
            return inst ? this._getDate(inst) : null;
        },
        _doKeyDown: function(event) {
            var onSelect, dateStr, sel, inst = $.datepicker._getInst(event.target), handled = true, isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
            inst._keyEvent = true;
            if ($.datepicker._datepickerShowing) {
                switch (event.keyCode) {
                  case 9:
                    $.datepicker._hideDatepicker();
                    handled = false;
                    break;

                  case 13:
                    sel = $("td." + $.datepicker._dayOverClass + ":not(." + $.datepicker._currentClass + ")", inst.dpDiv);
                    if (sel[0]) {
                        $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                    }
                    onSelect = $.datepicker._get(inst, "onSelect");
                    if (onSelect) {
                        dateStr = $.datepicker._formatDate(inst);
                        onSelect.apply(inst.input ? inst.input[0] : null, [ dateStr, inst ]);
                    } else {
                        $.datepicker._hideDatepicker();
                    }
                    return false;

                  case 27:
                    $.datepicker._hideDatepicker();
                    break;

                  case 33:
                    $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                    break;

                  case 34:
                    $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                    break;

                  case 35:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._clearDate(event.target);
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  case 36:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._gotoToday(event.target);
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  case 37:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, isRTL ? +1 : -1, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    if (event.originalEvent.altKey) {
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                    }
                    break;

                  case 38:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, -7, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  case 39:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, isRTL ? -1 : +1, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    if (event.originalEvent.altKey) {
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                    }
                    break;

                  case 40:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, +7, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  default:
                    handled = false;
                }
            } else if (event.keyCode === 36 && event.ctrlKey) {
                $.datepicker._showDatepicker(this);
            } else {
                handled = false;
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            }
        },
        _doKeyPress: function(event) {
            var chars, chr, inst = $.datepicker._getInst(event.target);
            if ($.datepicker._get(inst, "constrainInput")) {
                chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
                chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
                return event.ctrlKey || event.metaKey || chr < " " || !chars || chars.indexOf(chr) > -1;
            }
        },
        _doKeyUp: function(event) {
            var date, inst = $.datepicker._getInst(event.target);
            if (inst.input.val() !== inst.lastVal) {
                try {
                    date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst));
                    if (date) {
                        $.datepicker._setDateFromField(inst);
                        $.datepicker._updateAlternate(inst);
                        $.datepicker._updateDatepicker(inst);
                    }
                } catch (err) {}
            }
            return true;
        },
        _showDatepicker: function(input) {
            input = input.target || input;
            if (input.nodeName.toLowerCase() !== "input") {
                input = $("input", input.parentNode)[0];
            }
            if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
                return;
            }
            var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;
            inst = $.datepicker._getInst(input);
            if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                $.datepicker._curInst.dpDiv.stop(true, true);
                if (inst && $.datepicker._datepickerShowing) {
                    $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
                }
            }
            beforeShow = $.datepicker._get(inst, "beforeShow");
            beforeShowSettings = beforeShow ? beforeShow.apply(input, [ input, inst ]) : {};
            if (beforeShowSettings === false) {
                return;
            }
            extendRemove(inst.settings, beforeShowSettings);
            inst.lastVal = null;
            $.datepicker._lastInput = input;
            $.datepicker._setDateFromField(inst);
            if ($.datepicker._inDialog) {
                input.value = "";
            }
            if (!$.datepicker._pos) {
                $.datepicker._pos = $.datepicker._findPos(input);
                $.datepicker._pos[1] += input.offsetHeight;
            }
            isFixed = false;
            $(input).parents().each(function() {
                isFixed |= $(this).css("position") === "fixed";
                return !isFixed;
            });
            offset = {
                left: $.datepicker._pos[0],
                top: $.datepicker._pos[1]
            };
            $.datepicker._pos = null;
            inst.dpDiv.empty();
            inst.dpDiv.css({
                position: "absolute",
                display: "block",
                top: "-1000px"
            });
            $.datepicker._updateDatepicker(inst);
            offset = $.datepicker._checkOffset(inst, offset, isFixed);
            inst.dpDiv.css({
                position: $.datepicker._inDialog && $.blockUI ? "static" : isFixed ? "fixed" : "absolute",
                display: "none",
                left: offset.left + "px",
                top: offset.top + "px"
            });
            if (!inst.inline) {
                showAnim = $.datepicker._get(inst, "showAnim");
                duration = $.datepicker._get(inst, "duration");
                inst.dpDiv.zIndex($(input).zIndex() + 1);
                $.datepicker._datepickerShowing = true;
                if ($.effects && $.effects.effect[showAnim]) {
                    inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
                } else {
                    inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
                }
                if ($.datepicker._shouldFocusInput(inst)) {
                    inst.input.focus();
                }
                $.datepicker._curInst = inst;
            }
        },
        _updateDatepicker: function(inst) {
            this.maxRows = 4;
            instActive = inst;
            inst.dpDiv.empty().append(this._generateHTML(inst));
            this._attachHandlers(inst);
            inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();
            var origyearshtml, numMonths = this._getNumberOfMonths(inst), cols = numMonths[1], width = 17;
            inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
            if (cols > 1) {
                inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", width * cols + "em");
            }
            inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") + "Class"]("ui-datepicker-multi");
            inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl");
            if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
                inst.input.focus();
            }
            if (inst.yearshtml) {
                origyearshtml = inst.yearshtml;
                setTimeout(function() {
                    if (origyearshtml === inst.yearshtml && inst.yearshtml) {
                        inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
                    }
                    origyearshtml = inst.yearshtml = null;
                }, 0);
            }
        },
        _shouldFocusInput: function(inst) {
            return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus");
        },
        _checkOffset: function(inst, offset, isFixed) {
            var dpWidth = inst.dpDiv.outerWidth(), dpHeight = inst.dpDiv.outerHeight(), inputWidth = inst.input ? inst.input.outerWidth() : 0, inputHeight = inst.input ? inst.input.outerHeight() : 0, viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()), viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
            offset.left -= this._get(inst, "isRTL") ? dpWidth - inputWidth : 0;
            offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;
            offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0;
            offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
            offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0);
            return offset;
        },
        _findPos: function(obj) {
            var position, inst = this._getInst(obj), isRTL = this._get(inst, "isRTL");
            while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
                obj = obj[isRTL ? "previousSibling" : "nextSibling"];
            }
            position = $(obj).offset();
            return [ position.left, position.top ];
        },
        _hideDatepicker: function(input) {
            var showAnim, duration, postProcess, onClose, inst = this._curInst;
            if (!inst || input && inst !== $.data(input, PROP_NAME)) {
                return;
            }
            if (this._datepickerShowing) {
                showAnim = this._get(inst, "showAnim");
                duration = this._get(inst, "duration");
                postProcess = function() {
                    $.datepicker._tidyDialog(inst);
                };
                if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
                    inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
                } else {
                    inst.dpDiv[showAnim === "slideDown" ? "slideUp" : showAnim === "fadeIn" ? "fadeOut" : "hide"](showAnim ? duration : null, postProcess);
                }
                if (!showAnim) {
                    postProcess();
                }
                this._datepickerShowing = false;
                onClose = this._get(inst, "onClose");
                if (onClose) {
                    onClose.apply(inst.input ? inst.input[0] : null, [ inst.input ? inst.input.val() : "", inst ]);
                }
                this._lastInput = null;
                if (this._inDialog) {
                    this._dialogInput.css({
                        position: "absolute",
                        left: "0",
                        top: "-100px"
                    });
                    if ($.blockUI) {
                        $.unblockUI();
                        $("body").append(this.dpDiv);
                    }
                }
                this._inDialog = false;
            }
        },
        _tidyDialog: function(inst) {
            inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
        },
        _checkExternalClick: function(event) {
            if (!$.datepicker._curInst) {
                return;
            }
            var $target = $(event.target), inst = $.datepicker._getInst($target[0]);
            if ($target[0].id !== $.datepicker._mainDivId && $target.parents("#" + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest("." + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) {
                $.datepicker._hideDatepicker();
            }
        },
        _adjustDate: function(id, offset, period) {
            var target = $(id), inst = this._getInst(target[0]);
            if (this._isDisabledDatepicker(target[0])) {
                return;
            }
            this._adjustInstDate(inst, offset + (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), period);
            this._updateDatepicker(inst);
        },
        _gotoToday: function(id) {
            var date, target = $(id), inst = this._getInst(target[0]);
            if (this._get(inst, "gotoCurrent") && inst.currentDay) {
                inst.selectedDay = inst.currentDay;
                inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                inst.drawYear = inst.selectedYear = inst.currentYear;
            } else {
                date = new Date();
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
            }
            this._notifyChange(inst);
            this._adjustDate(target);
        },
        _selectMonthYear: function(id, select, period) {
            var target = $(id), inst = this._getInst(target[0]);
            inst["selected" + (period === "M" ? "Month" : "Year")] = inst["draw" + (period === "M" ? "Month" : "Year")] = parseInt(select.options[select.selectedIndex].value, 10);
            this._notifyChange(inst);
            this._adjustDate(target);
        },
        _selectDay: function(id, month, year, td) {
            var inst, target = $(id);
            if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                return;
            }
            inst = this._getInst(target[0]);
            inst.selectedDay = inst.currentDay = $("a", td).html();
            inst.selectedMonth = inst.currentMonth = month;
            inst.selectedYear = inst.currentYear = year;
            this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
        },
        _clearDate: function(id) {
            var target = $(id);
            this._selectDate(target, "");
        },
        _selectDate: function(id, dateStr) {
            var onSelect, target = $(id), inst = this._getInst(target[0]);
            dateStr = dateStr != null ? dateStr : this._formatDate(inst);
            if (inst.input) {
                inst.input.val(dateStr);
            }
            this._updateAlternate(inst);
            onSelect = this._get(inst, "onSelect");
            if (onSelect) {
                onSelect.apply(inst.input ? inst.input[0] : null, [ dateStr, inst ]);
            } else if (inst.input) {
                inst.input.trigger("change");
            }
            if (inst.inline) {
                this._updateDatepicker(inst);
            } else {
                this._hideDatepicker();
                this._lastInput = inst.input[0];
                if (typeof inst.input[0] !== "object") {
                    inst.input.focus();
                }
                this._lastInput = null;
            }
        },
        _updateAlternate: function(inst) {
            var altFormat, date, dateStr, altField = this._get(inst, "altField");
            if (altField) {
                altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
                date = this._getDate(inst);
                dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
                $(altField).each(function() {
                    $(this).val(dateStr);
                });
            }
        },
        noWeekends: function(date) {
            var day = date.getDay();
            return [ day > 0 && day < 6, "" ];
        },
        iso8601Week: function(date) {
            var time, checkDate = new Date(date.getTime());
            checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
            time = checkDate.getTime();
            checkDate.setMonth(0);
            checkDate.setDate(1);
            return Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
        },
        parseDate: function(format, value, settings) {
            if (format == null || value == null) {
                throw "Invalid arguments";
            }
            value = typeof value === "object" ? value.toString() : value + "";
            if (value === "") {
                return null;
            }
            var iFormat, dim, extra, iValue = 0, shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff, shortYearCutoff = typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10), dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, year = -1, month = -1, day = -1, doy = -1, literal = false, date, lookAhead = function(match) {
                var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                if (matches) {
                    iFormat++;
                }
                return matches;
            }, getNumber = function(match) {
                var isDoubled = lookAhead(match), size = match === "@" ? 14 : match === "!" ? 20 : match === "y" && isDoubled ? 4 : match === "o" ? 3 : 2, digits = new RegExp("^\\d{1," + size + "}"), num = value.substring(iValue).match(digits);
                if (!num) {
                    throw "Missing number at position " + iValue;
                }
                iValue += num[0].length;
                return parseInt(num[0], 10);
            }, getName = function(match, shortNames, longNames) {
                var index = -1, names = $.map(lookAhead(match) ? longNames : shortNames, function(v, k) {
                    return [ [ k, v ] ];
                }).sort(function(a, b) {
                    return -(a[1].length - b[1].length);
                });
                $.each(names, function(i, pair) {
                    var name = pair[1];
                    if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                        index = pair[0];
                        iValue += name.length;
                        return false;
                    }
                });
                if (index !== -1) {
                    return index + 1;
                } else {
                    throw "Unknown name at position " + iValue;
                }
            }, checkLiteral = function() {
                if (value.charAt(iValue) !== format.charAt(iFormat)) {
                    throw "Unexpected literal at position " + iValue;
                }
                iValue++;
            };
            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        checkLiteral();
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                      case "d":
                        day = getNumber("d");
                        break;

                      case "D":
                        getName("D", dayNamesShort, dayNames);
                        break;

                      case "o":
                        doy = getNumber("o");
                        break;

                      case "m":
                        month = getNumber("m");
                        break;

                      case "M":
                        month = getName("M", monthNamesShort, monthNames);
                        break;

                      case "y":
                        year = getNumber("y");
                        break;

                      case "@":
                        date = new Date(getNumber("@"));
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;

                      case "!":
                        date = new Date((getNumber("!") - this._ticksTo1970) / 1e4);
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;

                      case "'":
                        if (lookAhead("'")) {
                            checkLiteral();
                        } else {
                            literal = true;
                        }
                        break;

                      default:
                        checkLiteral();
                    }
                }
            }
            if (iValue < value.length) {
                extra = value.substr(iValue);
                if (!/^\s+/.test(extra)) {
                    throw "Extra/unparsed characters found in date: " + extra;
                }
            }
            if (year === -1) {
                year = new Date().getFullYear();
            } else if (year < 100) {
                year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
            }
            if (doy > -1) {
                month = 1;
                day = doy;
                do {
                    dim = this._getDaysInMonth(year, month - 1);
                    if (day <= dim) {
                        break;
                    }
                    month++;
                    day -= dim;
                } while (true);
            }
            date = this._daylightSavingAdjust(new Date(year, month - 1, day));
            if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
                throw "Invalid date";
            }
            return date;
        },
        ATOM: "yy-mm-dd",
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y",
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd",
        _ticksTo1970: ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 1e7,
        formatDate: function(format, date, settings) {
            if (!date) {
                return "";
            }
            var iFormat, dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, lookAhead = function(match) {
                var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                if (matches) {
                    iFormat++;
                }
                return matches;
            }, formatNumber = function(match, value, len) {
                var num = "" + value;
                if (lookAhead(match)) {
                    while (num.length < len) {
                        num = "0" + num;
                    }
                }
                return num;
            }, formatName = function(match, value, shortNames, longNames) {
                return lookAhead(match) ? longNames[value] : shortNames[value];
            }, output = "", literal = false;
            if (date) {
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                            literal = false;
                        } else {
                            output += format.charAt(iFormat);
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                          case "d":
                            output += formatNumber("d", date.getDate(), 2);
                            break;

                          case "D":
                            output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                            break;

                          case "o":
                            output += formatNumber("o", Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 864e5), 3);
                            break;

                          case "m":
                            output += formatNumber("m", date.getMonth() + 1, 2);
                            break;

                          case "M":
                            output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                            break;

                          case "y":
                            output += lookAhead("y") ? date.getFullYear() : (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100;
                            break;

                          case "@":
                            output += date.getTime();
                            break;

                          case "!":
                            output += date.getTime() * 1e4 + this._ticksTo1970;
                            break;

                          case "'":
                            if (lookAhead("'")) {
                                output += "'";
                            } else {
                                literal = true;
                            }
                            break;

                          default:
                            output += format.charAt(iFormat);
                        }
                    }
                }
            }
            return output;
        },
        _possibleChars: function(format) {
            var iFormat, chars = "", literal = false, lookAhead = function(match) {
                var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                if (matches) {
                    iFormat++;
                }
                return matches;
            };
            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        chars += format.charAt(iFormat);
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                      case "d":
                      case "m":
                      case "y":
                      case "@":
                        chars += "0123456789";
                        break;

                      case "D":
                      case "M":
                        return null;

                      case "'":
                        if (lookAhead("'")) {
                            chars += "'";
                        } else {
                            literal = true;
                        }
                        break;

                      default:
                        chars += format.charAt(iFormat);
                    }
                }
            }
            return chars;
        },
        _get: function(inst, name) {
            return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
        },
        _setDateFromField: function(inst, noDefault) {
            if (inst.input.val() === inst.lastVal) {
                return;
            }
            var dateFormat = this._get(inst, "dateFormat"), dates = inst.lastVal = inst.input ? inst.input.val() : null, defaultDate = this._getDefaultDate(inst), date = defaultDate, settings = this._getFormatConfig(inst);
            try {
                date = this.parseDate(dateFormat, dates, settings) || defaultDate;
            } catch (event) {
                dates = noDefault ? "" : dates;
            }
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            inst.currentDay = dates ? date.getDate() : 0;
            inst.currentMonth = dates ? date.getMonth() : 0;
            inst.currentYear = dates ? date.getFullYear() : 0;
            this._adjustInstDate(inst);
        },
        _getDefaultDate: function(inst) {
            return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
        },
        _determineDate: function(inst, date, defaultDate) {
            var offsetNumeric = function(offset) {
                var date = new Date();
                date.setDate(date.getDate() + offset);
                return date;
            }, offsetString = function(offset) {
                try {
                    return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), offset, $.datepicker._getFormatConfig(inst));
                } catch (e) {}
                var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(), year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, matches = pattern.exec(offset);
                while (matches) {
                    switch (matches[2] || "d") {
                      case "d":
                      case "D":
                        day += parseInt(matches[1], 10);
                        break;

                      case "w":
                      case "W":
                        day += parseInt(matches[1], 10) * 7;
                        break;

                      case "m":
                      case "M":
                        month += parseInt(matches[1], 10);
                        day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                        break;

                      case "y":
                      case "Y":
                        year += parseInt(matches[1], 10);
                        day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                        break;
                    }
                    matches = pattern.exec(offset);
                }
                return new Date(year, month, day);
            }, newDate = date == null || date === "" ? defaultDate : typeof date === "string" ? offsetString(date) : typeof date === "number" ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());
            newDate = newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate;
            if (newDate) {
                newDate.setHours(0);
                newDate.setMinutes(0);
                newDate.setSeconds(0);
                newDate.setMilliseconds(0);
            }
            return this._daylightSavingAdjust(newDate);
        },
        _daylightSavingAdjust: function(date) {
            if (!date) {
                return null;
            }
            date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
            return date;
        },
        _setDate: function(inst, date, noChange) {
            var clear = !date, origMonth = inst.selectedMonth, origYear = inst.selectedYear, newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
            inst.selectedDay = inst.currentDay = newDate.getDate();
            inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
            inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
            if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
                this._notifyChange(inst);
            }
            this._adjustInstDate(inst);
            if (inst.input) {
                inst.input.val(clear ? "" : this._formatDate(inst));
            }
        },
        _getDate: function(inst) {
            var startDate = !inst.currentYear || inst.input && inst.input.val() === "" ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
            return startDate;
        },
        _attachHandlers: function(inst) {
            var stepMonths = this._get(inst, "stepMonths"), id = "#" + inst.id.replace(/\\\\/g, "\\");
            inst.dpDiv.find("[data-handler]").map(function() {
                var handler = {
                    prev: function() {
                        $.datepicker._adjustDate(id, -stepMonths, "M");
                    },
                    next: function() {
                        $.datepicker._adjustDate(id, +stepMonths, "M");
                    },
                    hide: function() {
                        $.datepicker._hideDatepicker();
                    },
                    today: function() {
                        $.datepicker._gotoToday(id);
                    },
                    selectDay: function() {
                        $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
                        return false;
                    },
                    selectMonth: function() {
                        $.datepicker._selectMonthYear(id, this, "M");
                        return false;
                    },
                    selectYear: function() {
                        $.datepicker._selectMonthYear(id, this, "Y");
                        return false;
                    }
                };
                $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
            });
        },
        _generateHTML: function(inst) {
            var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin, monthNames, monthNamesShort, beforeShowDay, showOtherMonths, selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate, cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows, printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date(), today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), isRTL = this._get(inst, "isRTL"), showButtonPanel = this._get(inst, "showButtonPanel"), hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"), navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"), numMonths = this._getNumberOfMonths(inst), showCurrentAtPos = this._get(inst, "showCurrentAtPos"), stepMonths = this._get(inst, "stepMonths"), isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1, currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)), minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), drawMonth = inst.drawMonth - showCurrentAtPos, drawYear = inst.drawYear;
            if (drawMonth < 0) {
                drawMonth += 12;
                drawYear--;
            }
            if (maxDate) {
                maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));
                maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;
                while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                    drawMonth--;
                    if (drawMonth < 0) {
                        drawMonth = 11;
                        drawYear--;
                    }
                }
            }
            inst.drawMonth = drawMonth;
            inst.drawYear = drawYear;
            prevText = this._get(inst, "prevText");
            prevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst));
            prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" + " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>";
            nextText = this._get(inst, "nextText");
            nextText = !navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst));
            next = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" + " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>";
            currentText = this._get(inst, "currentText");
            gotoDate = this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today;
            currentText = !navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));
            controls = !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(inst, "closeText") + "</button>" : "";
            buttonPanel = showButtonPanel ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") + (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" + ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";
            firstDay = parseInt(this._get(inst, "firstDay"), 10);
            firstDay = isNaN(firstDay) ? 0 : firstDay;
            showWeek = this._get(inst, "showWeek");
            dayNames = this._get(inst, "dayNames");
            dayNamesMin = this._get(inst, "dayNamesMin");
            monthNames = this._get(inst, "monthNames");
            monthNamesShort = this._get(inst, "monthNamesShort");
            beforeShowDay = this._get(inst, "beforeShowDay");
            showOtherMonths = this._get(inst, "showOtherMonths");
            selectOtherMonths = this._get(inst, "selectOtherMonths");
            defaultDate = this._getDefaultDate(inst);
            html = "";
            dow;
            for (row = 0; row < numMonths[0]; row++) {
                group = "";
                this.maxRows = 4;
                for (col = 0; col < numMonths[1]; col++) {
                    selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                    cornerClass = " ui-corner-all";
                    calender = "";
                    if (isMultiMonth) {
                        calender += "<div class='ui-datepicker-group";
                        if (numMonths[1] > 1) {
                            switch (col) {
                              case 0:
                                calender += " ui-datepicker-group-first";
                                cornerClass = " ui-corner-" + (isRTL ? "right" : "left");
                                break;

                              case numMonths[1] - 1:
                                calender += " ui-datepicker-group-last";
                                cornerClass = " ui-corner-" + (isRTL ? "left" : "right");
                                break;

                              default:
                                calender += " ui-datepicker-group-middle";
                                cornerClass = "";
                                break;
                            }
                        }
                        calender += "'>";
                    }
                    calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" + (/all|left/.test(cornerClass) && row === 0 ? isRTL ? next : prev : "") + (/all|right/.test(cornerClass) && row === 0 ? isRTL ? prev : next : "") + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + "</div><table class='ui-datepicker-calendar'><thead>" + "<tr>";
                    thead = showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "";
                    for (dow = 0; dow < 7; dow++) {
                        day = (dow + firstDay) % 7;
                        thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" + "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                    }
                    calender += thead + "</tr></thead><tbody>";
                    daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                    if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                        inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                    }
                    leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                    curRows = Math.ceil((leadDays + daysInMonth) / 7);
                    numRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows;
                    this.maxRows = numRows;
                    printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                    for (dRow = 0; dRow < numRows; dRow++) {
                        calender += "<tr>";
                        tbody = !showWeek ? "" : "<td class='ui-datepicker-week-col'>" + this._get(inst, "calculateWeek")(printDate) + "</td>";
                        for (dow = 0; dow < 7; dow++) {
                            daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [ printDate ]) : [ true, "" ];
                            otherMonth = printDate.getMonth() !== drawMonth;
                            unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && printDate < minDate || maxDate && printDate > maxDate;
                            tbody += "<td class='" + ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (otherMonth ? " ui-datepicker-other-month" : "") + (printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ? " " + this._dayOverClass : "") + (unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") + (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + (otherMonth && !showOtherMonths ? "&#xa0;" : unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" + (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") + (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + (otherMonth ? " ui-priority-secondary" : "") + "' href='#'>" + printDate.getDate() + "</a>") + "</td>";
                            printDate.setDate(printDate.getDate() + 1);
                            printDate = this._daylightSavingAdjust(printDate);
                        }
                        calender += tbody + "</tr>";
                    }
                    drawMonth++;
                    if (drawMonth > 11) {
                        drawMonth = 0;
                        drawYear++;
                    }
                    calender += "</tbody></table>" + (isMultiMonth ? "</div>" + (numMonths[0] > 0 && col === numMonths[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
                    group += calender;
                }
                html += group;
            }
            html += buttonPanel;
            inst._keyEvent = false;
            return html;
        },
        _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
            var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, changeMonth = this._get(inst, "changeMonth"), changeYear = this._get(inst, "changeYear"), showMonthAfterYear = this._get(inst, "showMonthAfterYear"), html = "<div class='ui-datepicker-title'>", monthHtml = "";
            if (secondary || !changeMonth) {
                monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
            } else {
                inMinYear = minDate && minDate.getFullYear() === drawYear;
                inMaxYear = maxDate && maxDate.getFullYear() === drawYear;
                monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
                for (month = 0; month < 12; month++) {
                    if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                        monthHtml += "<option value='" + month + "'" + (month === drawMonth ? " selected='selected'" : "") + ">" + monthNamesShort[month] + "</option>";
                    }
                }
                monthHtml += "</select>";
            }
            if (!showMonthAfterYear) {
                html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
            }
            if (!inst.yearshtml) {
                inst.yearshtml = "";
                if (secondary || !changeYear) {
                    html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                } else {
                    years = this._get(inst, "yearRange").split(":");
                    thisYear = new Date().getFullYear();
                    determineYear = function(value) {
                        var year = value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);
                        return isNaN(year) ? thisYear : year;
                    };
                    year = determineYear(years[0]);
                    endYear = Math.max(year, determineYear(years[1] || ""));
                    year = minDate ? Math.max(year, minDate.getFullYear()) : year;
                    endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;
                    inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                    for (;year <= endYear; year++) {
                        inst.yearshtml += "<option value='" + year + "'" + (year === drawYear ? " selected='selected'" : "") + ">" + year + "</option>";
                    }
                    inst.yearshtml += "</select>";
                    html += inst.yearshtml;
                    inst.yearshtml = null;
                }
            }
            html += this._get(inst, "yearSuffix");
            if (showMonthAfterYear) {
                html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
            }
            html += "</div>";
            return html;
        },
        _adjustInstDate: function(inst, offset, period) {
            var year = inst.drawYear + (period === "Y" ? offset : 0), month = inst.drawMonth + (period === "M" ? offset : 0), day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0), date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            if (period === "M" || period === "Y") {
                this._notifyChange(inst);
            }
        },
        _restrictMinMax: function(inst, date) {
            var minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), newDate = minDate && date < minDate ? minDate : date;
            return maxDate && newDate > maxDate ? maxDate : newDate;
        },
        _notifyChange: function(inst) {
            var onChange = this._get(inst, "onChangeMonthYear");
            if (onChange) {
                onChange.apply(inst.input ? inst.input[0] : null, [ inst.selectedYear, inst.selectedMonth + 1, inst ]);
            }
        },
        _getNumberOfMonths: function(inst) {
            var numMonths = this._get(inst, "numberOfMonths");
            return numMonths == null ? [ 1, 1 ] : typeof numMonths === "number" ? [ 1, numMonths ] : numMonths;
        },
        _getMinMaxDate: function(inst, minMax) {
            return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
        },
        _getDaysInMonth: function(year, month) {
            return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
        },
        _getFirstDayOfMonth: function(year, month) {
            return new Date(year, month, 1).getDay();
        },
        _canAdjustMonth: function(inst, offset, curYear, curMonth) {
            var numMonths = this._getNumberOfMonths(inst), date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
            if (offset < 0) {
                date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
            }
            return this._isInRange(inst, date);
        },
        _isInRange: function(inst, date) {
            var yearSplit, currentYear, minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), minYear = null, maxYear = null, years = this._get(inst, "yearRange");
            if (years) {
                yearSplit = years.split(":");
                currentYear = new Date().getFullYear();
                minYear = parseInt(yearSplit[0], 10);
                maxYear = parseInt(yearSplit[1], 10);
                if (yearSplit[0].match(/[+\-].*/)) {
                    minYear += currentYear;
                }
                if (yearSplit[1].match(/[+\-].*/)) {
                    maxYear += currentYear;
                }
            }
            return (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);
        },
        _getFormatConfig: function(inst) {
            var shortYearCutoff = this._get(inst, "shortYearCutoff");
            shortYearCutoff = typeof shortYearCutoff !== "string" ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10);
            return {
                shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get(inst, "dayNamesShort"),
                dayNames: this._get(inst, "dayNames"),
                monthNamesShort: this._get(inst, "monthNamesShort"),
                monthNames: this._get(inst, "monthNames")
            };
        },
        _formatDate: function(inst, day, month, year) {
            if (!day) {
                inst.currentDay = inst.selectedDay;
                inst.currentMonth = inst.selectedMonth;
                inst.currentYear = inst.selectedYear;
            }
            var date = day ? typeof day === "object" ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
            return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
        }
    });
    function bindHover(dpDiv) {
        var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return dpDiv.delegate(selector, "mouseout", function() {
            $(this).removeClass("ui-state-hover");
            if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                $(this).removeClass("ui-datepicker-prev-hover");
            }
            if (this.className.indexOf("ui-datepicker-next") !== -1) {
                $(this).removeClass("ui-datepicker-next-hover");
            }
        }).delegate(selector, "mouseover", function() {
            if (!$.datepicker._isDisabledDatepicker(instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
                $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
                $(this).addClass("ui-state-hover");
                if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                    $(this).addClass("ui-datepicker-prev-hover");
                }
                if (this.className.indexOf("ui-datepicker-next") !== -1) {
                    $(this).addClass("ui-datepicker-next-hover");
                }
            }
        });
    }
    function extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) {
            if (props[name] == null) {
                target[name] = props[name];
            }
        }
        return target;
    }
    $.fn.datepicker = function(options) {
        if (!this.length) {
            return this;
        }
        if (!$.datepicker.initialized) {
            $(document).mousedown($.datepicker._checkExternalClick);
            $.datepicker.initialized = true;
        }
        if ($("#" + $.datepicker._mainDivId).length === 0) {
            $("body").append($.datepicker.dpDiv);
        }
        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
            return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this[0] ].concat(otherArgs));
        }
        if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
            return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this[0] ].concat(otherArgs));
        }
        return this.each(function() {
            typeof options === "string" ? $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this ].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
        });
    };
    $.datepicker = new Datepicker();
    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = "1.10.3";
})(jQuery);

(function($, undefined) {
    var sizeRelatedOptions = {
        buttons: true,
        height: true,
        maxHeight: true,
        maxWidth: true,
        minHeight: true,
        minWidth: true,
        width: true
    }, resizableRelatedOptions = {
        maxHeight: true,
        maxWidth: true,
        minHeight: true,
        minWidth: true
    };
    $.widget("ui.dialog", {
        version: "1.10.3",
        options: {
            appendTo: "body",
            autoOpen: true,
            buttons: [],
            closeOnEscape: true,
            closeText: "close",
            dialogClass: "",
            draggable: true,
            hide: null,
            height: "auto",
            maxHeight: null,
            maxWidth: null,
            minHeight: 150,
            minWidth: 150,
            modal: false,
            position: {
                my: "center",
                at: "center",
                of: window,
                collision: "fit",
                using: function(pos) {
                    var topOffset = $(this).css(pos).offset().top;
                    if (topOffset < 0) {
                        $(this).css("top", pos.top - topOffset);
                    }
                }
            },
            resizable: true,
            show: null,
            title: null,
            width: 300,
            beforeClose: null,
            close: null,
            drag: null,
            dragStart: null,
            dragStop: null,
            focus: null,
            open: null,
            resize: null,
            resizeStart: null,
            resizeStop: null
        },
        _create: function() {
            this.originalCss = {
                display: this.element[0].style.display,
                width: this.element[0].style.width,
                minHeight: this.element[0].style.minHeight,
                maxHeight: this.element[0].style.maxHeight,
                height: this.element[0].style.height
            };
            this.originalPosition = {
                parent: this.element.parent(),
                index: this.element.parent().children().index(this.element)
            };
            this.originalTitle = this.element.attr("title");
            this.options.title = this.options.title || this.originalTitle;
            this._createWrapper();
            this.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(this.uiDialog);
            this._createTitlebar();
            this._createButtonPane();
            if (this.options.draggable && $.fn.draggable) {
                this._makeDraggable();
            }
            if (this.options.resizable && $.fn.resizable) {
                this._makeResizable();
            }
            this._isOpen = false;
        },
        _init: function() {
            if (this.options.autoOpen) {
                this.open();
            }
        },
        _appendTo: function() {
            var element = this.options.appendTo;
            if (element && (element.jquery || element.nodeType)) {
                return $(element);
            }
            return this.document.find(element || "body").eq(0);
        },
        _destroy: function() {
            var next, originalPosition = this.originalPosition;
            this._destroyOverlay();
            this.element.removeUniqueId().removeClass("ui-dialog-content ui-widget-content").css(this.originalCss).detach();
            this.uiDialog.stop(true, true).remove();
            if (this.originalTitle) {
                this.element.attr("title", this.originalTitle);
            }
            next = originalPosition.parent.children().eq(originalPosition.index);
            if (next.length && next[0] !== this.element[0]) {
                next.before(this.element);
            } else {
                originalPosition.parent.append(this.element);
            }
        },
        widget: function() {
            return this.uiDialog;
        },
        disable: $.noop,
        enable: $.noop,
        close: function(event) {
            var that = this;
            if (!this._isOpen || this._trigger("beforeClose", event) === false) {
                return;
            }
            this._isOpen = false;
            this._destroyOverlay();
            if (!this.opener.filter(":focusable").focus().length) {
                $(this.document[0].activeElement).blur();
            }
            this._hide(this.uiDialog, this.options.hide, function() {
                that._trigger("close", event);
            });
        },
        isOpen: function() {
            return this._isOpen;
        },
        moveToTop: function() {
            this._moveToTop();
        },
        _moveToTop: function(event, silent) {
            var moved = !!this.uiDialog.nextAll(":visible").insertBefore(this.uiDialog).length;
            if (moved && !silent) {
                this._trigger("focus", event);
            }
            return moved;
        },
        open: function() {
            var that = this;
            if (this._isOpen) {
                if (this._moveToTop()) {
                    this._focusTabbable();
                }
                return;
            }
            this._isOpen = true;
            this.opener = $(this.document[0].activeElement);
            this._size();
            this._position();
            this._createOverlay();
            this._moveToTop(null, true);
            this._show(this.uiDialog, this.options.show, function() {
                that._focusTabbable();
                that._trigger("focus");
            });
            this._trigger("open");
        },
        _focusTabbable: function() {
            var hasFocus = this.element.find("[autofocus]");
            if (!hasFocus.length) {
                hasFocus = this.element.find(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialogButtonPane.find(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialog;
            }
            hasFocus.eq(0).focus();
        },
        _keepFocus: function(event) {
            function checkFocus() {
                var activeElement = this.document[0].activeElement, isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);
                if (!isActive) {
                    this._focusTabbable();
                }
            }
            event.preventDefault();
            checkFocus.call(this);
            this._delay(checkFocus);
        },
        _createWrapper: function() {
            this.uiDialog = $("<div>").addClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " + this.options.dialogClass).hide().attr({
                tabIndex: -1,
                role: "dialog"
            }).appendTo(this._appendTo());
            this._on(this.uiDialog, {
                keydown: function(event) {
                    if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) {
                        event.preventDefault();
                        this.close(event);
                        return;
                    }
                    if (event.keyCode !== $.ui.keyCode.TAB) {
                        return;
                    }
                    var tabbables = this.uiDialog.find(":tabbable"), first = tabbables.filter(":first"), last = tabbables.filter(":last");
                    if ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {
                        first.focus(1);
                        event.preventDefault();
                    } else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {
                        last.focus(1);
                        event.preventDefault();
                    }
                },
                mousedown: function(event) {
                    if (this._moveToTop(event)) {
                        this._focusTabbable();
                    }
                }
            });
            if (!this.element.find("[aria-describedby]").length) {
                this.uiDialog.attr({
                    "aria-describedby": this.element.uniqueId().attr("id")
                });
            }
        },
        _createTitlebar: function() {
            var uiDialogTitle;
            this.uiDialogTitlebar = $("<div>").addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(this.uiDialog);
            this._on(this.uiDialogTitlebar, {
                mousedown: function(event) {
                    if (!$(event.target).closest(".ui-dialog-titlebar-close")) {
                        this.uiDialog.focus();
                    }
                }
            });
            this.uiDialogTitlebarClose = $("<button></button>").button({
                label: this.options.closeText,
                icons: {
                    primary: "ui-icon-closethick"
                },
                text: false
            }).addClass("ui-dialog-titlebar-close").appendTo(this.uiDialogTitlebar);
            this._on(this.uiDialogTitlebarClose, {
                click: function(event) {
                    event.preventDefault();
                    this.close(event);
                }
            });
            uiDialogTitle = $("<span>").uniqueId().addClass("ui-dialog-title").prependTo(this.uiDialogTitlebar);
            this._title(uiDialogTitle);
            this.uiDialog.attr({
                "aria-labelledby": uiDialogTitle.attr("id")
            });
        },
        _title: function(title) {
            if (!this.options.title) {
                title.html("&#160;");
            }
            title.text(this.options.title);
        },
        _createButtonPane: function() {
            this.uiDialogButtonPane = $("<div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix");
            this.uiButtonSet = $("<div>").addClass("ui-dialog-buttonset").appendTo(this.uiDialogButtonPane);
            this._createButtons();
        },
        _createButtons: function() {
            var that = this, buttons = this.options.buttons;
            this.uiDialogButtonPane.remove();
            this.uiButtonSet.empty();
            if ($.isEmptyObject(buttons) || $.isArray(buttons) && !buttons.length) {
                this.uiDialog.removeClass("ui-dialog-buttons");
                return;
            }
            $.each(buttons, function(name, props) {
                var click, buttonOptions;
                props = $.isFunction(props) ? {
                    click: props,
                    text: name
                } : props;
                props = $.extend({
                    type: "button"
                }, props);
                click = props.click;
                props.click = function() {
                    click.apply(that.element[0], arguments);
                };
                buttonOptions = {
                    icons: props.icons,
                    text: props.showText
                };
                delete props.icons;
                delete props.showText;
                $("<button></button>", props).button(buttonOptions).appendTo(that.uiButtonSet);
            });
            this.uiDialog.addClass("ui-dialog-buttons");
            this.uiDialogButtonPane.appendTo(this.uiDialog);
        },
        _makeDraggable: function() {
            var that = this, options = this.options;
            function filteredUi(ui) {
                return {
                    position: ui.position,
                    offset: ui.offset
                };
            }
            this.uiDialog.draggable({
                cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                handle: ".ui-dialog-titlebar",
                containment: "document",
                start: function(event, ui) {
                    $(this).addClass("ui-dialog-dragging");
                    that._blockFrames();
                    that._trigger("dragStart", event, filteredUi(ui));
                },
                drag: function(event, ui) {
                    that._trigger("drag", event, filteredUi(ui));
                },
                stop: function(event, ui) {
                    options.position = [ ui.position.left - that.document.scrollLeft(), ui.position.top - that.document.scrollTop() ];
                    $(this).removeClass("ui-dialog-dragging");
                    that._unblockFrames();
                    that._trigger("dragStop", event, filteredUi(ui));
                }
            });
        },
        _makeResizable: function() {
            var that = this, options = this.options, handles = options.resizable, position = this.uiDialog.css("position"), resizeHandles = typeof handles === "string" ? handles : "n,e,s,w,se,sw,ne,nw";
            function filteredUi(ui) {
                return {
                    originalPosition: ui.originalPosition,
                    originalSize: ui.originalSize,
                    position: ui.position,
                    size: ui.size
                };
            }
            this.uiDialog.resizable({
                cancel: ".ui-dialog-content",
                containment: "document",
                alsoResize: this.element,
                maxWidth: options.maxWidth,
                maxHeight: options.maxHeight,
                minWidth: options.minWidth,
                minHeight: this._minHeight(),
                handles: resizeHandles,
                start: function(event, ui) {
                    $(this).addClass("ui-dialog-resizing");
                    that._blockFrames();
                    that._trigger("resizeStart", event, filteredUi(ui));
                },
                resize: function(event, ui) {
                    that._trigger("resize", event, filteredUi(ui));
                },
                stop: function(event, ui) {
                    options.height = $(this).height();
                    options.width = $(this).width();
                    $(this).removeClass("ui-dialog-resizing");
                    that._unblockFrames();
                    that._trigger("resizeStop", event, filteredUi(ui));
                }
            }).css("position", position);
        },
        _minHeight: function() {
            var options = this.options;
            return options.height === "auto" ? options.minHeight : Math.min(options.minHeight, options.height);
        },
        _position: function() {
            var isVisible = this.uiDialog.is(":visible");
            if (!isVisible) {
                this.uiDialog.show();
            }
            this.uiDialog.position(this.options.position);
            if (!isVisible) {
                this.uiDialog.hide();
            }
        },
        _setOptions: function(options) {
            var that = this, resize = false, resizableOptions = {};
            $.each(options, function(key, value) {
                that._setOption(key, value);
                if (key in sizeRelatedOptions) {
                    resize = true;
                }
                if (key in resizableRelatedOptions) {
                    resizableOptions[key] = value;
                }
            });
            if (resize) {
                this._size();
                this._position();
            }
            if (this.uiDialog.is(":data(ui-resizable)")) {
                this.uiDialog.resizable("option", resizableOptions);
            }
        },
        _setOption: function(key, value) {
            var isDraggable, isResizable, uiDialog = this.uiDialog;
            if (key === "dialogClass") {
                uiDialog.removeClass(this.options.dialogClass).addClass(value);
            }
            if (key === "disabled") {
                return;
            }
            this._super(key, value);
            if (key === "appendTo") {
                this.uiDialog.appendTo(this._appendTo());
            }
            if (key === "buttons") {
                this._createButtons();
            }
            if (key === "closeText") {
                this.uiDialogTitlebarClose.button({
                    label: "" + value
                });
            }
            if (key === "draggable") {
                isDraggable = uiDialog.is(":data(ui-draggable)");
                if (isDraggable && !value) {
                    uiDialog.draggable("destroy");
                }
                if (!isDraggable && value) {
                    this._makeDraggable();
                }
            }
            if (key === "position") {
                this._position();
            }
            if (key === "resizable") {
                isResizable = uiDialog.is(":data(ui-resizable)");
                if (isResizable && !value) {
                    uiDialog.resizable("destroy");
                }
                if (isResizable && typeof value === "string") {
                    uiDialog.resizable("option", "handles", value);
                }
                if (!isResizable && value !== false) {
                    this._makeResizable();
                }
            }
            if (key === "title") {
                this._title(this.uiDialogTitlebar.find(".ui-dialog-title"));
            }
        },
        _size: function() {
            var nonContentHeight, minContentHeight, maxContentHeight, options = this.options;
            this.element.show().css({
                width: "auto",
                minHeight: 0,
                maxHeight: "none",
                height: 0
            });
            if (options.minWidth > options.width) {
                options.width = options.minWidth;
            }
            nonContentHeight = this.uiDialog.css({
                height: "auto",
                width: options.width
            }).outerHeight();
            minContentHeight = Math.max(0, options.minHeight - nonContentHeight);
            maxContentHeight = typeof options.maxHeight === "number" ? Math.max(0, options.maxHeight - nonContentHeight) : "none";
            if (options.height === "auto") {
                this.element.css({
                    minHeight: minContentHeight,
                    maxHeight: maxContentHeight,
                    height: "auto"
                });
            } else {
                this.element.height(Math.max(0, options.height - nonContentHeight));
            }
            if (this.uiDialog.is(":data(ui-resizable)")) {
                this.uiDialog.resizable("option", "minHeight", this._minHeight());
            }
        },
        _blockFrames: function() {
            this.iframeBlocks = this.document.find("iframe").map(function() {
                var iframe = $(this);
                return $("<div>").css({
                    position: "absolute",
                    width: iframe.outerWidth(),
                    height: iframe.outerHeight()
                }).appendTo(iframe.parent()).offset(iframe.offset())[0];
            });
        },
        _unblockFrames: function() {
            if (this.iframeBlocks) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks;
            }
        },
        _allowInteraction: function(event) {
            if ($(event.target).closest(".ui-dialog").length) {
                return true;
            }
            return !!$(event.target).closest(".ui-datepicker").length;
        },
        _createOverlay: function() {
            if (!this.options.modal) {
                return;
            }
            var that = this, widgetFullName = this.widgetFullName;
            if (!$.ui.dialog.overlayInstances) {
                this._delay(function() {
                    if ($.ui.dialog.overlayInstances) {
                        this.document.bind("focusin.dialog", function(event) {
                            if (!that._allowInteraction(event)) {
                                event.preventDefault();
                                $(".ui-dialog:visible:last .ui-dialog-content").data(widgetFullName)._focusTabbable();
                            }
                        });
                    }
                });
            }
            this.overlay = $("<div>").addClass("ui-widget-overlay ui-front").appendTo(this._appendTo());
            this._on(this.overlay, {
                mousedown: "_keepFocus"
            });
            $.ui.dialog.overlayInstances++;
        },
        _destroyOverlay: function() {
            if (!this.options.modal) {
                return;
            }
            if (this.overlay) {
                $.ui.dialog.overlayInstances--;
                if (!$.ui.dialog.overlayInstances) {
                    this.document.unbind("focusin.dialog");
                }
                this.overlay.remove();
                this.overlay = null;
            }
        }
    });
    $.ui.dialog.overlayInstances = 0;
    if ($.uiBackCompat !== false) {
        $.widget("ui.dialog", $.ui.dialog, {
            _position: function() {
                var position = this.options.position, myAt = [], offset = [ 0, 0 ], isVisible;
                if (position) {
                    if (typeof position === "string" || typeof position === "object" && "0" in position) {
                        myAt = position.split ? position.split(" ") : [ position[0], position[1] ];
                        if (myAt.length === 1) {
                            myAt[1] = myAt[0];
                        }
                        $.each([ "left", "top" ], function(i, offsetPosition) {
                            if (+myAt[i] === myAt[i]) {
                                offset[i] = myAt[i];
                                myAt[i] = offsetPosition;
                            }
                        });
                        position = {
                            my: myAt[0] + (offset[0] < 0 ? offset[0] : "+" + offset[0]) + " " + myAt[1] + (offset[1] < 0 ? offset[1] : "+" + offset[1]),
                            at: myAt.join(" ")
                        };
                    }
                    position = $.extend({}, $.ui.dialog.prototype.options.position, position);
                } else {
                    position = $.ui.dialog.prototype.options.position;
                }
                isVisible = this.uiDialog.is(":visible");
                if (!isVisible) {
                    this.uiDialog.show();
                }
                this.uiDialog.position(position);
                if (!isVisible) {
                    this.uiDialog.hide();
                }
            }
        });
    }
})(jQuery);

(function($, undefined) {
    var rvertical = /up|down|vertical/, rpositivemotion = /up|left|vertical|horizontal/;
    $.effects.effect.blind = function(o, done) {
        var el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), direction = o.direction || "up", vertical = rvertical.test(direction), ref = vertical ? "height" : "width", ref2 = vertical ? "top" : "left", motion = rpositivemotion.test(direction), animation = {}, show = mode === "show", wrapper, distance, margin;
        if (el.parent().is(".ui-effects-wrapper")) {
            $.effects.save(el.parent(), props);
        } else {
            $.effects.save(el, props);
        }
        el.show();
        wrapper = $.effects.createWrapper(el).css({
            overflow: "hidden"
        });
        distance = wrapper[ref]();
        margin = parseFloat(wrapper.css(ref2)) || 0;
        animation[ref] = show ? distance : 0;
        if (!motion) {
            el.css(vertical ? "bottom" : "right", 0).css(vertical ? "top" : "left", "auto").css({
                position: "absolute"
            });
            animation[ref2] = show ? margin : distance + margin;
        }
        if (show) {
            wrapper.css(ref, 0);
            if (!motion) {
                wrapper.css(ref2, margin + distance);
            }
        }
        wrapper.animate(animation, {
            duration: o.duration,
            easing: o.easing,
            queue: false,
            complete: function() {
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });
    };
})(jQuery);

(function($, undefined) {
    $.effects.effect.bounce = function(o, done) {
        var el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "effect"), hide = mode === "hide", show = mode === "show", direction = o.direction || "up", distance = o.distance, times = o.times || 5, anims = times * 2 + (show || hide ? 1 : 0), speed = o.duration / anims, easing = o.easing, ref = direction === "up" || direction === "down" ? "top" : "left", motion = direction === "up" || direction === "left", i, upAnim, downAnim, queue = el.queue(), queuelen = queue.length;
        if (show || hide) {
            props.push("opacity");
        }
        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);
        if (!distance) {
            distance = el[ref === "top" ? "outerHeight" : "outerWidth"]() / 3;
        }
        if (show) {
            downAnim = {
                opacity: 1
            };
            downAnim[ref] = 0;
            el.css("opacity", 0).css(ref, motion ? -distance * 2 : distance * 2).animate(downAnim, speed, easing);
        }
        if (hide) {
            distance = distance / Math.pow(2, times - 1);
        }
        downAnim = {};
        downAnim[ref] = 0;
        for (i = 0; i < times; i++) {
            upAnim = {};
            upAnim[ref] = (motion ? "-=" : "+=") + distance;
            el.animate(upAnim, speed, easing).animate(downAnim, speed, easing);
            distance = hide ? distance * 2 : distance / 2;
        }
        if (hide) {
            upAnim = {
                opacity: 0
            };
            upAnim[ref] = (motion ? "-=" : "+=") + distance;
            el.animate(upAnim, speed, easing);
        }
        el.queue(function() {
            if (hide) {
                el.hide();
            }
            $.effects.restore(el, props);
            $.effects.removeWrapper(el);
            done();
        });
        if (queuelen > 1) {
            queue.splice.apply(queue, [ 1, 0 ].concat(queue.splice(queuelen, anims + 1)));
        }
        el.dequeue();
    };
})(jQuery);

(function($, undefined) {
    $.effects.effect.clip = function(o, done) {
        var el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), show = mode === "show", direction = o.direction || "vertical", vert = direction === "vertical", size = vert ? "height" : "width", position = vert ? "top" : "left", animation = {}, wrapper, animate, distance;
        $.effects.save(el, props);
        el.show();
        wrapper = $.effects.createWrapper(el).css({
            overflow: "hidden"
        });
        animate = el[0].tagName === "IMG" ? wrapper : el;
        distance = animate[size]();
        if (show) {
            animate.css(size, 0);
            animate.css(position, distance / 2);
        }
        animation[size] = show ? distance : 0;
        animation[position] = show ? 0 : distance / 2;
        animate.animate(animation, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                if (!show) {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });
    };
})(jQuery);

(function($, undefined) {
    $.effects.effect.drop = function(o, done) {
        var el = $(this), props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), show = mode === "show", direction = o.direction || "left", ref = direction === "up" || direction === "down" ? "top" : "left", motion = direction === "up" || direction === "left" ? "pos" : "neg", animation = {
            opacity: show ? 1 : 0
        }, distance;
        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);
        distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true) / 2;
        if (show) {
            el.css("opacity", 0).css(ref, motion === "pos" ? -distance : distance);
        }
        animation[ref] = (show ? motion === "pos" ? "+=" : "-=" : motion === "pos" ? "-=" : "+=") + distance;
        el.animate(animation, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });
    };
})(jQuery);

(function($, undefined) {
    $.effects.effect.explode = function(o, done) {
        var rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3, cells = rows, el = $(this), mode = $.effects.setMode(el, o.mode || "hide"), show = mode === "show", offset = el.show().css("visibility", "hidden").offset(), width = Math.ceil(el.outerWidth() / cells), height = Math.ceil(el.outerHeight() / rows), pieces = [], i, j, left, top, mx, my;
        function childComplete() {
            pieces.push(this);
            if (pieces.length === rows * cells) {
                animComplete();
            }
        }
        for (i = 0; i < rows; i++) {
            top = offset.top + i * height;
            my = i - (rows - 1) / 2;
            for (j = 0; j < cells; j++) {
                left = offset.left + j * width;
                mx = j - (cells - 1) / 2;
                el.clone().appendTo("body").wrap("<div></div>").css({
                    position: "absolute",
                    visibility: "visible",
                    left: -j * width,
                    top: -i * height
                }).parent().addClass("ui-effects-explode").css({
                    position: "absolute",
                    overflow: "hidden",
                    width: width,
                    height: height,
                    left: left + (show ? mx * width : 0),
                    top: top + (show ? my * height : 0),
                    opacity: show ? 0 : 1
                }).animate({
                    left: left + (show ? 0 : mx * width),
                    top: top + (show ? 0 : my * height),
                    opacity: show ? 1 : 0
                }, o.duration || 500, o.easing, childComplete);
            }
        }
        function animComplete() {
            el.css({
                visibility: "visible"
            });
            $(pieces).remove();
            if (!show) {
                el.hide();
            }
            done();
        }
    };
})(jQuery);

(function($, undefined) {
    $.effects.effect.fade = function(o, done) {
        var el = $(this), mode = $.effects.setMode(el, o.mode || "toggle");
        el.animate({
            opacity: mode
        }, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: done
        });
    };
})(jQuery);

(function($, undefined) {
    $.effects.effect.fold = function(o, done) {
        var el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), show = mode === "show", hide = mode === "hide", size = o.size || 15, percent = /([0-9]+)%/.exec(size), horizFirst = !!o.horizFirst, widthFirst = show !== horizFirst, ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ], duration = o.duration / 2, wrapper, distance, animation1 = {}, animation2 = {};
        $.effects.save(el, props);
        el.show();
        wrapper = $.effects.createWrapper(el).css({
            overflow: "hidden"
        });
        distance = widthFirst ? [ wrapper.width(), wrapper.height() ] : [ wrapper.height(), wrapper.width() ];
        if (percent) {
            size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];
        }
        if (show) {
            wrapper.css(horizFirst ? {
                height: 0,
                width: size
            } : {
                height: size,
                width: 0
            });
        }
        animation1[ref[0]] = show ? distance[0] : size;
        animation2[ref[1]] = show ? distance[1] : 0;
        wrapper.animate(animation1, duration, o.easing).animate(animation2, duration, o.easing, function() {
            if (hide) {
                el.hide();
            }
            $.effects.restore(el, props);
            $.effects.removeWrapper(el);
            done();
        });
    };
})(jQuery);

(function($, undefined) {
    $.effects.effect.highlight = function(o, done) {
        var elem = $(this), props = [ "backgroundImage", "backgroundColor", "opacity" ], mode = $.effects.setMode(elem, o.mode || "show"), animation = {
            backgroundColor: elem.css("backgroundColor")
        };
        if (mode === "hide") {
            animation.opacity = 0;
        }
        $.effects.save(elem, props);
        elem.show().css({
            backgroundImage: "none",
            backgroundColor: o.color || "#ffff99"
        }).animate(animation, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                if (mode === "hide") {
                    elem.hide();
                }
                $.effects.restore(elem, props);
                done();
            }
        });
    };
})(jQuery);

(function($, undefined) {
    $.effects.effect.pulsate = function(o, done) {
        var elem = $(this), mode = $.effects.setMode(elem, o.mode || "show"), show = mode === "show", hide = mode === "hide", showhide = show || mode === "hide", anims = (o.times || 5) * 2 + (showhide ? 1 : 0), duration = o.duration / anims, animateTo = 0, queue = elem.queue(), queuelen = queue.length, i;
        if (show || !elem.is(":visible")) {
            elem.css("opacity", 0).show();
            animateTo = 1;
        }
        for (i = 1; i < anims; i++) {
            elem.animate({
                opacity: animateTo
            }, duration, o.easing);
            animateTo = 1 - animateTo;
        }
        elem.animate({
            opacity: animateTo
        }, duration, o.easing);
        elem.queue(function() {
            if (hide) {
                elem.hide();
            }
            done();
        });
        if (queuelen > 1) {
            queue.splice.apply(queue, [ 1, 0 ].concat(queue.splice(queuelen, anims + 1)));
        }
        elem.dequeue();
    };
})(jQuery);

(function($, undefined) {
    $.effects.effect.puff = function(o, done) {
        var elem = $(this), mode = $.effects.setMode(elem, o.mode || "hide"), hide = mode === "hide", percent = parseInt(o.percent, 10) || 150, factor = percent / 100, original = {
            height: elem.height(),
            width: elem.width(),
            outerHeight: elem.outerHeight(),
            outerWidth: elem.outerWidth()
        };
        $.extend(o, {
            effect: "scale",
            queue: false,
            fade: true,
            mode: mode,
            complete: done,
            percent: hide ? percent : 100,
            from: hide ? original : {
                height: original.height * factor,
                width: original.width * factor,
                outerHeight: original.outerHeight * factor,
                outerWidth: original.outerWidth * factor
            }
        });
        elem.effect(o);
    };
    $.effects.effect.scale = function(o, done) {
        var el = $(this), options = $.extend(true, {}, o), mode = $.effects.setMode(el, o.mode || "effect"), percent = parseInt(o.percent, 10) || (parseInt(o.percent, 10) === 0 ? 0 : mode === "hide" ? 0 : 100), direction = o.direction || "both", origin = o.origin, original = {
            height: el.height(),
            width: el.width(),
            outerHeight: el.outerHeight(),
            outerWidth: el.outerWidth()
        }, factor = {
            y: direction !== "horizontal" ? percent / 100 : 1,
            x: direction !== "vertical" ? percent / 100 : 1
        };
        options.effect = "size";
        options.queue = false;
        options.complete = done;
        if (mode !== "effect") {
            options.origin = origin || [ "middle", "center" ];
            options.restore = true;
        }
        options.from = o.from || (mode === "show" ? {
            height: 0,
            width: 0,
            outerHeight: 0,
            outerWidth: 0
        } : original);
        options.to = {
            height: original.height * factor.y,
            width: original.width * factor.x,
            outerHeight: original.outerHeight * factor.y,
            outerWidth: original.outerWidth * factor.x
        };
        if (options.fade) {
            if (mode === "show") {
                options.from.opacity = 0;
                options.to.opacity = 1;
            }
            if (mode === "hide") {
                options.from.opacity = 1;
                options.to.opacity = 0;
            }
        }
        el.effect(options);
    };
    $.effects.effect.size = function(o, done) {
        var original, baseline, factor, el = $(this), props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ], props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ], props2 = [ "width", "height", "overflow" ], cProps = [ "fontSize" ], vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ], hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ], mode = $.effects.setMode(el, o.mode || "effect"), restore = o.restore || mode !== "effect", scale = o.scale || "both", origin = o.origin || [ "middle", "center" ], position = el.css("position"), props = restore ? props0 : props1, zero = {
            height: 0,
            width: 0,
            outerHeight: 0,
            outerWidth: 0
        };
        if (mode === "show") {
            el.show();
        }
        original = {
            height: el.height(),
            width: el.width(),
            outerHeight: el.outerHeight(),
            outerWidth: el.outerWidth()
        };
        if (o.mode === "toggle" && mode === "show") {
            el.from = o.to || zero;
            el.to = o.from || original;
        } else {
            el.from = o.from || (mode === "show" ? zero : original);
            el.to = o.to || (mode === "hide" ? zero : original);
        }
        factor = {
            from: {
                y: el.from.height / original.height,
                x: el.from.width / original.width
            },
            to: {
                y: el.to.height / original.height,
                x: el.to.width / original.width
            }
        };
        if (scale === "box" || scale === "both") {
            if (factor.from.y !== factor.to.y) {
                props = props.concat(vProps);
                el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
                el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
            }
            if (factor.from.x !== factor.to.x) {
                props = props.concat(hProps);
                el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
                el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
            }
        }
        if (scale === "content" || scale === "both") {
            if (factor.from.y !== factor.to.y) {
                props = props.concat(cProps).concat(props2);
                el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
                el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
            }
        }
        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);
        el.css("overflow", "hidden").css(el.from);
        if (origin) {
            baseline = $.effects.getBaseline(origin, original);
            el.from.top = (original.outerHeight - el.outerHeight()) * baseline.y;
            el.from.left = (original.outerWidth - el.outerWidth()) * baseline.x;
            el.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y;
            el.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x;
        }
        el.css(el.from);
        if (scale === "content" || scale === "both") {
            vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
            hProps = hProps.concat([ "marginLeft", "marginRight" ]);
            props2 = props0.concat(vProps).concat(hProps);
            el.find("*[width]").each(function() {
                var child = $(this), c_original = {
                    height: child.height(),
                    width: child.width(),
                    outerHeight: child.outerHeight(),
                    outerWidth: child.outerWidth()
                };
                if (restore) {
                    $.effects.save(child, props2);
                }
                child.from = {
                    height: c_original.height * factor.from.y,
                    width: c_original.width * factor.from.x,
                    outerHeight: c_original.outerHeight * factor.from.y,
                    outerWidth: c_original.outerWidth * factor.from.x
                };
                child.to = {
                    height: c_original.height * factor.to.y,
                    width: c_original.width * factor.to.x,
                    outerHeight: c_original.height * factor.to.y,
                    outerWidth: c_original.width * factor.to.x
                };
                if (factor.from.y !== factor.to.y) {
                    child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
                    child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
                }
                if (factor.from.x !== factor.to.x) {
                    child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
                    child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
                }
                child.css(child.from);
                child.animate(child.to, o.duration, o.easing, function() {
                    if (restore) {
                        $.effects.restore(child, props2);
                    }
                });
            });
        }
        el.animate(el.to, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                if (el.to.opacity === 0) {
                    el.css("opacity", el.from.opacity);
                }
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                if (!restore) {
                    if (position === "static") {
                        el.css({
                            position: "relative",
                            top: el.to.top,
                            left: el.to.left
                        });
                    } else {
                        $.each([ "top", "left" ], function(idx, pos) {
                            el.css(pos, function(_, str) {
                                var val = parseInt(str, 10), toRef = idx ? el.to.left : el.to.top;
                                if (str === "auto") {
                                    return toRef + "px";
                                }
                                return val + toRef + "px";
                            });
                        });
                    }
                }
                $.effects.removeWrapper(el);
                done();
            }
        });
    };
})(jQuery);

(function($, undefined) {
    $.effects.effect.shake = function(o, done) {
        var el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "effect"), direction = o.direction || "left", distance = o.distance || 20, times = o.times || 3, anims = times * 2 + 1, speed = Math.round(o.duration / anims), ref = direction === "up" || direction === "down" ? "top" : "left", positiveMotion = direction === "up" || direction === "left", animation = {}, animation1 = {}, animation2 = {}, i, queue = el.queue(), queuelen = queue.length;
        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);
        animation[ref] = (positiveMotion ? "-=" : "+=") + distance;
        animation1[ref] = (positiveMotion ? "+=" : "-=") + distance * 2;
        animation2[ref] = (positiveMotion ? "-=" : "+=") + distance * 2;
        el.animate(animation, speed, o.easing);
        for (i = 1; i < times; i++) {
            el.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);
        }
        el.animate(animation1, speed, o.easing).animate(animation, speed / 2, o.easing).queue(function() {
            if (mode === "hide") {
                el.hide();
            }
            $.effects.restore(el, props);
            $.effects.removeWrapper(el);
            done();
        });
        if (queuelen > 1) {
            queue.splice.apply(queue, [ 1, 0 ].concat(queue.splice(queuelen, anims + 1)));
        }
        el.dequeue();
    };
})(jQuery);

(function($, undefined) {
    $.effects.effect.slide = function(o, done) {
        var el = $(this), props = [ "position", "top", "bottom", "left", "right", "width", "height" ], mode = $.effects.setMode(el, o.mode || "show"), show = mode === "show", direction = o.direction || "left", ref = direction === "up" || direction === "down" ? "top" : "left", positiveMotion = direction === "up" || direction === "left", distance, animation = {};
        $.effects.save(el, props);
        el.show();
        distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true);
        $.effects.createWrapper(el).css({
            overflow: "hidden"
        });
        if (show) {
            el.css(ref, positiveMotion ? isNaN(distance) ? "-" + distance : -distance : distance);
        }
        animation[ref] = (show ? positiveMotion ? "+=" : "-=" : positiveMotion ? "-=" : "+=") + distance;
        el.animate(animation, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });
    };
})(jQuery);

(function($, undefined) {
    $.effects.effect.transfer = function(o, done) {
        var elem = $(this), target = $(o.to), targetFixed = target.css("position") === "fixed", body = $("body"), fixTop = targetFixed ? body.scrollTop() : 0, fixLeft = targetFixed ? body.scrollLeft() : 0, endPosition = target.offset(), animation = {
            top: endPosition.top - fixTop,
            left: endPosition.left - fixLeft,
            height: target.innerHeight(),
            width: target.innerWidth()
        }, startPosition = elem.offset(), transfer = $("<div class='ui-effects-transfer'></div>").appendTo(document.body).addClass(o.className).css({
            top: startPosition.top - fixTop,
            left: startPosition.left - fixLeft,
            height: elem.innerHeight(),
            width: elem.innerWidth(),
            position: targetFixed ? "fixed" : "absolute"
        }).animate(animation, o.duration, o.easing, function() {
            transfer.remove();
            done();
        });
    };
})(jQuery);

(function($, undefined) {
    $.widget("ui.menu", {
        version: "1.10.3",
        defaultElement: "<ul>",
        delay: 300,
        options: {
            icons: {
                submenu: "ui-icon-carat-1-e"
            },
            menus: "ul",
            position: {
                my: "left top",
                at: "right top"
            },
            role: "menu",
            blur: null,
            focus: null,
            select: null
        },
        _create: function() {
            this.activeMenu = this.element;
            this.mouseHandled = false;
            this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content ui-corner-all").toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length).attr({
                role: this.options.role,
                tabIndex: 0
            }).bind("click" + this.eventNamespace, $.proxy(function(event) {
                if (this.options.disabled) {
                    event.preventDefault();
                }
            }, this));
            if (this.options.disabled) {
                this.element.addClass("ui-state-disabled").attr("aria-disabled", "true");
            }
            this._on({
                "mousedown .ui-menu-item > a": function(event) {
                    event.preventDefault();
                },
                "click .ui-state-disabled > a": function(event) {
                    event.preventDefault();
                },
                "click .ui-menu-item:has(a)": function(event) {
                    var target = $(event.target).closest(".ui-menu-item");
                    if (!this.mouseHandled && target.not(".ui-state-disabled").length) {
                        this.mouseHandled = true;
                        this.select(event);
                        if (target.has(".ui-menu").length) {
                            this.expand(event);
                        } else if (!this.element.is(":focus")) {
                            this.element.trigger("focus", [ true ]);
                            if (this.active && this.active.parents(".ui-menu").length === 1) {
                                clearTimeout(this.timer);
                            }
                        }
                    }
                },
                "mouseenter .ui-menu-item": function(event) {
                    var target = $(event.currentTarget);
                    target.siblings().children(".ui-state-active").removeClass("ui-state-active");
                    this.focus(event, target);
                },
                mouseleave: "collapseAll",
                "mouseleave .ui-menu": "collapseAll",
                focus: function(event, keepActiveItem) {
                    var item = this.active || this.element.children(".ui-menu-item").eq(0);
                    if (!keepActiveItem) {
                        this.focus(event, item);
                    }
                },
                blur: function(event) {
                    this._delay(function() {
                        if (!$.contains(this.element[0], this.document[0].activeElement)) {
                            this.collapseAll(event);
                        }
                    });
                },
                keydown: "_keydown"
            });
            this.refresh();
            this._on(this.document, {
                click: function(event) {
                    if (!$(event.target).closest(".ui-menu").length) {
                        this.collapseAll(event);
                    }
                    this.mouseHandled = false;
                }
            });
        },
        _destroy: function() {
            this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeClass("ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show();
            this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").children("a").removeUniqueId().removeClass("ui-corner-all ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function() {
                var elem = $(this);
                if (elem.data("ui-menu-submenu-carat")) {
                    elem.remove();
                }
            });
            this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content");
        },
        _keydown: function(event) {
            var match, prev, character, skip, regex, preventDefault = true;
            function escape(value) {
                return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
            }
            switch (event.keyCode) {
              case $.ui.keyCode.PAGE_UP:
                this.previousPage(event);
                break;

              case $.ui.keyCode.PAGE_DOWN:
                this.nextPage(event);
                break;

              case $.ui.keyCode.HOME:
                this._move("first", "first", event);
                break;

              case $.ui.keyCode.END:
                this._move("last", "last", event);
                break;

              case $.ui.keyCode.UP:
                this.previous(event);
                break;

              case $.ui.keyCode.DOWN:
                this.next(event);
                break;

              case $.ui.keyCode.LEFT:
                this.collapse(event);
                break;

              case $.ui.keyCode.RIGHT:
                if (this.active && !this.active.is(".ui-state-disabled")) {
                    this.expand(event);
                }
                break;

              case $.ui.keyCode.ENTER:
              case $.ui.keyCode.SPACE:
                this._activate(event);
                break;

              case $.ui.keyCode.ESCAPE:
                this.collapse(event);
                break;

              default:
                preventDefault = false;
                prev = this.previousFilter || "";
                character = String.fromCharCode(event.keyCode);
                skip = false;
                clearTimeout(this.filterTimer);
                if (character === prev) {
                    skip = true;
                } else {
                    character = prev + character;
                }
                regex = new RegExp("^" + escape(character), "i");
                match = this.activeMenu.children(".ui-menu-item").filter(function() {
                    return regex.test($(this).children("a").text());
                });
                match = skip && match.index(this.active.next()) !== -1 ? this.active.nextAll(".ui-menu-item") : match;
                if (!match.length) {
                    character = String.fromCharCode(event.keyCode);
                    regex = new RegExp("^" + escape(character), "i");
                    match = this.activeMenu.children(".ui-menu-item").filter(function() {
                        return regex.test($(this).children("a").text());
                    });
                }
                if (match.length) {
                    this.focus(event, match);
                    if (match.length > 1) {
                        this.previousFilter = character;
                        this.filterTimer = this._delay(function() {
                            delete this.previousFilter;
                        }, 1e3);
                    } else {
                        delete this.previousFilter;
                    }
                } else {
                    delete this.previousFilter;
                }
            }
            if (preventDefault) {
                event.preventDefault();
            }
        },
        _activate: function(event) {
            if (!this.active.is(".ui-state-disabled")) {
                if (this.active.children("a[aria-haspopup='true']").length) {
                    this.expand(event);
                } else {
                    this.select(event);
                }
            }
        },
        refresh: function() {
            var menus, icon = this.options.icons.submenu, submenus = this.element.find(this.options.menus);
            submenus.filter(":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-corner-all").hide().attr({
                role: this.options.role,
                "aria-hidden": "true",
                "aria-expanded": "false"
            }).each(function() {
                var menu = $(this), item = menu.prev("a"), submenuCarat = $("<span>").addClass("ui-menu-icon ui-icon " + icon).data("ui-menu-submenu-carat", true);
                item.attr("aria-haspopup", "true").prepend(submenuCarat);
                menu.attr("aria-labelledby", item.attr("id"));
            });
            menus = submenus.add(this.element);
            menus.children(":not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role", "presentation").children("a").uniqueId().addClass("ui-corner-all").attr({
                tabIndex: -1,
                role: this._itemRole()
            });
            menus.children(":not(.ui-menu-item)").each(function() {
                var item = $(this);
                if (!/[^\-\u2014\u2013\s]/.test(item.text())) {
                    item.addClass("ui-widget-content ui-menu-divider");
                }
            });
            menus.children(".ui-state-disabled").attr("aria-disabled", "true");
            if (this.active && !$.contains(this.element[0], this.active[0])) {
                this.blur();
            }
        },
        _itemRole: function() {
            return {
                menu: "menuitem",
                listbox: "option"
            }[this.options.role];
        },
        _setOption: function(key, value) {
            if (key === "icons") {
                this.element.find(".ui-menu-icon").removeClass(this.options.icons.submenu).addClass(value.submenu);
            }
            this._super(key, value);
        },
        focus: function(event, item) {
            var nested, focused;
            this.blur(event, event && event.type === "focus");
            this._scrollIntoView(item);
            this.active = item.first();
            focused = this.active.children("a").addClass("ui-state-focus");
            if (this.options.role) {
                this.element.attr("aria-activedescendant", focused.attr("id"));
            }
            this.active.parent().closest(".ui-menu-item").children("a:first").addClass("ui-state-active");
            if (event && event.type === "keydown") {
                this._close();
            } else {
                this.timer = this._delay(function() {
                    this._close();
                }, this.delay);
            }
            nested = item.children(".ui-menu");
            if (nested.length && /^mouse/.test(event.type)) {
                this._startOpening(nested);
            }
            this.activeMenu = item.parent();
            this._trigger("focus", event, {
                item: item
            });
        },
        _scrollIntoView: function(item) {
            var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
            if (this._hasScroll()) {
                borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0;
                paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0;
                offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
                scroll = this.activeMenu.scrollTop();
                elementHeight = this.activeMenu.height();
                itemHeight = item.height();
                if (offset < 0) {
                    this.activeMenu.scrollTop(scroll + offset);
                } else if (offset + itemHeight > elementHeight) {
                    this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
                }
            }
        },
        blur: function(event, fromFocus) {
            if (!fromFocus) {
                clearTimeout(this.timer);
            }
            if (!this.active) {
                return;
            }
            this.active.children("a").removeClass("ui-state-focus");
            this.active = null;
            this._trigger("blur", event, {
                item: this.active
            });
        },
        _startOpening: function(submenu) {
            clearTimeout(this.timer);
            if (submenu.attr("aria-hidden") !== "true") {
                return;
            }
            this.timer = this._delay(function() {
                this._close();
                this._open(submenu);
            }, this.delay);
        },
        _open: function(submenu) {
            var position = $.extend({
                of: this.active
            }, this.options.position);
            clearTimeout(this.timer);
            this.element.find(".ui-menu").not(submenu.parents(".ui-menu")).hide().attr("aria-hidden", "true");
            submenu.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(position);
        },
        collapseAll: function(event, all) {
            clearTimeout(this.timer);
            this.timer = this._delay(function() {
                var currentMenu = all ? this.element : $(event && event.target).closest(this.element.find(".ui-menu"));
                if (!currentMenu.length) {
                    currentMenu = this.element;
                }
                this._close(currentMenu);
                this.blur(event);
                this.activeMenu = currentMenu;
            }, this.delay);
        },
        _close: function(startMenu) {
            if (!startMenu) {
                startMenu = this.active ? this.active.parent() : this.element;
            }
            startMenu.find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false").end().find("a.ui-state-active").removeClass("ui-state-active");
        },
        collapse: function(event) {
            var newItem = this.active && this.active.parent().closest(".ui-menu-item", this.element);
            if (newItem && newItem.length) {
                this._close();
                this.focus(event, newItem);
            }
        },
        expand: function(event) {
            var newItem = this.active && this.active.children(".ui-menu ").children(".ui-menu-item").first();
            if (newItem && newItem.length) {
                this._open(newItem.parent());
                this._delay(function() {
                    this.focus(event, newItem);
                });
            }
        },
        next: function(event) {
            this._move("next", "first", event);
        },
        previous: function(event) {
            this._move("prev", "last", event);
        },
        isFirstItem: function() {
            return this.active && !this.active.prevAll(".ui-menu-item").length;
        },
        isLastItem: function() {
            return this.active && !this.active.nextAll(".ui-menu-item").length;
        },
        _move: function(direction, filter, event) {
            var next;
            if (this.active) {
                if (direction === "first" || direction === "last") {
                    next = this.active[direction === "first" ? "prevAll" : "nextAll"](".ui-menu-item").eq(-1);
                } else {
                    next = this.active[direction + "All"](".ui-menu-item").eq(0);
                }
            }
            if (!next || !next.length || !this.active) {
                next = this.activeMenu.children(".ui-menu-item")[filter]();
            }
            this.focus(event, next);
        },
        nextPage: function(event) {
            var item, base, height;
            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isLastItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.nextAll(".ui-menu-item").each(function() {
                    item = $(this);
                    return item.offset().top - base - height < 0;
                });
                this.focus(event, item);
            } else {
                this.focus(event, this.activeMenu.children(".ui-menu-item")[!this.active ? "first" : "last"]());
            }
        },
        previousPage: function(event) {
            var item, base, height;
            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isFirstItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.prevAll(".ui-menu-item").each(function() {
                    item = $(this);
                    return item.offset().top - base + height > 0;
                });
                this.focus(event, item);
            } else {
                this.focus(event, this.activeMenu.children(".ui-menu-item").first());
            }
        },
        _hasScroll: function() {
            return this.element.outerHeight() < this.element.prop("scrollHeight");
        },
        select: function(event) {
            this.active = this.active || $(event.target).closest(".ui-menu-item");
            var ui = {
                item: this.active
            };
            if (!this.active.has(".ui-menu").length) {
                this.collapseAll(event, true);
            }
            this._trigger("select", event, ui);
        }
    });
})(jQuery);

(function($, undefined) {
    $.ui = $.ui || {};
    var cachedScrollbarWidth, max = Math.max, abs = Math.abs, round = Math.round, rhorizontal = /left|center|right/, rvertical = /top|center|bottom/, roffset = /[\+\-]\d+(\.[\d]+)?%?/, rposition = /^\w+/, rpercent = /%$/, _position = $.fn.position;
    function getOffsets(offsets, width, height) {
        return [ parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1) ];
    }
    function parseCss(element, property) {
        return parseInt($.css(element, property), 10) || 0;
    }
    function getDimensions(elem) {
        var raw = elem[0];
        if (raw.nodeType === 9) {
            return {
                width: elem.width(),
                height: elem.height(),
                offset: {
                    top: 0,
                    left: 0
                }
            };
        }
        if ($.isWindow(raw)) {
            return {
                width: elem.width(),
                height: elem.height(),
                offset: {
                    top: elem.scrollTop(),
                    left: elem.scrollLeft()
                }
            };
        }
        if (raw.preventDefault) {
            return {
                width: 0,
                height: 0,
                offset: {
                    top: raw.pageY,
                    left: raw.pageX
                }
            };
        }
        return {
            width: elem.outerWidth(),
            height: elem.outerHeight(),
            offset: elem.offset()
        };
    }
    $.position = {
        scrollbarWidth: function() {
            if (cachedScrollbarWidth !== undefined) {
                return cachedScrollbarWidth;
            }
            var w1, w2, div = $("<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"), innerDiv = div.children()[0];
            $("body").append(div);
            w1 = innerDiv.offsetWidth;
            div.css("overflow", "scroll");
            w2 = innerDiv.offsetWidth;
            if (w1 === w2) {
                w2 = div[0].clientWidth;
            }
            div.remove();
            return cachedScrollbarWidth = w1 - w2;
        },
        getScrollInfo: function(within) {
            var overflowX = within.isWindow ? "" : within.element.css("overflow-x"), overflowY = within.isWindow ? "" : within.element.css("overflow-y"), hasOverflowX = overflowX === "scroll" || overflowX === "auto" && within.width < within.element[0].scrollWidth, hasOverflowY = overflowY === "scroll" || overflowY === "auto" && within.height < within.element[0].scrollHeight;
            return {
                width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                height: hasOverflowX ? $.position.scrollbarWidth() : 0
            };
        },
        getWithinInfo: function(element) {
            var withinElement = $(element || window), isWindow = $.isWindow(withinElement[0]);
            return {
                element: withinElement,
                isWindow: isWindow,
                offset: withinElement.offset() || {
                    left: 0,
                    top: 0
                },
                scrollLeft: withinElement.scrollLeft(),
                scrollTop: withinElement.scrollTop(),
                width: isWindow ? withinElement.width() : withinElement.outerWidth(),
                height: isWindow ? withinElement.height() : withinElement.outerHeight()
            };
        }
    };
    $.fn.position = function(options) {
        if (!options || !options.of) {
            return _position.apply(this, arguments);
        }
        options = $.extend({}, options);
        var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions, target = $(options.of), within = $.position.getWithinInfo(options.within), scrollInfo = $.position.getScrollInfo(within), collision = (options.collision || "flip").split(" "), offsets = {};
        dimensions = getDimensions(target);
        if (target[0].preventDefault) {
            options.at = "left top";
        }
        targetWidth = dimensions.width;
        targetHeight = dimensions.height;
        targetOffset = dimensions.offset;
        basePosition = $.extend({}, targetOffset);
        $.each([ "my", "at" ], function() {
            var pos = (options[this] || "").split(" "), horizontalOffset, verticalOffset;
            if (pos.length === 1) {
                pos = rhorizontal.test(pos[0]) ? pos.concat([ "center" ]) : rvertical.test(pos[0]) ? [ "center" ].concat(pos) : [ "center", "center" ];
            }
            pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
            pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";
            horizontalOffset = roffset.exec(pos[0]);
            verticalOffset = roffset.exec(pos[1]);
            offsets[this] = [ horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0 ];
            options[this] = [ rposition.exec(pos[0])[0], rposition.exec(pos[1])[0] ];
        });
        if (collision.length === 1) {
            collision[1] = collision[0];
        }
        if (options.at[0] === "right") {
            basePosition.left += targetWidth;
        } else if (options.at[0] === "center") {
            basePosition.left += targetWidth / 2;
        }
        if (options.at[1] === "bottom") {
            basePosition.top += targetHeight;
        } else if (options.at[1] === "center") {
            basePosition.top += targetHeight / 2;
        }
        atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
        basePosition.left += atOffset[0];
        basePosition.top += atOffset[1];
        return this.each(function() {
            var collisionPosition, using, elem = $(this), elemWidth = elem.outerWidth(), elemHeight = elem.outerHeight(), marginLeft = parseCss(this, "marginLeft"), marginTop = parseCss(this, "marginTop"), collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width, collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height, position = $.extend({}, basePosition), myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());
            if (options.my[0] === "right") {
                position.left -= elemWidth;
            } else if (options.my[0] === "center") {
                position.left -= elemWidth / 2;
            }
            if (options.my[1] === "bottom") {
                position.top -= elemHeight;
            } else if (options.my[1] === "center") {
                position.top -= elemHeight / 2;
            }
            position.left += myOffset[0];
            position.top += myOffset[1];
            if (!$.support.offsetFractions) {
                position.left = round(position.left);
                position.top = round(position.top);
            }
            collisionPosition = {
                marginLeft: marginLeft,
                marginTop: marginTop
            };
            $.each([ "left", "top" ], function(i, dir) {
                if ($.ui.position[collision[i]]) {
                    $.ui.position[collision[i]][dir](position, {
                        targetWidth: targetWidth,
                        targetHeight: targetHeight,
                        elemWidth: elemWidth,
                        elemHeight: elemHeight,
                        collisionPosition: collisionPosition,
                        collisionWidth: collisionWidth,
                        collisionHeight: collisionHeight,
                        offset: [ atOffset[0] + myOffset[0], atOffset[1] + myOffset[1] ],
                        my: options.my,
                        at: options.at,
                        within: within,
                        elem: elem
                    });
                }
            });
            if (options.using) {
                using = function(props) {
                    var left = targetOffset.left - position.left, right = left + targetWidth - elemWidth, top = targetOffset.top - position.top, bottom = top + targetHeight - elemHeight, feedback = {
                        target: {
                            element: target,
                            left: targetOffset.left,
                            top: targetOffset.top,
                            width: targetWidth,
                            height: targetHeight
                        },
                        element: {
                            element: elem,
                            left: position.left,
                            top: position.top,
                            width: elemWidth,
                            height: elemHeight
                        },
                        horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                        vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                    };
                    if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
                        feedback.horizontal = "center";
                    }
                    if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
                        feedback.vertical = "middle";
                    }
                    if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
                        feedback.important = "horizontal";
                    } else {
                        feedback.important = "vertical";
                    }
                    options.using.call(this, props, feedback);
                };
            }
            elem.offset($.extend(position, {
                using: using
            }));
        });
    };
    $.ui.position = {
        fit: {
            left: function(position, data) {
                var within = data.within, withinOffset = within.isWindow ? within.scrollLeft : within.offset.left, outerWidth = within.width, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = withinOffset - collisionPosLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset, newOverRight;
                if (data.collisionWidth > outerWidth) {
                    if (overLeft > 0 && overRight <= 0) {
                        newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                        position.left += overLeft - newOverRight;
                    } else if (overRight > 0 && overLeft <= 0) {
                        position.left = withinOffset;
                    } else {
                        if (overLeft > overRight) {
                            position.left = withinOffset + outerWidth - data.collisionWidth;
                        } else {
                            position.left = withinOffset;
                        }
                    }
                } else if (overLeft > 0) {
                    position.left += overLeft;
                } else if (overRight > 0) {
                    position.left -= overRight;
                } else {
                    position.left = max(position.left - collisionPosLeft, position.left);
                }
            },
            top: function(position, data) {
                var within = data.within, withinOffset = within.isWindow ? within.scrollTop : within.offset.top, outerHeight = data.within.height, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = withinOffset - collisionPosTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset, newOverBottom;
                if (data.collisionHeight > outerHeight) {
                    if (overTop > 0 && overBottom <= 0) {
                        newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                        position.top += overTop - newOverBottom;
                    } else if (overBottom > 0 && overTop <= 0) {
                        position.top = withinOffset;
                    } else {
                        if (overTop > overBottom) {
                            position.top = withinOffset + outerHeight - data.collisionHeight;
                        } else {
                            position.top = withinOffset;
                        }
                    }
                } else if (overTop > 0) {
                    position.top += overTop;
                } else if (overBottom > 0) {
                    position.top -= overBottom;
                } else {
                    position.top = max(position.top - collisionPosTop, position.top);
                }
            }
        },
        flip: {
            left: function(position, data) {
                var within = data.within, withinOffset = within.offset.left + within.scrollLeft, outerWidth = within.width, offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = collisionPosLeft - offsetLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft, myOffset = data.my[0] === "left" ? -data.elemWidth : data.my[0] === "right" ? data.elemWidth : 0, atOffset = data.at[0] === "left" ? data.targetWidth : data.at[0] === "right" ? -data.targetWidth : 0, offset = -2 * data.offset[0], newOverRight, newOverLeft;
                if (overLeft < 0) {
                    newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                    if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                        position.left += myOffset + atOffset + offset;
                    }
                } else if (overRight > 0) {
                    newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                    if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                        position.left += myOffset + atOffset + offset;
                    }
                }
            },
            top: function(position, data) {
                var within = data.within, withinOffset = within.offset.top + within.scrollTop, outerHeight = within.height, offsetTop = within.isWindow ? within.scrollTop : within.offset.top, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = collisionPosTop - offsetTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop, top = data.my[1] === "top", myOffset = top ? -data.elemHeight : data.my[1] === "bottom" ? data.elemHeight : 0, atOffset = data.at[1] === "top" ? data.targetHeight : data.at[1] === "bottom" ? -data.targetHeight : 0, offset = -2 * data.offset[1], newOverTop, newOverBottom;
                if (overTop < 0) {
                    newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                    if (position.top + myOffset + atOffset + offset > overTop && (newOverBottom < 0 || newOverBottom < abs(overTop))) {
                        position.top += myOffset + atOffset + offset;
                    }
                } else if (overBottom > 0) {
                    newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                    if (position.top + myOffset + atOffset + offset > overBottom && (newOverTop > 0 || abs(newOverTop) < overBottom)) {
                        position.top += myOffset + atOffset + offset;
                    }
                }
            }
        },
        flipfit: {
            left: function() {
                $.ui.position.flip.left.apply(this, arguments);
                $.ui.position.fit.left.apply(this, arguments);
            },
            top: function() {
                $.ui.position.flip.top.apply(this, arguments);
                $.ui.position.fit.top.apply(this, arguments);
            }
        }
    };
    (function() {
        var testElement, testElementParent, testElementStyle, offsetLeft, i, body = document.getElementsByTagName("body")[0], div = document.createElement("div");
        testElement = document.createElement(body ? "div" : "body");
        testElementStyle = {
            visibility: "hidden",
            width: 0,
            height: 0,
            border: 0,
            margin: 0,
            background: "none"
        };
        if (body) {
            $.extend(testElementStyle, {
                position: "absolute",
                left: "-1000px",
                top: "-1000px"
            });
        }
        for (i in testElementStyle) {
            testElement.style[i] = testElementStyle[i];
        }
        testElement.appendChild(div);
        testElementParent = body || document.documentElement;
        testElementParent.insertBefore(testElement, testElementParent.firstChild);
        div.style.cssText = "position: absolute; left: 10.7432222px;";
        offsetLeft = $(div).offset().left;
        $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;
        testElement.innerHTML = "";
        testElementParent.removeChild(testElement);
    })();
})(jQuery);

(function($, undefined) {
    $.widget("ui.progressbar", {
        version: "1.10.3",
        options: {
            max: 100,
            value: 0,
            change: null,
            complete: null
        },
        min: 0,
        _create: function() {
            this.oldValue = this.options.value = this._constrainedValue();
            this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({
                role: "progressbar",
                "aria-valuemin": this.min
            });
            this.valueDiv = $("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element);
            this._refreshValue();
        },
        _destroy: function() {
            this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");
            this.valueDiv.remove();
        },
        value: function(newValue) {
            if (newValue === undefined) {
                return this.options.value;
            }
            this.options.value = this._constrainedValue(newValue);
            this._refreshValue();
        },
        _constrainedValue: function(newValue) {
            if (newValue === undefined) {
                newValue = this.options.value;
            }
            this.indeterminate = newValue === false;
            if (typeof newValue !== "number") {
                newValue = 0;
            }
            return this.indeterminate ? false : Math.min(this.options.max, Math.max(this.min, newValue));
        },
        _setOptions: function(options) {
            var value = options.value;
            delete options.value;
            this._super(options);
            this.options.value = this._constrainedValue(value);
            this._refreshValue();
        },
        _setOption: function(key, value) {
            if (key === "max") {
                value = Math.max(this.min, value);
            }
            this._super(key, value);
        },
        _percentage: function() {
            return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
        },
        _refreshValue: function() {
            var value = this.options.value, percentage = this._percentage();
            this.valueDiv.toggle(this.indeterminate || value > this.min).toggleClass("ui-corner-right", value === this.options.max).width(percentage.toFixed(0) + "%");
            this.element.toggleClass("ui-progressbar-indeterminate", this.indeterminate);
            if (this.indeterminate) {
                this.element.removeAttr("aria-valuenow");
                if (!this.overlayDiv) {
                    this.overlayDiv = $("<div class='ui-progressbar-overlay'></div>").appendTo(this.valueDiv);
                }
            } else {
                this.element.attr({
                    "aria-valuemax": this.options.max,
                    "aria-valuenow": value
                });
                if (this.overlayDiv) {
                    this.overlayDiv.remove();
                    this.overlayDiv = null;
                }
            }
            if (this.oldValue !== value) {
                this.oldValue = value;
                this._trigger("change");
            }
            if (value === this.options.max) {
                this._trigger("complete");
            }
        }
    });
})(jQuery);

(function($, undefined) {
    var numPages = 5;
    $.widget("ui.slider", $.ui.mouse, {
        version: "1.10.3",
        widgetEventPrefix: "slide",
        options: {
            animate: false,
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: false,
            step: 1,
            value: 0,
            values: null,
            change: null,
            slide: null,
            start: null,
            stop: null
        },
        _create: function() {
            this._keySliding = false;
            this._mouseSliding = false;
            this._animateOff = true;
            this._handleIndex = null;
            this._detectOrientation();
            this._mouseInit();
            this.element.addClass("ui-slider" + " ui-slider-" + this.orientation + " ui-widget" + " ui-widget-content" + " ui-corner-all");
            this._refresh();
            this._setOption("disabled", this.options.disabled);
            this._animateOff = false;
        },
        _refresh: function() {
            this._createRange();
            this._createHandles();
            this._setupEvents();
            this._refreshValue();
        },
        _createHandles: function() {
            var i, handleCount, options = this.options, existingHandles = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"), handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>", handles = [];
            handleCount = options.values && options.values.length || 1;
            if (existingHandles.length > handleCount) {
                existingHandles.slice(handleCount).remove();
                existingHandles = existingHandles.slice(0, handleCount);
            }
            for (i = existingHandles.length; i < handleCount; i++) {
                handles.push(handle);
            }
            this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));
            this.handle = this.handles.eq(0);
            this.handles.each(function(i) {
                $(this).data("ui-slider-handle-index", i);
            });
        },
        _createRange: function() {
            var options = this.options, classes = "";
            if (options.range) {
                if (options.range === true) {
                    if (!options.values) {
                        options.values = [ this._valueMin(), this._valueMin() ];
                    } else if (options.values.length && options.values.length !== 2) {
                        options.values = [ options.values[0], options.values[0] ];
                    } else if ($.isArray(options.values)) {
                        options.values = options.values.slice(0);
                    }
                }
                if (!this.range || !this.range.length) {
                    this.range = $("<div></div>").appendTo(this.element);
                    classes = "ui-slider-range" + " ui-widget-header ui-corner-all";
                } else {
                    this.range.removeClass("ui-slider-range-min ui-slider-range-max").css({
                        left: "",
                        bottom: ""
                    });
                }
                this.range.addClass(classes + (options.range === "min" || options.range === "max" ? " ui-slider-range-" + options.range : ""));
            } else {
                this.range = $([]);
            }
        },
        _setupEvents: function() {
            var elements = this.handles.add(this.range).filter("a");
            this._off(elements);
            this._on(elements, this._handleEvents);
            this._hoverable(elements);
            this._focusable(elements);
        },
        _destroy: function() {
            this.handles.remove();
            this.range.remove();
            this.element.removeClass("ui-slider" + " ui-slider-horizontal" + " ui-slider-vertical" + " ui-widget" + " ui-widget-content" + " ui-corner-all");
            this._mouseDestroy();
        },
        _mouseCapture: function(event) {
            var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle, that = this, o = this.options;
            if (o.disabled) {
                return false;
            }
            this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            };
            this.elementOffset = this.element.offset();
            position = {
                x: event.pageX,
                y: event.pageY
            };
            normValue = this._normValueFromMouse(position);
            distance = this._valueMax() - this._valueMin() + 1;
            this.handles.each(function(i) {
                var thisDistance = Math.abs(normValue - that.values(i));
                if (distance > thisDistance || distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min)) {
                    distance = thisDistance;
                    closestHandle = $(this);
                    index = i;
                }
            });
            allowed = this._start(event, index);
            if (allowed === false) {
                return false;
            }
            this._mouseSliding = true;
            this._handleIndex = index;
            closestHandle.addClass("ui-state-active").focus();
            offset = closestHandle.offset();
            mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
            this._clickOffset = mouseOverHandle ? {
                left: 0,
                top: 0
            } : {
                left: event.pageX - offset.left - closestHandle.width() / 2,
                top: event.pageY - offset.top - closestHandle.height() / 2 - (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) - (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) + (parseInt(closestHandle.css("marginTop"), 10) || 0)
            };
            if (!this.handles.hasClass("ui-state-hover")) {
                this._slide(event, index, normValue);
            }
            this._animateOff = true;
            return true;
        },
        _mouseStart: function() {
            return true;
        },
        _mouseDrag: function(event) {
            var position = {
                x: event.pageX,
                y: event.pageY
            }, normValue = this._normValueFromMouse(position);
            this._slide(event, this._handleIndex, normValue);
            return false;
        },
        _mouseStop: function(event) {
            this.handles.removeClass("ui-state-active");
            this._mouseSliding = false;
            this._stop(event, this._handleIndex);
            this._change(event, this._handleIndex);
            this._handleIndex = null;
            this._clickOffset = null;
            this._animateOff = false;
            return false;
        },
        _detectOrientation: function() {
            this.orientation = this.options.orientation === "vertical" ? "vertical" : "horizontal";
        },
        _normValueFromMouse: function(position) {
            var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;
            if (this.orientation === "horizontal") {
                pixelTotal = this.elementSize.width;
                pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
            } else {
                pixelTotal = this.elementSize.height;
                pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
            }
            percentMouse = pixelMouse / pixelTotal;
            if (percentMouse > 1) {
                percentMouse = 1;
            }
            if (percentMouse < 0) {
                percentMouse = 0;
            }
            if (this.orientation === "vertical") {
                percentMouse = 1 - percentMouse;
            }
            valueTotal = this._valueMax() - this._valueMin();
            valueMouse = this._valueMin() + percentMouse * valueTotal;
            return this._trimAlignValue(valueMouse);
        },
        _start: function(event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            if (this.options.values && this.options.values.length) {
                uiHash.value = this.values(index);
                uiHash.values = this.values();
            }
            return this._trigger("start", event, uiHash);
        },
        _slide: function(event, index, newVal) {
            var otherVal, newValues, allowed;
            if (this.options.values && this.options.values.length) {
                otherVal = this.values(index ? 0 : 1);
                if (this.options.values.length === 2 && this.options.range === true && (index === 0 && newVal > otherVal || index === 1 && newVal < otherVal)) {
                    newVal = otherVal;
                }
                if (newVal !== this.values(index)) {
                    newValues = this.values();
                    newValues[index] = newVal;
                    allowed = this._trigger("slide", event, {
                        handle: this.handles[index],
                        value: newVal,
                        values: newValues
                    });
                    otherVal = this.values(index ? 0 : 1);
                    if (allowed !== false) {
                        this.values(index, newVal, true);
                    }
                }
            } else {
                if (newVal !== this.value()) {
                    allowed = this._trigger("slide", event, {
                        handle: this.handles[index],
                        value: newVal
                    });
                    if (allowed !== false) {
                        this.value(newVal);
                    }
                }
            }
        },
        _stop: function(event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            if (this.options.values && this.options.values.length) {
                uiHash.value = this.values(index);
                uiHash.values = this.values();
            }
            this._trigger("stop", event, uiHash);
        },
        _change: function(event, index) {
            if (!this._keySliding && !this._mouseSliding) {
                var uiHash = {
                    handle: this.handles[index],
                    value: this.value()
                };
                if (this.options.values && this.options.values.length) {
                    uiHash.value = this.values(index);
                    uiHash.values = this.values();
                }
                this._lastChangedValue = index;
                this._trigger("change", event, uiHash);
            }
        },
        value: function(newValue) {
            if (arguments.length) {
                this.options.value = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, 0);
                return;
            }
            return this._value();
        },
        values: function(index, newValue) {
            var vals, newValues, i;
            if (arguments.length > 1) {
                this.options.values[index] = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, index);
                return;
            }
            if (arguments.length) {
                if ($.isArray(arguments[0])) {
                    vals = this.options.values;
                    newValues = arguments[0];
                    for (i = 0; i < vals.length; i += 1) {
                        vals[i] = this._trimAlignValue(newValues[i]);
                        this._change(null, i);
                    }
                    this._refreshValue();
                } else {
                    if (this.options.values && this.options.values.length) {
                        return this._values(index);
                    } else {
                        return this.value();
                    }
                }
            } else {
                return this._values();
            }
        },
        _setOption: function(key, value) {
            var i, valsLength = 0;
            if (key === "range" && this.options.range === true) {
                if (value === "min") {
                    this.options.value = this._values(0);
                    this.options.values = null;
                } else if (value === "max") {
                    this.options.value = this._values(this.options.values.length - 1);
                    this.options.values = null;
                }
            }
            if ($.isArray(this.options.values)) {
                valsLength = this.options.values.length;
            }
            $.Widget.prototype._setOption.apply(this, arguments);
            switch (key) {
              case "orientation":
                this._detectOrientation();
                this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation);
                this._refreshValue();
                break;

              case "value":
                this._animateOff = true;
                this._refreshValue();
                this._change(null, 0);
                this._animateOff = false;
                break;

              case "values":
                this._animateOff = true;
                this._refreshValue();
                for (i = 0; i < valsLength; i += 1) {
                    this._change(null, i);
                }
                this._animateOff = false;
                break;

              case "min":
              case "max":
                this._animateOff = true;
                this._refreshValue();
                this._animateOff = false;
                break;

              case "range":
                this._animateOff = true;
                this._refresh();
                this._animateOff = false;
                break;
            }
        },
        _value: function() {
            var val = this.options.value;
            val = this._trimAlignValue(val);
            return val;
        },
        _values: function(index) {
            var val, vals, i;
            if (arguments.length) {
                val = this.options.values[index];
                val = this._trimAlignValue(val);
                return val;
            } else if (this.options.values && this.options.values.length) {
                vals = this.options.values.slice();
                for (i = 0; i < vals.length; i += 1) {
                    vals[i] = this._trimAlignValue(vals[i]);
                }
                return vals;
            } else {
                return [];
            }
        },
        _trimAlignValue: function(val) {
            if (val <= this._valueMin()) {
                return this._valueMin();
            }
            if (val >= this._valueMax()) {
                return this._valueMax();
            }
            var step = this.options.step > 0 ? this.options.step : 1, valModStep = (val - this._valueMin()) % step, alignValue = val - valModStep;
            if (Math.abs(valModStep) * 2 >= step) {
                alignValue += valModStep > 0 ? step : -step;
            }
            return parseFloat(alignValue.toFixed(5));
        },
        _valueMin: function() {
            return this.options.min;
        },
        _valueMax: function() {
            return this.options.max;
        },
        _refreshValue: function() {
            var lastValPercent, valPercent, value, valueMin, valueMax, oRange = this.options.range, o = this.options, that = this, animate = !this._animateOff ? o.animate : false, _set = {};
            if (this.options.values && this.options.values.length) {
                this.handles.each(function(i) {
                    valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
                    _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                    $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                    if (that.options.range === true) {
                        if (that.orientation === "horizontal") {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                    left: valPercent + "%"
                                }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({
                                    width: valPercent - lastValPercent + "%"
                                }, {
                                    queue: false,
                                    duration: o.animate
                                });
                            }
                        } else {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                    bottom: valPercent + "%"
                                }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({
                                    height: valPercent - lastValPercent + "%"
                                }, {
                                    queue: false,
                                    duration: o.animate
                                });
                            }
                        }
                    }
                    lastValPercent = valPercent;
                });
            } else {
                value = this.value();
                valueMin = this._valueMin();
                valueMax = this._valueMax();
                valPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;
                _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                if (oRange === "min" && this.orientation === "horizontal") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        width: valPercent + "%"
                    }, o.animate);
                }
                if (oRange === "max" && this.orientation === "horizontal") {
                    this.range[animate ? "animate" : "css"]({
                        width: 100 - valPercent + "%"
                    }, {
                        queue: false,
                        duration: o.animate
                    });
                }
                if (oRange === "min" && this.orientation === "vertical") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        height: valPercent + "%"
                    }, o.animate);
                }
                if (oRange === "max" && this.orientation === "vertical") {
                    this.range[animate ? "animate" : "css"]({
                        height: 100 - valPercent + "%"
                    }, {
                        queue: false,
                        duration: o.animate
                    });
                }
            }
        },
        _handleEvents: {
            keydown: function(event) {
                var allowed, curVal, newVal, step, index = $(event.target).data("ui-slider-handle-index");
                switch (event.keyCode) {
                  case $.ui.keyCode.HOME:
                  case $.ui.keyCode.END:
                  case $.ui.keyCode.PAGE_UP:
                  case $.ui.keyCode.PAGE_DOWN:
                  case $.ui.keyCode.UP:
                  case $.ui.keyCode.RIGHT:
                  case $.ui.keyCode.DOWN:
                  case $.ui.keyCode.LEFT:
                    event.preventDefault();
                    if (!this._keySliding) {
                        this._keySliding = true;
                        $(event.target).addClass("ui-state-active");
                        allowed = this._start(event, index);
                        if (allowed === false) {
                            return;
                        }
                    }
                    break;
                }
                step = this.options.step;
                if (this.options.values && this.options.values.length) {
                    curVal = newVal = this.values(index);
                } else {
                    curVal = newVal = this.value();
                }
                switch (event.keyCode) {
                  case $.ui.keyCode.HOME:
                    newVal = this._valueMin();
                    break;

                  case $.ui.keyCode.END:
                    newVal = this._valueMax();
                    break;

                  case $.ui.keyCode.PAGE_UP:
                    newVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / numPages);
                    break;

                  case $.ui.keyCode.PAGE_DOWN:
                    newVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / numPages);
                    break;

                  case $.ui.keyCode.UP:
                  case $.ui.keyCode.RIGHT:
                    if (curVal === this._valueMax()) {
                        return;
                    }
                    newVal = this._trimAlignValue(curVal + step);
                    break;

                  case $.ui.keyCode.DOWN:
                  case $.ui.keyCode.LEFT:
                    if (curVal === this._valueMin()) {
                        return;
                    }
                    newVal = this._trimAlignValue(curVal - step);
                    break;
                }
                this._slide(event, index, newVal);
            },
            click: function(event) {
                event.preventDefault();
            },
            keyup: function(event) {
                var index = $(event.target).data("ui-slider-handle-index");
                if (this._keySliding) {
                    this._keySliding = false;
                    this._stop(event, index);
                    this._change(event, index);
                    $(event.target).removeClass("ui-state-active");
                }
            }
        }
    });
})(jQuery);

(function($) {
    function modifier(fn) {
        return function() {
            var previous = this.element.val();
            fn.apply(this, arguments);
            this._refresh();
            if (previous !== this.element.val()) {
                this._trigger("change");
            }
        };
    }
    $.widget("ui.spinner", {
        version: "1.10.3",
        defaultElement: "<input>",
        widgetEventPrefix: "spin",
        options: {
            culture: null,
            icons: {
                down: "ui-icon-triangle-1-s",
                up: "ui-icon-triangle-1-n"
            },
            incremental: true,
            max: null,
            min: null,
            numberFormat: null,
            page: 10,
            step: 1,
            change: null,
            spin: null,
            start: null,
            stop: null
        },
        _create: function() {
            this._setOption("max", this.options.max);
            this._setOption("min", this.options.min);
            this._setOption("step", this.options.step);
            this._value(this.element.val(), true);
            this._draw();
            this._on(this._events);
            this._refresh();
            this._on(this.window, {
                beforeunload: function() {
                    this.element.removeAttr("autocomplete");
                }
            });
        },
        _getCreateOptions: function() {
            var options = {}, element = this.element;
            $.each([ "min", "max", "step" ], function(i, option) {
                var value = element.attr(option);
                if (value !== undefined && value.length) {
                    options[option] = value;
                }
            });
            return options;
        },
        _events: {
            keydown: function(event) {
                if (this._start(event) && this._keydown(event)) {
                    event.preventDefault();
                }
            },
            keyup: "_stop",
            focus: function() {
                this.previous = this.element.val();
            },
            blur: function(event) {
                if (this.cancelBlur) {
                    delete this.cancelBlur;
                    return;
                }
                this._stop();
                this._refresh();
                if (this.previous !== this.element.val()) {
                    this._trigger("change", event);
                }
            },
            mousewheel: function(event, delta) {
                if (!delta) {
                    return;
                }
                if (!this.spinning && !this._start(event)) {
                    return false;
                }
                this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
                clearTimeout(this.mousewheelTimer);
                this.mousewheelTimer = this._delay(function() {
                    if (this.spinning) {
                        this._stop(event);
                    }
                }, 100);
                event.preventDefault();
            },
            "mousedown .ui-spinner-button": function(event) {
                var previous;
                previous = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val();
                function checkFocus() {
                    var isActive = this.element[0] === this.document[0].activeElement;
                    if (!isActive) {
                        this.element.focus();
                        this.previous = previous;
                        this._delay(function() {
                            this.previous = previous;
                        });
                    }
                }
                event.preventDefault();
                checkFocus.call(this);
                this.cancelBlur = true;
                this._delay(function() {
                    delete this.cancelBlur;
                    checkFocus.call(this);
                });
                if (this._start(event) === false) {
                    return;
                }
                this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
            },
            "mouseup .ui-spinner-button": "_stop",
            "mouseenter .ui-spinner-button": function(event) {
                if (!$(event.currentTarget).hasClass("ui-state-active")) {
                    return;
                }
                if (this._start(event) === false) {
                    return false;
                }
                this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
            },
            "mouseleave .ui-spinner-button": "_stop"
        },
        _draw: function() {
            var uiSpinner = this.uiSpinner = this.element.addClass("ui-spinner-input").attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
            this.element.attr("role", "spinbutton");
            this.buttons = uiSpinner.find(".ui-spinner-button").attr("tabIndex", -1).button().removeClass("ui-corner-all");
            if (this.buttons.height() > Math.ceil(uiSpinner.height() * .5) && uiSpinner.height() > 0) {
                uiSpinner.height(uiSpinner.height());
            }
            if (this.options.disabled) {
                this.disable();
            }
        },
        _keydown: function(event) {
            var options = this.options, keyCode = $.ui.keyCode;
            switch (event.keyCode) {
              case keyCode.UP:
                this._repeat(null, 1, event);
                return true;

              case keyCode.DOWN:
                this._repeat(null, -1, event);
                return true;

              case keyCode.PAGE_UP:
                this._repeat(null, options.page, event);
                return true;

              case keyCode.PAGE_DOWN:
                this._repeat(null, -options.page, event);
                return true;
            }
            return false;
        },
        _uiSpinnerHtml: function() {
            return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
        },
        _buttonHtml: function() {
            return "" + "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" + "<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" + "</a>" + "<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" + "<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" + "</a>";
        },
        _start: function(event) {
            if (!this.spinning && this._trigger("start", event) === false) {
                return false;
            }
            if (!this.counter) {
                this.counter = 1;
            }
            this.spinning = true;
            return true;
        },
        _repeat: function(i, steps, event) {
            i = i || 500;
            clearTimeout(this.timer);
            this.timer = this._delay(function() {
                this._repeat(40, steps, event);
            }, i);
            this._spin(steps * this.options.step, event);
        },
        _spin: function(step, event) {
            var value = this.value() || 0;
            if (!this.counter) {
                this.counter = 1;
            }
            value = this._adjustValue(value + step * this._increment(this.counter));
            if (!this.spinning || this._trigger("spin", event, {
                value: value
            }) !== false) {
                this._value(value);
                this.counter++;
            }
        },
        _increment: function(i) {
            var incremental = this.options.incremental;
            if (incremental) {
                return $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 5e4 - i * i / 500 + 17 * i / 200 + 1);
            }
            return 1;
        },
        _precision: function() {
            var precision = this._precisionOf(this.options.step);
            if (this.options.min !== null) {
                precision = Math.max(precision, this._precisionOf(this.options.min));
            }
            return precision;
        },
        _precisionOf: function(num) {
            var str = num.toString(), decimal = str.indexOf(".");
            return decimal === -1 ? 0 : str.length - decimal - 1;
        },
        _adjustValue: function(value) {
            var base, aboveMin, options = this.options;
            base = options.min !== null ? options.min : 0;
            aboveMin = value - base;
            aboveMin = Math.round(aboveMin / options.step) * options.step;
            value = base + aboveMin;
            value = parseFloat(value.toFixed(this._precision()));
            if (options.max !== null && value > options.max) {
                return options.max;
            }
            if (options.min !== null && value < options.min) {
                return options.min;
            }
            return value;
        },
        _stop: function(event) {
            if (!this.spinning) {
                return;
            }
            clearTimeout(this.timer);
            clearTimeout(this.mousewheelTimer);
            this.counter = 0;
            this.spinning = false;
            this._trigger("stop", event);
        },
        _setOption: function(key, value) {
            if (key === "culture" || key === "numberFormat") {
                var prevValue = this._parse(this.element.val());
                this.options[key] = value;
                this.element.val(this._format(prevValue));
                return;
            }
            if (key === "max" || key === "min" || key === "step") {
                if (typeof value === "string") {
                    value = this._parse(value);
                }
            }
            if (key === "icons") {
                this.buttons.first().find(".ui-icon").removeClass(this.options.icons.up).addClass(value.up);
                this.buttons.last().find(".ui-icon").removeClass(this.options.icons.down).addClass(value.down);
            }
            this._super(key, value);
            if (key === "disabled") {
                if (value) {
                    this.element.prop("disabled", true);
                    this.buttons.button("disable");
                } else {
                    this.element.prop("disabled", false);
                    this.buttons.button("enable");
                }
            }
        },
        _setOptions: modifier(function(options) {
            this._super(options);
            this._value(this.element.val());
        }),
        _parse: function(val) {
            if (typeof val === "string" && val !== "") {
                val = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val;
            }
            return val === "" || isNaN(val) ? null : val;
        },
        _format: function(value) {
            if (value === "") {
                return "";
            }
            return window.Globalize && this.options.numberFormat ? Globalize.format(value, this.options.numberFormat, this.options.culture) : value;
        },
        _refresh: function() {
            this.element.attr({
                "aria-valuemin": this.options.min,
                "aria-valuemax": this.options.max,
                "aria-valuenow": this._parse(this.element.val())
            });
        },
        _value: function(value, allowAny) {
            var parsed;
            if (value !== "") {
                parsed = this._parse(value);
                if (parsed !== null) {
                    if (!allowAny) {
                        parsed = this._adjustValue(parsed);
                    }
                    value = this._format(parsed);
                }
            }
            this.element.val(value);
            this._refresh();
        },
        _destroy: function() {
            this.element.removeClass("ui-spinner-input").prop("disabled", false).removeAttr("autocomplete").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");
            this.uiSpinner.replaceWith(this.element);
        },
        stepUp: modifier(function(steps) {
            this._stepUp(steps);
        }),
        _stepUp: function(steps) {
            if (this._start()) {
                this._spin((steps || 1) * this.options.step);
                this._stop();
            }
        },
        stepDown: modifier(function(steps) {
            this._stepDown(steps);
        }),
        _stepDown: function(steps) {
            if (this._start()) {
                this._spin((steps || 1) * -this.options.step);
                this._stop();
            }
        },
        pageUp: modifier(function(pages) {
            this._stepUp((pages || 1) * this.options.page);
        }),
        pageDown: modifier(function(pages) {
            this._stepDown((pages || 1) * this.options.page);
        }),
        value: function(newVal) {
            if (!arguments.length) {
                return this._parse(this.element.val());
            }
            modifier(this._value).call(this, newVal);
        },
        widget: function() {
            return this.uiSpinner;
        }
    });
})(jQuery);

(function($, undefined) {
    var tabId = 0, rhash = /#.*$/;
    function getNextTabId() {
        return ++tabId;
    }
    function isLocal(anchor) {
        return anchor.hash.length > 1 && decodeURIComponent(anchor.href.replace(rhash, "")) === decodeURIComponent(location.href.replace(rhash, ""));
    }
    $.widget("ui.tabs", {
        version: "1.10.3",
        delay: 300,
        options: {
            active: null,
            collapsible: false,
            event: "click",
            heightStyle: "content",
            hide: null,
            show: null,
            activate: null,
            beforeActivate: null,
            beforeLoad: null,
            load: null
        },
        _create: function() {
            var that = this, options = this.options;
            this.running = false;
            this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible", options.collapsible).delegate(".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function(event) {
                if ($(this).is(".ui-state-disabled")) {
                    event.preventDefault();
                }
            }).delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
                if ($(this).closest("li").is(".ui-state-disabled")) {
                    this.blur();
                }
            });
            this._processTabs();
            options.active = this._initialActive();
            if ($.isArray(options.disabled)) {
                options.disabled = $.unique(options.disabled.concat($.map(this.tabs.filter(".ui-state-disabled"), function(li) {
                    return that.tabs.index(li);
                }))).sort();
            }
            if (this.options.active !== false && this.anchors.length) {
                this.active = this._findActive(options.active);
            } else {
                this.active = $();
            }
            this._refresh();
            if (this.active.length) {
                this.load(options.active);
            }
        },
        _initialActive: function() {
            var active = this.options.active, collapsible = this.options.collapsible, locationHash = location.hash.substring(1);
            if (active === null) {
                if (locationHash) {
                    this.tabs.each(function(i, tab) {
                        if ($(tab).attr("aria-controls") === locationHash) {
                            active = i;
                            return false;
                        }
                    });
                }
                if (active === null) {
                    active = this.tabs.index(this.tabs.filter(".ui-tabs-active"));
                }
                if (active === null || active === -1) {
                    active = this.tabs.length ? 0 : false;
                }
            }
            if (active !== false) {
                active = this.tabs.index(this.tabs.eq(active));
                if (active === -1) {
                    active = collapsible ? false : 0;
                }
            }
            if (!collapsible && active === false && this.anchors.length) {
                active = 0;
            }
            return active;
        },
        _getCreateEventData: function() {
            return {
                tab: this.active,
                panel: !this.active.length ? $() : this._getPanelForTab(this.active)
            };
        },
        _tabKeydown: function(event) {
            var focusedTab = $(this.document[0].activeElement).closest("li"), selectedIndex = this.tabs.index(focusedTab), goingForward = true;
            if (this._handlePageNav(event)) {
                return;
            }
            switch (event.keyCode) {
              case $.ui.keyCode.RIGHT:
              case $.ui.keyCode.DOWN:
                selectedIndex++;
                break;

              case $.ui.keyCode.UP:
              case $.ui.keyCode.LEFT:
                goingForward = false;
                selectedIndex--;
                break;

              case $.ui.keyCode.END:
                selectedIndex = this.anchors.length - 1;
                break;

              case $.ui.keyCode.HOME:
                selectedIndex = 0;
                break;

              case $.ui.keyCode.SPACE:
                event.preventDefault();
                clearTimeout(this.activating);
                this._activate(selectedIndex);
                return;

              case $.ui.keyCode.ENTER:
                event.preventDefault();
                clearTimeout(this.activating);
                this._activate(selectedIndex === this.options.active ? false : selectedIndex);
                return;

              default:
                return;
            }
            event.preventDefault();
            clearTimeout(this.activating);
            selectedIndex = this._focusNextTab(selectedIndex, goingForward);
            if (!event.ctrlKey) {
                focusedTab.attr("aria-selected", "false");
                this.tabs.eq(selectedIndex).attr("aria-selected", "true");
                this.activating = this._delay(function() {
                    this.option("active", selectedIndex);
                }, this.delay);
            }
        },
        _panelKeydown: function(event) {
            if (this._handlePageNav(event)) {
                return;
            }
            if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
                event.preventDefault();
                this.active.focus();
            }
        },
        _handlePageNav: function(event) {
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
                this._activate(this._focusNextTab(this.options.active - 1, false));
                return true;
            }
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
                this._activate(this._focusNextTab(this.options.active + 1, true));
                return true;
            }
        },
        _findNextTab: function(index, goingForward) {
            var lastTabIndex = this.tabs.length - 1;
            function constrain() {
                if (index > lastTabIndex) {
                    index = 0;
                }
                if (index < 0) {
                    index = lastTabIndex;
                }
                return index;
            }
            while ($.inArray(constrain(), this.options.disabled) !== -1) {
                index = goingForward ? index + 1 : index - 1;
            }
            return index;
        },
        _focusNextTab: function(index, goingForward) {
            index = this._findNextTab(index, goingForward);
            this.tabs.eq(index).focus();
            return index;
        },
        _setOption: function(key, value) {
            if (key === "active") {
                this._activate(value);
                return;
            }
            if (key === "disabled") {
                this._setupDisabled(value);
                return;
            }
            this._super(key, value);
            if (key === "collapsible") {
                this.element.toggleClass("ui-tabs-collapsible", value);
                if (!value && this.options.active === false) {
                    this._activate(0);
                }
            }
            if (key === "event") {
                this._setupEvents(value);
            }
            if (key === "heightStyle") {
                this._setupHeightStyle(value);
            }
        },
        _tabId: function(tab) {
            return tab.attr("aria-controls") || "ui-tabs-" + getNextTabId();
        },
        _sanitizeSelector: function(hash) {
            return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
        },
        refresh: function() {
            var options = this.options, lis = this.tablist.children(":has(a[href])");
            options.disabled = $.map(lis.filter(".ui-state-disabled"), function(tab) {
                return lis.index(tab);
            });
            this._processTabs();
            if (options.active === false || !this.anchors.length) {
                options.active = false;
                this.active = $();
            } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
                if (this.tabs.length === options.disabled.length) {
                    options.active = false;
                    this.active = $();
                } else {
                    this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
                }
            } else {
                options.active = this.tabs.index(this.active);
            }
            this._refresh();
        },
        _refresh: function() {
            this._setupDisabled(this.options.disabled);
            this._setupEvents(this.options.event);
            this._setupHeightStyle(this.options.heightStyle);
            this.tabs.not(this.active).attr({
                "aria-selected": "false",
                tabIndex: -1
            });
            this.panels.not(this._getPanelForTab(this.active)).hide().attr({
                "aria-expanded": "false",
                "aria-hidden": "true"
            });
            if (!this.active.length) {
                this.tabs.eq(0).attr("tabIndex", 0);
            } else {
                this.active.addClass("ui-tabs-active ui-state-active").attr({
                    "aria-selected": "true",
                    tabIndex: 0
                });
                this._getPanelForTab(this.active).show().attr({
                    "aria-expanded": "true",
                    "aria-hidden": "false"
                });
            }
        },
        _processTabs: function() {
            var that = this;
            this.tablist = this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role", "tablist");
            this.tabs = this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({
                role: "tab",
                tabIndex: -1
            });
            this.anchors = this.tabs.map(function() {
                return $("a", this)[0];
            }).addClass("ui-tabs-anchor").attr({
                role: "presentation",
                tabIndex: -1
            });
            this.panels = $();
            this.anchors.each(function(i, anchor) {
                var selector, panel, panelId, anchorId = $(anchor).uniqueId().attr("id"), tab = $(anchor).closest("li"), originalAriaControls = tab.attr("aria-controls");
                if (isLocal(anchor)) {
                    selector = anchor.hash;
                    panel = that.element.find(that._sanitizeSelector(selector));
                } else {
                    panelId = that._tabId(tab);
                    selector = "#" + panelId;
                    panel = that.element.find(selector);
                    if (!panel.length) {
                        panel = that._createPanel(panelId);
                        panel.insertAfter(that.panels[i - 1] || that.tablist);
                    }
                    panel.attr("aria-live", "polite");
                }
                if (panel.length) {
                    that.panels = that.panels.add(panel);
                }
                if (originalAriaControls) {
                    tab.data("ui-tabs-aria-controls", originalAriaControls);
                }
                tab.attr({
                    "aria-controls": selector.substring(1),
                    "aria-labelledby": anchorId
                });
                panel.attr("aria-labelledby", anchorId);
            });
            this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role", "tabpanel");
        },
        _getList: function() {
            return this.element.find("ol,ul").eq(0);
        },
        _createPanel: function(id) {
            return $("<div>").attr("id", id).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy", true);
        },
        _setupDisabled: function(disabled) {
            if ($.isArray(disabled)) {
                if (!disabled.length) {
                    disabled = false;
                } else if (disabled.length === this.anchors.length) {
                    disabled = true;
                }
            }
            for (var i = 0, li; li = this.tabs[i]; i++) {
                if (disabled === true || $.inArray(i, disabled) !== -1) {
                    $(li).addClass("ui-state-disabled").attr("aria-disabled", "true");
                } else {
                    $(li).removeClass("ui-state-disabled").removeAttr("aria-disabled");
                }
            }
            this.options.disabled = disabled;
        },
        _setupEvents: function(event) {
            var events = {
                click: function(event) {
                    event.preventDefault();
                }
            };
            if (event) {
                $.each(event.split(" "), function(index, eventName) {
                    events[eventName] = "_eventHandler";
                });
            }
            this._off(this.anchors.add(this.tabs).add(this.panels));
            this._on(this.anchors, events);
            this._on(this.tabs, {
                keydown: "_tabKeydown"
            });
            this._on(this.panels, {
                keydown: "_panelKeydown"
            });
            this._focusable(this.tabs);
            this._hoverable(this.tabs);
        },
        _setupHeightStyle: function(heightStyle) {
            var maxHeight, parent = this.element.parent();
            if (heightStyle === "fill") {
                maxHeight = parent.height();
                maxHeight -= this.element.outerHeight() - this.element.height();
                this.element.siblings(":visible").each(function() {
                    var elem = $(this), position = elem.css("position");
                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });
                this.element.children().not(this.panels).each(function() {
                    maxHeight -= $(this).outerHeight(true);
                });
                this.panels.each(function() {
                    $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
                }).css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.panels.each(function() {
                    maxHeight = Math.max(maxHeight, $(this).height("").height());
                }).height(maxHeight);
            }
        },
        _eventHandler: function(event) {
            var options = this.options, active = this.active, anchor = $(event.currentTarget), tab = anchor.closest("li"), clickedIsActive = tab[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : this._getPanelForTab(tab), toHide = !active.length ? $() : this._getPanelForTab(active), eventData = {
                oldTab: active,
                oldPanel: toHide,
                newTab: collapsing ? $() : tab,
                newPanel: toShow
            };
            event.preventDefault();
            if (tab.hasClass("ui-state-disabled") || tab.hasClass("ui-tabs-loading") || this.running || clickedIsActive && !options.collapsible || this._trigger("beforeActivate", event, eventData) === false) {
                return;
            }
            options.active = collapsing ? false : this.tabs.index(tab);
            this.active = clickedIsActive ? $() : tab;
            if (this.xhr) {
                this.xhr.abort();
            }
            if (!toHide.length && !toShow.length) {
                $.error("jQuery UI Tabs: Mismatching fragment identifier.");
            }
            if (toShow.length) {
                this.load(this.tabs.index(tab), event);
            }
            this._toggle(event, eventData);
        },
        _toggle: function(event, eventData) {
            var that = this, toShow = eventData.newPanel, toHide = eventData.oldPanel;
            this.running = true;
            function complete() {
                that.running = false;
                that._trigger("activate", event, eventData);
            }
            function show() {
                eventData.newTab.closest("li").addClass("ui-tabs-active ui-state-active");
                if (toShow.length && that.options.show) {
                    that._show(toShow, that.options.show, complete);
                } else {
                    toShow.show();
                    complete();
                }
            }
            if (toHide.length && this.options.hide) {
                this._hide(toHide, this.options.hide, function() {
                    eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
                    show();
                });
            } else {
                eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
                toHide.hide();
                show();
            }
            toHide.attr({
                "aria-expanded": "false",
                "aria-hidden": "true"
            });
            eventData.oldTab.attr("aria-selected", "false");
            if (toShow.length && toHide.length) {
                eventData.oldTab.attr("tabIndex", -1);
            } else if (toShow.length) {
                this.tabs.filter(function() {
                    return $(this).attr("tabIndex") === 0;
                }).attr("tabIndex", -1);
            }
            toShow.attr({
                "aria-expanded": "true",
                "aria-hidden": "false"
            });
            eventData.newTab.attr({
                "aria-selected": "true",
                tabIndex: 0
            });
        },
        _activate: function(index) {
            var anchor, active = this._findActive(index);
            if (active[0] === this.active[0]) {
                return;
            }
            if (!active.length) {
                active = this.active;
            }
            anchor = active.find(".ui-tabs-anchor")[0];
            this._eventHandler({
                target: anchor,
                currentTarget: anchor,
                preventDefault: $.noop
            });
        },
        _findActive: function(index) {
            return index === false ? $() : this.tabs.eq(index);
        },
        _getIndex: function(index) {
            if (typeof index === "string") {
                index = this.anchors.index(this.anchors.filter("[href$='" + index + "']"));
            }
            return index;
        },
        _destroy: function() {
            if (this.xhr) {
                this.xhr.abort();
            }
            this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible");
            this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role");
            this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeUniqueId();
            this.tabs.add(this.panels).each(function() {
                if ($.data(this, "ui-tabs-destroy")) {
                    $(this).remove();
                } else {
                    $(this).removeClass("ui-state-default ui-state-active ui-state-disabled " + "ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role");
                }
            });
            this.tabs.each(function() {
                var li = $(this), prev = li.data("ui-tabs-aria-controls");
                if (prev) {
                    li.attr("aria-controls", prev).removeData("ui-tabs-aria-controls");
                } else {
                    li.removeAttr("aria-controls");
                }
            });
            this.panels.show();
            if (this.options.heightStyle !== "content") {
                this.panels.css("height", "");
            }
        },
        enable: function(index) {
            var disabled = this.options.disabled;
            if (disabled === false) {
                return;
            }
            if (index === undefined) {
                disabled = false;
            } else {
                index = this._getIndex(index);
                if ($.isArray(disabled)) {
                    disabled = $.map(disabled, function(num) {
                        return num !== index ? num : null;
                    });
                } else {
                    disabled = $.map(this.tabs, function(li, num) {
                        return num !== index ? num : null;
                    });
                }
            }
            this._setupDisabled(disabled);
        },
        disable: function(index) {
            var disabled = this.options.disabled;
            if (disabled === true) {
                return;
            }
            if (index === undefined) {
                disabled = true;
            } else {
                index = this._getIndex(index);
                if ($.inArray(index, disabled) !== -1) {
                    return;
                }
                if ($.isArray(disabled)) {
                    disabled = $.merge([ index ], disabled).sort();
                } else {
                    disabled = [ index ];
                }
            }
            this._setupDisabled(disabled);
        },
        load: function(index, event) {
            index = this._getIndex(index);
            var that = this, tab = this.tabs.eq(index), anchor = tab.find(".ui-tabs-anchor"), panel = this._getPanelForTab(tab), eventData = {
                tab: tab,
                panel: panel
            };
            if (isLocal(anchor[0])) {
                return;
            }
            this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));
            if (this.xhr && this.xhr.statusText !== "canceled") {
                tab.addClass("ui-tabs-loading");
                panel.attr("aria-busy", "true");
                this.xhr.success(function(response) {
                    setTimeout(function() {
                        panel.html(response);
                        that._trigger("load", event, eventData);
                    }, 1);
                }).complete(function(jqXHR, status) {
                    setTimeout(function() {
                        if (status === "abort") {
                            that.panels.stop(false, true);
                        }
                        tab.removeClass("ui-tabs-loading");
                        panel.removeAttr("aria-busy");
                        if (jqXHR === that.xhr) {
                            delete that.xhr;
                        }
                    }, 1);
                });
            }
        },
        _ajaxSettings: function(anchor, event, eventData) {
            var that = this;
            return {
                url: anchor.attr("href"),
                beforeSend: function(jqXHR, settings) {
                    return that._trigger("beforeLoad", event, $.extend({
                        jqXHR: jqXHR,
                        ajaxSettings: settings
                    }, eventData));
                }
            };
        },
        _getPanelForTab: function(tab) {
            var id = $(tab).attr("aria-controls");
            return this.element.find(this._sanitizeSelector("#" + id));
        }
    });
})(jQuery);

(function($) {
    var increments = 0;
    function addDescribedBy(elem, id) {
        var describedby = (elem.attr("aria-describedby") || "").split(/\s+/);
        describedby.push(id);
        elem.data("ui-tooltip-id", id).attr("aria-describedby", $.trim(describedby.join(" ")));
    }
    function removeDescribedBy(elem) {
        var id = elem.data("ui-tooltip-id"), describedby = (elem.attr("aria-describedby") || "").split(/\s+/), index = $.inArray(id, describedby);
        if (index !== -1) {
            describedby.splice(index, 1);
        }
        elem.removeData("ui-tooltip-id");
        describedby = $.trim(describedby.join(" "));
        if (describedby) {
            elem.attr("aria-describedby", describedby);
        } else {
            elem.removeAttr("aria-describedby");
        }
    }
    $.widget("ui.tooltip", {
        version: "1.10.3",
        options: {
            content: function() {
                var title = $(this).attr("title") || "";
                return $("<a>").text(title).html();
            },
            hide: true,
            items: "[title]:not([disabled])",
            position: {
                my: "left top+15",
                at: "left bottom",
                collision: "flipfit flip"
            },
            show: true,
            tooltipClass: null,
            track: false,
            close: null,
            open: null
        },
        _create: function() {
            this._on({
                mouseover: "open",
                focusin: "open"
            });
            this.tooltips = {};
            this.parents = {};
            if (this.options.disabled) {
                this._disable();
            }
        },
        _setOption: function(key, value) {
            var that = this;
            if (key === "disabled") {
                this[value ? "_disable" : "_enable"]();
                this.options[key] = value;
                return;
            }
            this._super(key, value);
            if (key === "content") {
                $.each(this.tooltips, function(id, element) {
                    that._updateContent(element);
                });
            }
        },
        _disable: function() {
            var that = this;
            $.each(this.tooltips, function(id, element) {
                var event = $.Event("blur");
                event.target = event.currentTarget = element[0];
                that.close(event, true);
            });
            this.element.find(this.options.items).addBack().each(function() {
                var element = $(this);
                if (element.is("[title]")) {
                    element.data("ui-tooltip-title", element.attr("title")).attr("title", "");
                }
            });
        },
        _enable: function() {
            this.element.find(this.options.items).addBack().each(function() {
                var element = $(this);
                if (element.data("ui-tooltip-title")) {
                    element.attr("title", element.data("ui-tooltip-title"));
                }
            });
        },
        open: function(event) {
            var that = this, target = $(event ? event.target : this.element).closest(this.options.items);
            if (!target.length || target.data("ui-tooltip-id")) {
                return;
            }
            if (target.attr("title")) {
                target.data("ui-tooltip-title", target.attr("title"));
            }
            target.data("ui-tooltip-open", true);
            if (event && event.type === "mouseover") {
                target.parents().each(function() {
                    var parent = $(this), blurEvent;
                    if (parent.data("ui-tooltip-open")) {
                        blurEvent = $.Event("blur");
                        blurEvent.target = blurEvent.currentTarget = this;
                        that.close(blurEvent, true);
                    }
                    if (parent.attr("title")) {
                        parent.uniqueId();
                        that.parents[this.id] = {
                            element: this,
                            title: parent.attr("title")
                        };
                        parent.attr("title", "");
                    }
                });
            }
            this._updateContent(target, event);
        },
        _updateContent: function(target, event) {
            var content, contentOption = this.options.content, that = this, eventType = event ? event.type : null;
            if (typeof contentOption === "string") {
                return this._open(event, target, contentOption);
            }
            content = contentOption.call(target[0], function(response) {
                if (!target.data("ui-tooltip-open")) {
                    return;
                }
                that._delay(function() {
                    if (event) {
                        event.type = eventType;
                    }
                    this._open(event, target, response);
                });
            });
            if (content) {
                this._open(event, target, content);
            }
        },
        _open: function(event, target, content) {
            var tooltip, events, delayedShow, positionOption = $.extend({}, this.options.position);
            if (!content) {
                return;
            }
            tooltip = this._find(target);
            if (tooltip.length) {
                tooltip.find(".ui-tooltip-content").html(content);
                return;
            }
            if (target.is("[title]")) {
                if (event && event.type === "mouseover") {
                    target.attr("title", "");
                } else {
                    target.removeAttr("title");
                }
            }
            tooltip = this._tooltip(target);
            addDescribedBy(target, tooltip.attr("id"));
            tooltip.find(".ui-tooltip-content").html(content);
            function position(event) {
                positionOption.of = event;
                if (tooltip.is(":hidden")) {
                    return;
                }
                tooltip.position(positionOption);
            }
            if (this.options.track && event && /^mouse/.test(event.type)) {
                this._on(this.document, {
                    mousemove: position
                });
                position(event);
            } else {
                tooltip.position($.extend({
                    of: target
                }, this.options.position));
            }
            tooltip.hide();
            this._show(tooltip, this.options.show);
            if (this.options.show && this.options.show.delay) {
                delayedShow = this.delayedShow = setInterval(function() {
                    if (tooltip.is(":visible")) {
                        position(positionOption.of);
                        clearInterval(delayedShow);
                    }
                }, $.fx.interval);
            }
            this._trigger("open", event, {
                tooltip: tooltip
            });
            events = {
                keyup: function(event) {
                    if (event.keyCode === $.ui.keyCode.ESCAPE) {
                        var fakeEvent = $.Event(event);
                        fakeEvent.currentTarget = target[0];
                        this.close(fakeEvent, true);
                    }
                },
                remove: function() {
                    this._removeTooltip(tooltip);
                }
            };
            if (!event || event.type === "mouseover") {
                events.mouseleave = "close";
            }
            if (!event || event.type === "focusin") {
                events.focusout = "close";
            }
            this._on(true, target, events);
        },
        close: function(event) {
            var that = this, target = $(event ? event.currentTarget : this.element), tooltip = this._find(target);
            if (this.closing) {
                return;
            }
            clearInterval(this.delayedShow);
            if (target.data("ui-tooltip-title")) {
                target.attr("title", target.data("ui-tooltip-title"));
            }
            removeDescribedBy(target);
            tooltip.stop(true);
            this._hide(tooltip, this.options.hide, function() {
                that._removeTooltip($(this));
            });
            target.removeData("ui-tooltip-open");
            this._off(target, "mouseleave focusout keyup");
            if (target[0] !== this.element[0]) {
                this._off(target, "remove");
            }
            this._off(this.document, "mousemove");
            if (event && event.type === "mouseleave") {
                $.each(this.parents, function(id, parent) {
                    $(parent.element).attr("title", parent.title);
                    delete that.parents[id];
                });
            }
            this.closing = true;
            this._trigger("close", event, {
                tooltip: tooltip
            });
            this.closing = false;
        },
        _tooltip: function(element) {
            var id = "ui-tooltip-" + increments++, tooltip = $("<div>").attr({
                id: id,
                role: "tooltip"
            }).addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content " + (this.options.tooltipClass || ""));
            $("<div>").addClass("ui-tooltip-content").appendTo(tooltip);
            tooltip.appendTo(this.document[0].body);
            this.tooltips[id] = element;
            return tooltip;
        },
        _find: function(target) {
            var id = target.data("ui-tooltip-id");
            return id ? $("#" + id) : $();
        },
        _removeTooltip: function(tooltip) {
            tooltip.remove();
            delete this.tooltips[tooltip.attr("id")];
        },
        _destroy: function() {
            var that = this;
            $.each(this.tooltips, function(id, element) {
                var event = $.Event("blur");
                event.target = event.currentTarget = element[0];
                that.close(event, true);
                $("#" + id).remove();
                if (element.data("ui-tooltip-title")) {
                    element.attr("title", element.data("ui-tooltip-title"));
                    element.removeData("ui-tooltip-title");
                }
            });
        }
    });
})(jQuery);

(function($) {
    $.ui.timepicker = $.ui.timepicker || {};
    if ($.ui.timepicker.version) {
        return;
    }
    $.extend($.ui, {
        timepicker: {
            version: "1.0.3"
        }
    });
    function Timepicker() {
        this.regional = [];
        this.regional[""] = {
            currentText: "Now",
            closeText: "Done",
            ampm: false,
            amNames: [ "AM", "A" ],
            pmNames: [ "PM", "P" ],
            timeFormat: "hh:mm tt",
            timeSuffix: "",
            timeOnlyTitle: "Choose Time",
            timeText: "Time",
            hourText: "Hour",
            minuteText: "Minute",
            secondText: "Second",
            millisecText: "Millisecond",
            timezoneText: "Time Zone"
        };
        this._defaults = {
            showButtonPanel: true,
            timeOnly: false,
            showHour: true,
            showMinute: true,
            showSecond: false,
            showMillisec: false,
            showTimezone: false,
            showTime: true,
            stepHour: 1,
            stepMinute: 1,
            stepSecond: 1,
            stepMillisec: 1,
            hour: 0,
            minute: 0,
            second: 0,
            millisec: 0,
            timezone: null,
            useLocalTimezone: false,
            defaultTimezone: "+0000",
            hourMin: 0,
            minuteMin: 0,
            secondMin: 0,
            millisecMin: 0,
            hourMax: 23,
            minuteMax: 59,
            secondMax: 59,
            millisecMax: 999,
            minDateTime: null,
            maxDateTime: null,
            onSelect: null,
            hourGrid: 0,
            minuteGrid: 0,
            secondGrid: 0,
            millisecGrid: 0,
            alwaysSetTime: true,
            separator: " ",
            altFieldTimeOnly: true,
            altSeparator: null,
            altTimeSuffix: null,
            showTimepicker: true,
            timezoneIso8601: false,
            timezoneList: null,
            addSliderAccess: false,
            sliderAccessArgs: null,
            defaultValue: null
        };
        $.extend(this._defaults, this.regional[""]);
    }
    $.extend(Timepicker.prototype, {
        $input: null,
        $altInput: null,
        $timeObj: null,
        inst: null,
        hour_slider: null,
        minute_slider: null,
        second_slider: null,
        millisec_slider: null,
        timezone_select: null,
        hour: 0,
        minute: 0,
        second: 0,
        millisec: 0,
        timezone: null,
        defaultTimezone: "+0000",
        hourMinOriginal: null,
        minuteMinOriginal: null,
        secondMinOriginal: null,
        millisecMinOriginal: null,
        hourMaxOriginal: null,
        minuteMaxOriginal: null,
        secondMaxOriginal: null,
        millisecMaxOriginal: null,
        ampm: "",
        formattedDate: "",
        formattedTime: "",
        formattedDateTime: "",
        timezoneList: null,
        units: [ "hour", "minute", "second", "millisec" ],
        setDefaults: function(settings) {
            extendRemove(this._defaults, settings || {});
            return this;
        },
        _newInst: function($input, o) {
            var tp_inst = new Timepicker(), inlineSettings = {};
            for (var attrName in this._defaults) {
                if (this._defaults.hasOwnProperty(attrName)) {
                    var attrValue = $input.attr("time:" + attrName);
                    if (attrValue) {
                        try {
                            inlineSettings[attrName] = eval(attrValue);
                        } catch (err) {
                            inlineSettings[attrName] = attrValue;
                        }
                    }
                }
            }
            tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, o, {
                beforeShow: function(input, dp_inst) {
                    if ($.isFunction(o.beforeShow)) {
                        return o.beforeShow(input, dp_inst, tp_inst);
                    }
                },
                onChangeMonthYear: function(year, month, dp_inst) {
                    tp_inst._updateDateTime(dp_inst);
                    if ($.isFunction(o.onChangeMonthYear)) {
                        o.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst);
                    }
                },
                onClose: function(dateText, dp_inst) {
                    if (tp_inst.timeDefined === true && $input.val() !== "") {
                        tp_inst._updateDateTime(dp_inst);
                    }
                    if ($.isFunction(o.onClose)) {
                        o.onClose.call($input[0], dateText, dp_inst, tp_inst);
                    }
                },
                timepicker: tp_inst
            });
            tp_inst.amNames = $.map(tp_inst._defaults.amNames, function(val) {
                return val.toUpperCase();
            });
            tp_inst.pmNames = $.map(tp_inst._defaults.pmNames, function(val) {
                return val.toUpperCase();
            });
            if (tp_inst._defaults.timezoneList === null) {
                var timezoneList = [ "-1200", "-1100", "-1000", "-0930", "-0900", "-0800", "-0700", "-0600", "-0500", "-0430", "-0400", "-0330", "-0300", "-0200", "-0100", "+0000", "+0100", "+0200", "+0300", "+0330", "+0400", "+0430", "+0500", "+0530", "+0545", "+0600", "+0630", "+0700", "+0800", "+0845", "+0900", "+0930", "+1000", "+1030", "+1100", "+1130", "+1200", "+1245", "+1300", "+1400" ];
                if (tp_inst._defaults.timezoneIso8601) {
                    timezoneList = $.map(timezoneList, function(val) {
                        return val == "+0000" ? "Z" : val.substring(0, 3) + ":" + val.substring(3);
                    });
                }
                tp_inst._defaults.timezoneList = timezoneList;
            }
            tp_inst.timezone = tp_inst._defaults.timezone;
            tp_inst.hour = tp_inst._defaults.hour;
            tp_inst.minute = tp_inst._defaults.minute;
            tp_inst.second = tp_inst._defaults.second;
            tp_inst.millisec = tp_inst._defaults.millisec;
            tp_inst.ampm = "";
            tp_inst.$input = $input;
            if (o.altField) {
                tp_inst.$altInput = $(o.altField).css({
                    cursor: "pointer"
                }).focus(function() {
                    $input.trigger("focus");
                });
            }
            if (tp_inst._defaults.minDate === 0 || tp_inst._defaults.minDateTime === 0) {
                tp_inst._defaults.minDate = new Date();
            }
            if (tp_inst._defaults.maxDate === 0 || tp_inst._defaults.maxDateTime === 0) {
                tp_inst._defaults.maxDate = new Date();
            }
            if (tp_inst._defaults.minDate !== undefined && tp_inst._defaults.minDate instanceof Date) {
                tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime());
            }
            if (tp_inst._defaults.minDateTime !== undefined && tp_inst._defaults.minDateTime instanceof Date) {
                tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime());
            }
            if (tp_inst._defaults.maxDate !== undefined && tp_inst._defaults.maxDate instanceof Date) {
                tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime());
            }
            if (tp_inst._defaults.maxDateTime !== undefined && tp_inst._defaults.maxDateTime instanceof Date) {
                tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime());
            }
            tp_inst.$input.bind("focus", function() {
                tp_inst._onFocus();
            });
            return tp_inst;
        },
        _addTimePicker: function(dp_inst) {
            var currDT = this.$altInput && this._defaults.altFieldTimeOnly ? this.$input.val() + " " + this.$altInput.val() : this.$input.val();
            this.timeDefined = this._parseTime(currDT);
            this._limitMinMaxDateTime(dp_inst, false);
            this._injectTimePicker();
        },
        _parseTime: function(timeString, withDate) {
            if (!this.inst) {
                this.inst = $.datepicker._getInst(this.$input[0]);
            }
            if (withDate || !this._defaults.timeOnly) {
                var dp_dateFormat = $.datepicker._get(this.inst, "dateFormat");
                try {
                    var parseRes = parseDateTimeInternal(dp_dateFormat, this._defaults.timeFormat, timeString, $.datepicker._getFormatConfig(this.inst), this._defaults);
                    if (!parseRes.timeObj) {
                        return false;
                    }
                    $.extend(this, parseRes.timeObj);
                } catch (err) {
                    return false;
                }
                return true;
            } else {
                var timeObj = $.datepicker.parseTime(this._defaults.timeFormat, timeString, this._defaults);
                if (!timeObj) {
                    return false;
                }
                $.extend(this, timeObj);
                return true;
            }
        },
        _injectTimePicker: function() {
            var $dp = this.inst.dpDiv, o = this.inst.settings, tp_inst = this, litem = "", uitem = "", max = {}, gridSize = {}, size = null;
            if ($dp.find("div.ui-timepicker-div").length === 0 && o.showTimepicker) {
                var noDisplay = ' style="display:none;"', html = '<div class="ui-timepicker-div"><dl>' + '<dt class="ui_tpicker_time_label"' + (o.showTime ? "" : noDisplay) + ">" + o.timeText + "</dt>" + '<dd class="ui_tpicker_time"' + (o.showTime ? "" : noDisplay) + "></dd>";
                for (var i = 0, l = this.units.length; i < l; i++) {
                    litem = this.units[i];
                    uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
                    max[litem] = parseInt(o[litem + "Max"] - (o[litem + "Max"] - o[litem + "Min"]) % o["step" + uitem], 10);
                    gridSize[litem] = 0;
                    html += '<dt class="ui_tpicker_' + litem + '_label"' + (o["show" + uitem] ? "" : noDisplay) + ">" + o[litem + "Text"] + "</dt>" + '<dd class="ui_tpicker_' + litem + '"><div class="ui_tpicker_' + litem + '_slider"' + (o["show" + uitem] ? "" : noDisplay) + "></div>";
                    if (o["show" + uitem] && o[litem + "Grid"] > 0) {
                        html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';
                        if (litem == "hour") {
                            for (var h = o[litem + "Min"]; h <= max[litem]; h += parseInt(o[litem + "Grid"], 10)) {
                                gridSize[litem]++;
                                var tmph = o.ampm && h > 12 ? h - 12 : h;
                                if (tmph < 10) {
                                    tmph = "0" + tmph;
                                }
                                if (o.ampm) {
                                    if (h === 0) {
                                        tmph = 12 + "a";
                                    } else {
                                        if (h < 12) {
                                            tmph += "a";
                                        } else {
                                            tmph += "p";
                                        }
                                    }
                                }
                                html += '<td data-for="' + litem + '">' + tmph + "</td>";
                            }
                        } else {
                            for (var m = o[litem + "Min"]; m <= max[litem]; m += parseInt(o[litem + "Grid"], 10)) {
                                gridSize[litem]++;
                                html += '<td data-for="' + litem + '">' + (m < 10 ? "0" : "") + m + "</td>";
                            }
                        }
                        html += "</tr></table></div>";
                    }
                    html += "</dd>";
                }
                html += '<dt class="ui_tpicker_timezone_label"' + (o.showTimezone ? "" : noDisplay) + ">" + o.timezoneText + "</dt>";
                html += '<dd class="ui_tpicker_timezone" ' + (o.showTimezone ? "" : noDisplay) + "></dd>";
                html += "</dl></div>";
                var $tp = $(html);
                if (o.timeOnly === true) {
                    $tp.prepend('<div class="ui-widget-header ui-helper-clearfix ui-corner-all">' + '<div class="ui-datepicker-title">' + o.timeOnlyTitle + "</div>" + "</div>");
                    $dp.find(".ui-datepicker-header, .ui-datepicker-calendar").hide();
                }
                this.hour_slider = $tp.find(".ui_tpicker_hour_slider").prop("slide", null).slider({
                    orientation: "horizontal",
                    value: this.hour,
                    min: o.hourMin,
                    max: max.hour,
                    step: o.stepHour,
                    slide: function(event, ui) {
                        tp_inst.hour_slider.slider("option", "value", ui.value);
                        tp_inst._onTimeChange();
                    },
                    stop: function(event, ui) {
                        tp_inst._onSelectHandler();
                    }
                });
                this.minute_slider = $tp.find(".ui_tpicker_minute_slider").prop("slide", null).slider({
                    orientation: "horizontal",
                    value: this.minute,
                    min: o.minuteMin,
                    max: max.minute,
                    step: o.stepMinute,
                    slide: function(event, ui) {
                        tp_inst.minute_slider.slider("option", "value", ui.value);
                        tp_inst._onTimeChange();
                    },
                    stop: function(event, ui) {
                        tp_inst._onSelectHandler();
                    }
                });
                this.second_slider = $tp.find(".ui_tpicker_second_slider").prop("slide", null).slider({
                    orientation: "horizontal",
                    value: this.second,
                    min: o.secondMin,
                    max: max.second,
                    step: o.stepSecond,
                    slide: function(event, ui) {
                        tp_inst.second_slider.slider("option", "value", ui.value);
                        tp_inst._onTimeChange();
                    },
                    stop: function(event, ui) {
                        tp_inst._onSelectHandler();
                    }
                });
                this.millisec_slider = $tp.find(".ui_tpicker_millisec_slider").prop("slide", null).slider({
                    orientation: "horizontal",
                    value: this.millisec,
                    min: o.millisecMin,
                    max: max.millisec,
                    step: o.stepMillisec,
                    slide: function(event, ui) {
                        tp_inst.millisec_slider.slider("option", "value", ui.value);
                        tp_inst._onTimeChange();
                    },
                    stop: function(event, ui) {
                        tp_inst._onSelectHandler();
                    }
                });
                for (var i = 0, l = tp_inst.units.length; i < l; i++) {
                    litem = tp_inst.units[i];
                    uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
                    if (o["show" + uitem] && o[litem + "Grid"] > 0) {
                        size = 100 * gridSize[litem] * o[litem + "Grid"] / (max[litem] - o[litem + "Min"]);
                        $tp.find(".ui_tpicker_" + litem + " table").css({
                            width: size + "%",
                            marginLeft: size / (-2 * gridSize[litem]) + "%",
                            borderCollapse: "collapse"
                        }).find("td").click(function(e) {
                            var $t = $(this), h = $t.html(), f = $t.data("for");
                            if (f == "hour" && o.ampm) {
                                var ap = h.substring(2).toLowerCase(), aph = parseInt(h.substring(0, 2), 10);
                                if (ap == "a") {
                                    if (aph == 12) {
                                        h = 0;
                                    } else {
                                        h = aph;
                                    }
                                } else if (aph == 12) {
                                    h = 12;
                                } else {
                                    h = aph + 12;
                                }
                            }
                            tp_inst[f + "_slider"].slider("option", "value", parseInt(h, 10));
                            tp_inst._onTimeChange();
                            tp_inst._onSelectHandler();
                        }).css({
                            cursor: "pointer",
                            width: 100 / gridSize[litem] + "%",
                            textAlign: "center",
                            overflow: "hidden"
                        });
                    }
                }
                this.timezone_select = $tp.find(".ui_tpicker_timezone").append("<select></select>").find("select");
                $.fn.append.apply(this.timezone_select, $.map(o.timezoneList, function(val, idx) {
                    return $("<option />").val(typeof val == "object" ? val.value : val).text(typeof val == "object" ? val.label : val);
                }));
                if (typeof this.timezone != "undefined" && this.timezone !== null && this.timezone !== "") {
                    var local_date = new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12);
                    var local_timezone = $.timepicker.timeZoneOffsetString(local_date);
                    if (local_timezone == this.timezone) {
                        selectLocalTimeZone(tp_inst);
                    } else {
                        this.timezone_select.val(this.timezone);
                    }
                } else {
                    if (typeof this.hour != "undefined" && this.hour !== null && this.hour !== "") {
                        this.timezone_select.val(o.defaultTimezone);
                    } else {
                        selectLocalTimeZone(tp_inst);
                    }
                }
                this.timezone_select.change(function() {
                    tp_inst._defaults.useLocalTimezone = false;
                    tp_inst._onTimeChange();
                });
                var $buttonPanel = $dp.find(".ui-datepicker-buttonpane");
                if ($buttonPanel.length) {
                    $buttonPanel.before($tp);
                } else {
                    $dp.append($tp);
                }
                this.$timeObj = $tp.find(".ui_tpicker_time");
                if (this.inst !== null) {
                    var timeDefined = this.timeDefined;
                    this._onTimeChange();
                    this.timeDefined = timeDefined;
                }
                if (this._defaults.addSliderAccess) {
                    var sliderAccessArgs = this._defaults.sliderAccessArgs;
                    setTimeout(function() {
                        if ($tp.find(".ui-slider-access").length === 0) {
                            $tp.find(".ui-slider:visible").sliderAccess(sliderAccessArgs);
                            var sliderAccessWidth = $tp.find(".ui-slider-access:eq(0)").outerWidth(true);
                            if (sliderAccessWidth) {
                                $tp.find("table:visible").each(function() {
                                    var $g = $(this), oldWidth = $g.outerWidth(), oldMarginLeft = $g.css("marginLeft").toString().replace("%", ""), newWidth = oldWidth - sliderAccessWidth, newMarginLeft = oldMarginLeft * newWidth / oldWidth + "%";
                                    $g.css({
                                        width: newWidth,
                                        marginLeft: newMarginLeft
                                    });
                                });
                            }
                        }
                    }, 10);
                }
            }
        },
        _limitMinMaxDateTime: function(dp_inst, adjustSliders) {
            var o = this._defaults, dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay);
            if (!this._defaults.showTimepicker) {
                return;
            }
            if ($.datepicker._get(dp_inst, "minDateTime") !== null && $.datepicker._get(dp_inst, "minDateTime") !== undefined && dp_date) {
                var minDateTime = $.datepicker._get(dp_inst, "minDateTime"), minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0);
                if (this.hourMinOriginal === null || this.minuteMinOriginal === null || this.secondMinOriginal === null || this.millisecMinOriginal === null) {
                    this.hourMinOriginal = o.hourMin;
                    this.minuteMinOriginal = o.minuteMin;
                    this.secondMinOriginal = o.secondMin;
                    this.millisecMinOriginal = o.millisecMin;
                }
                if (dp_inst.settings.timeOnly || minDateTimeDate.getTime() == dp_date.getTime()) {
                    this._defaults.hourMin = minDateTime.getHours();
                    if (this.hour <= this._defaults.hourMin) {
                        this.hour = this._defaults.hourMin;
                        this._defaults.minuteMin = minDateTime.getMinutes();
                        if (this.minute <= this._defaults.minuteMin) {
                            this.minute = this._defaults.minuteMin;
                            this._defaults.secondMin = minDateTime.getSeconds();
                            if (this.second <= this._defaults.secondMin) {
                                this.second = this._defaults.secondMin;
                                this._defaults.millisecMin = minDateTime.getMilliseconds();
                            } else {
                                if (this.millisec < this._defaults.millisecMin) {
                                    this.millisec = this._defaults.millisecMin;
                                }
                                this._defaults.millisecMin = this.millisecMinOriginal;
                            }
                        } else {
                            this._defaults.secondMin = this.secondMinOriginal;
                            this._defaults.millisecMin = this.millisecMinOriginal;
                        }
                    } else {
                        this._defaults.minuteMin = this.minuteMinOriginal;
                        this._defaults.secondMin = this.secondMinOriginal;
                        this._defaults.millisecMin = this.millisecMinOriginal;
                    }
                } else {
                    this._defaults.hourMin = this.hourMinOriginal;
                    this._defaults.minuteMin = this.minuteMinOriginal;
                    this._defaults.secondMin = this.secondMinOriginal;
                    this._defaults.millisecMin = this.millisecMinOriginal;
                }
            }
            if ($.datepicker._get(dp_inst, "maxDateTime") !== null && $.datepicker._get(dp_inst, "maxDateTime") !== undefined && dp_date) {
                var maxDateTime = $.datepicker._get(dp_inst, "maxDateTime"), maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0);
                if (this.hourMaxOriginal === null || this.minuteMaxOriginal === null || this.secondMaxOriginal === null) {
                    this.hourMaxOriginal = o.hourMax;
                    this.minuteMaxOriginal = o.minuteMax;
                    this.secondMaxOriginal = o.secondMax;
                    this.millisecMaxOriginal = o.millisecMax;
                }
                if (dp_inst.settings.timeOnly || maxDateTimeDate.getTime() == dp_date.getTime()) {
                    this._defaults.hourMax = maxDateTime.getHours();
                    if (this.hour >= this._defaults.hourMax) {
                        this.hour = this._defaults.hourMax;
                        this._defaults.minuteMax = maxDateTime.getMinutes();
                        if (this.minute >= this._defaults.minuteMax) {
                            this.minute = this._defaults.minuteMax;
                            this._defaults.secondMax = maxDateTime.getSeconds();
                        } else if (this.second >= this._defaults.secondMax) {
                            this.second = this._defaults.secondMax;
                            this._defaults.millisecMax = maxDateTime.getMilliseconds();
                        } else {
                            if (this.millisec > this._defaults.millisecMax) {
                                this.millisec = this._defaults.millisecMax;
                            }
                            this._defaults.millisecMax = this.millisecMaxOriginal;
                        }
                    } else {
                        this._defaults.minuteMax = this.minuteMaxOriginal;
                        this._defaults.secondMax = this.secondMaxOriginal;
                        this._defaults.millisecMax = this.millisecMaxOriginal;
                    }
                } else {
                    this._defaults.hourMax = this.hourMaxOriginal;
                    this._defaults.minuteMax = this.minuteMaxOriginal;
                    this._defaults.secondMax = this.secondMaxOriginal;
                    this._defaults.millisecMax = this.millisecMaxOriginal;
                }
            }
            if (adjustSliders !== undefined && adjustSliders === true) {
                var hourMax = parseInt(this._defaults.hourMax - (this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour, 10), minMax = parseInt(this._defaults.minuteMax - (this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute, 10), secMax = parseInt(this._defaults.secondMax - (this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond, 10), millisecMax = parseInt(this._defaults.millisecMax - (this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec, 10);
                if (this.hour_slider) {
                    this.hour_slider.slider("option", {
                        min: this._defaults.hourMin,
                        max: hourMax
                    }).slider("value", this.hour);
                }
                if (this.minute_slider) {
                    this.minute_slider.slider("option", {
                        min: this._defaults.minuteMin,
                        max: minMax
                    }).slider("value", this.minute);
                }
                if (this.second_slider) {
                    this.second_slider.slider("option", {
                        min: this._defaults.secondMin,
                        max: secMax
                    }).slider("value", this.second);
                }
                if (this.millisec_slider) {
                    this.millisec_slider.slider("option", {
                        min: this._defaults.millisecMin,
                        max: millisecMax
                    }).slider("value", this.millisec);
                }
            }
        },
        _onTimeChange: function() {
            var hour = this.hour_slider ? this.hour_slider.slider("value") : false, minute = this.minute_slider ? this.minute_slider.slider("value") : false, second = this.second_slider ? this.second_slider.slider("value") : false, millisec = this.millisec_slider ? this.millisec_slider.slider("value") : false, timezone = this.timezone_select ? this.timezone_select.val() : false, o = this._defaults;
            if (typeof hour == "object") {
                hour = false;
            }
            if (typeof minute == "object") {
                minute = false;
            }
            if (typeof second == "object") {
                second = false;
            }
            if (typeof millisec == "object") {
                millisec = false;
            }
            if (typeof timezone == "object") {
                timezone = false;
            }
            if (hour !== false) {
                hour = parseInt(hour, 10);
            }
            if (minute !== false) {
                minute = parseInt(minute, 10);
            }
            if (second !== false) {
                second = parseInt(second, 10);
            }
            if (millisec !== false) {
                millisec = parseInt(millisec, 10);
            }
            var ampm = o[hour < 12 ? "amNames" : "pmNames"][0];
            var hasChanged = hour != this.hour || minute != this.minute || second != this.second || millisec != this.millisec || this.ampm.length > 0 && hour < 12 != ($.inArray(this.ampm.toUpperCase(), this.amNames) !== -1) || this.timezone === null && timezone != this.defaultTimezone || this.timezone !== null && timezone != this.timezone;
            if (hasChanged) {
                if (hour !== false) {
                    this.hour = hour;
                }
                if (minute !== false) {
                    this.minute = minute;
                }
                if (second !== false) {
                    this.second = second;
                }
                if (millisec !== false) {
                    this.millisec = millisec;
                }
                if (timezone !== false) {
                    this.timezone = timezone;
                }
                if (!this.inst) {
                    this.inst = $.datepicker._getInst(this.$input[0]);
                }
                this._limitMinMaxDateTime(this.inst, true);
            }
            if (o.ampm) {
                this.ampm = ampm;
            }
            this.formattedTime = $.datepicker.formatTime(this._defaults.timeFormat, this, this._defaults);
            if (this.$timeObj) {
                this.$timeObj.text(this.formattedTime + o.timeSuffix);
            }
            this.timeDefined = true;
            if (hasChanged) {
                this._updateDateTime();
            }
        },
        _onSelectHandler: function() {
            var onSelect = this._defaults.onSelect || this.inst.settings.onSelect;
            var inputEl = this.$input ? this.$input[0] : null;
            if (onSelect && inputEl) {
                onSelect.apply(inputEl, [ this.formattedDateTime, this ]);
            }
        },
        _formatTime: function(time, format) {
            time = time || {
                hour: this.hour,
                minute: this.minute,
                second: this.second,
                millisec: this.millisec,
                ampm: this.ampm,
                timezone: this.timezone
            };
            var tmptime = (format || this._defaults.timeFormat).toString();
            tmptime = $.datepicker.formatTime(tmptime, time, this._defaults);
            if (arguments.length) {
                return tmptime;
            } else {
                this.formattedTime = tmptime;
            }
        },
        _updateDateTime: function(dp_inst) {
            dp_inst = this.inst || dp_inst;
            var dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay)), dateFmt = $.datepicker._get(dp_inst, "dateFormat"), formatCfg = $.datepicker._getFormatConfig(dp_inst), timeAvailable = dt !== null && this.timeDefined;
            this.formattedDate = $.datepicker.formatDate(dateFmt, dt === null ? new Date() : dt, formatCfg);
            var formattedDateTime = this.formattedDate;
            if (this._defaults.timeOnly === true) {
                formattedDateTime = this.formattedTime;
            } else if (this._defaults.timeOnly !== true && (this._defaults.alwaysSetTime || timeAvailable)) {
                formattedDateTime += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix;
            }
            this.formattedDateTime = formattedDateTime;
            if (!this._defaults.showTimepicker) {
                this.$input.val(this.formattedDate);
            } else if (this.$altInput && this._defaults.altFieldTimeOnly === true) {
                this.$altInput.val(this.formattedTime);
                this.$input.val(this.formattedDate);
            } else if (this.$altInput) {
                this.$input.val(formattedDateTime);
                var altFormattedDateTime = "", altSeparator = this._defaults.altSeparator ? this._defaults.altSeparator : this._defaults.separator, altTimeSuffix = this._defaults.altTimeSuffix ? this._defaults.altTimeSuffix : this._defaults.timeSuffix;
                if (this._defaults.altFormat) altFormattedDateTime = $.datepicker.formatDate(this._defaults.altFormat, dt === null ? new Date() : dt, formatCfg); else altFormattedDateTime = this.formattedDate;
                if (altFormattedDateTime) altFormattedDateTime += altSeparator;
                if (this._defaults.altTimeFormat) altFormattedDateTime += $.datepicker.formatTime(this._defaults.altTimeFormat, this, this._defaults) + altTimeSuffix; else altFormattedDateTime += this.formattedTime + altTimeSuffix;
                this.$altInput.val(altFormattedDateTime);
            } else {
                this.$input.val(formattedDateTime);
            }
            this.$input.trigger("change");
        },
        _onFocus: function() {
            if (!this.$input.val() && this._defaults.defaultValue) {
                this.$input.val(this._defaults.defaultValue);
                var inst = $.datepicker._getInst(this.$input.get(0)), tp_inst = $.datepicker._get(inst, "timepicker");
                if (tp_inst) {
                    if (tp_inst._defaults.timeOnly && inst.input.val() != inst.lastVal) {
                        try {
                            $.datepicker._updateDatepicker(inst);
                        } catch (err) {
                            $.datepicker.log(err);
                        }
                    }
                }
            }
        }
    });
    $.fn.extend({
        timepicker: function(o) {
            o = o || {};
            var tmp_args = Array.prototype.slice.call(arguments);
            if (typeof o == "object") {
                tmp_args[0] = $.extend(o, {
                    timeOnly: true
                });
            }
            return $(this).each(function() {
                $.fn.datetimepicker.apply($(this), tmp_args);
            });
        },
        datetimepicker: function(o) {
            o = o || {};
            var tmp_args = arguments;
            if (typeof o == "string") {
                if (o == "getDate") {
                    return $.fn.datepicker.apply($(this[0]), tmp_args);
                } else {
                    return this.each(function() {
                        var $t = $(this);
                        $t.datepicker.apply($t, tmp_args);
                    });
                }
            } else {
                return this.each(function() {
                    var $t = $(this);
                    $t.datepicker($.timepicker._newInst($t, o)._defaults);
                });
            }
        }
    });
    $.datepicker.parseDateTime = function(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
        var parseRes = parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings);
        if (parseRes.timeObj) {
            var t = parseRes.timeObj;
            parseRes.date.setHours(t.hour, t.minute, t.second, t.millisec);
        }
        return parseRes.date;
    };
    $.datepicker.parseTime = function(timeFormat, timeString, options) {
        var getPatternAmpm = function(amNames, pmNames) {
            var markers = [];
            if (amNames) {
                $.merge(markers, amNames);
            }
            if (pmNames) {
                $.merge(markers, pmNames);
            }
            markers = $.map(markers, function(val) {
                return val.replace(/[.*+?|()\[\]{}\\]/g, "\\$&");
            });
            return "(" + markers.join("|") + ")?";
        };
        var getFormatPositions = function(timeFormat) {
            var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|t{1,2}|z)/g), orders = {
                h: -1,
                m: -1,
                s: -1,
                l: -1,
                t: -1,
                z: -1
            };
            if (finds) {
                for (var i = 0; i < finds.length; i++) {
                    if (orders[finds[i].toString().charAt(0)] == -1) {
                        orders[finds[i].toString().charAt(0)] = i + 1;
                    }
                }
            }
            return orders;
        };
        var o = extendRemove(extendRemove({}, $.timepicker._defaults), options || {});
        var regstr = "^" + timeFormat.toString().replace(/h{1,2}/gi, "(\\d?\\d)").replace(/m{1,2}/gi, "(\\d?\\d)").replace(/s{1,2}/gi, "(\\d?\\d)").replace(/l{1}/gi, "(\\d?\\d?\\d)").replace(/t{1,2}/gi, getPatternAmpm(o.amNames, o.pmNames)).replace(/z{1}/gi, "(z|[-+]\\d\\d:?\\d\\d|\\S+)?").replace(/\s/g, "\\s?") + o.timeSuffix + "$", order = getFormatPositions(timeFormat), ampm = "", treg;
        treg = timeString.match(new RegExp(regstr, "i"));
        var resTime = {
            hour: 0,
            minute: 0,
            second: 0,
            millisec: 0
        };
        if (treg) {
            if (order.t !== -1) {
                if (treg[order.t] === undefined || treg[order.t].length === 0) {
                    ampm = "";
                    resTime.ampm = "";
                } else {
                    ampm = $.inArray(treg[order.t].toUpperCase(), o.amNames) !== -1 ? "AM" : "PM";
                    resTime.ampm = o[ampm == "AM" ? "amNames" : "pmNames"][0];
                }
            }
            if (order.h !== -1) {
                if (ampm == "AM" && treg[order.h] == "12") {
                    resTime.hour = 0;
                } else {
                    if (ampm == "PM" && treg[order.h] != "12") {
                        resTime.hour = parseInt(treg[order.h], 10) + 12;
                    } else {
                        resTime.hour = Number(treg[order.h]);
                    }
                }
            }
            if (order.m !== -1) {
                resTime.minute = Number(treg[order.m]);
            }
            if (order.s !== -1) {
                resTime.second = Number(treg[order.s]);
            }
            if (order.l !== -1) {
                resTime.millisec = Number(treg[order.l]);
            }
            if (order.z !== -1 && treg[order.z] !== undefined) {
                var tz = treg[order.z].toUpperCase();
                switch (tz.length) {
                  case 1:
                    tz = o.timezoneIso8601 ? "Z" : "+0000";
                    break;

                  case 5:
                    if (o.timezoneIso8601) {
                        tz = tz.substring(1) == "0000" ? "Z" : tz.substring(0, 3) + ":" + tz.substring(3);
                    }
                    break;

                  case 6:
                    if (!o.timezoneIso8601) {
                        tz = tz == "Z" || tz.substring(1) == "00:00" ? "+0000" : tz.replace(/:/, "");
                    } else {
                        if (tz.substring(1) == "00:00") {
                            tz = "Z";
                        }
                    }
                    break;
                }
                resTime.timezone = tz;
            }
            return resTime;
        }
        return false;
    };
    $.datepicker.formatTime = function(format, time, options) {
        options = options || {};
        options = $.extend({}, $.timepicker._defaults, options);
        time = $.extend({
            hour: 0,
            minute: 0,
            second: 0,
            millisec: 0,
            timezone: "+0000"
        }, time);
        var tmptime = format;
        var ampmName = options.amNames[0];
        var hour = parseInt(time.hour, 10);
        if (options.ampm) {
            if (hour > 11) {
                ampmName = options.pmNames[0];
                if (hour > 12) {
                    hour = hour % 12;
                }
            }
            if (hour === 0) {
                hour = 12;
            }
        }
        tmptime = tmptime.replace(/(?:hh?|mm?|ss?|[tT]{1,2}|[lz]|('.*?'|".*?"))/g, function(match) {
            switch (match.toLowerCase()) {
              case "hh":
                return ("0" + hour).slice(-2);

              case "h":
                return hour;

              case "mm":
                return ("0" + time.minute).slice(-2);

              case "m":
                return time.minute;

              case "ss":
                return ("0" + time.second).slice(-2);

              case "s":
                return time.second;

              case "l":
                return ("00" + time.millisec).slice(-3);

              case "z":
                return time.timezone;

              case "t":
              case "tt":
                if (options.ampm) {
                    if (match.length == 1) {
                        ampmName = ampmName.charAt(0);
                    }
                    return match.charAt(0) === "T" ? ampmName.toUpperCase() : ampmName.toLowerCase();
                }
                return "";

              default:
                return match.replace(/\'/g, "") || "'";
            }
        });
        tmptime = $.trim(tmptime);
        return tmptime;
    };
    $.datepicker._base_selectDate = $.datepicker._selectDate;
    $.datepicker._selectDate = function(id, dateStr) {
        var inst = this._getInst($(id)[0]), tp_inst = this._get(inst, "timepicker");
        if (tp_inst) {
            tp_inst._limitMinMaxDateTime(inst, true);
            inst.inline = inst.stay_open = true;
            this._base_selectDate(id, dateStr);
            inst.inline = inst.stay_open = false;
            this._notifyChange(inst);
            this._updateDatepicker(inst);
        } else {
            this._base_selectDate(id, dateStr);
        }
    };
    $.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker;
    $.datepicker._updateDatepicker = function(inst) {
        var input = inst.input[0];
        if ($.datepicker._curInst && $.datepicker._curInst != inst && $.datepicker._datepickerShowing && $.datepicker._lastInput != input) {
            return;
        }
        if (typeof inst.stay_open !== "boolean" || inst.stay_open === false) {
            this._base_updateDatepicker(inst);
            var tp_inst = this._get(inst, "timepicker");
            if (tp_inst) {
                tp_inst._addTimePicker(inst);
                if (tp_inst._defaults.useLocalTimezone) {
                    var date = new Date(inst.selectedYear, inst.selectedMonth, inst.selectedDay, 12);
                    selectLocalTimeZone(tp_inst, date);
                    tp_inst._onTimeChange();
                }
            }
        }
    };
    $.datepicker._base_doKeyPress = $.datepicker._doKeyPress;
    $.datepicker._doKeyPress = function(event) {
        var inst = $.datepicker._getInst(event.target), tp_inst = $.datepicker._get(inst, "timepicker");
        if (tp_inst) {
            if ($.datepicker._get(inst, "constrainInput")) {
                var ampm = tp_inst._defaults.ampm, dateChars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat")), datetimeChars = tp_inst._defaults.timeFormat.toString().replace(/[hms]/g, "").replace(/TT/g, ampm ? "APM" : "").replace(/Tt/g, ampm ? "AaPpMm" : "").replace(/tT/g, ampm ? "AaPpMm" : "").replace(/T/g, ampm ? "AP" : "").replace(/tt/g, ampm ? "apm" : "").replace(/t/g, ampm ? "ap" : "") + " " + tp_inst._defaults.separator + tp_inst._defaults.timeSuffix + (tp_inst._defaults.showTimezone ? tp_inst._defaults.timezoneList.join("") : "") + tp_inst._defaults.amNames.join("") + tp_inst._defaults.pmNames.join("") + dateChars, chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode);
                return event.ctrlKey || chr < " " || !dateChars || datetimeChars.indexOf(chr) > -1;
            }
        }
        return $.datepicker._base_doKeyPress(event);
    };
    $.datepicker._base_doKeyUp = $.datepicker._doKeyUp;
    $.datepicker._doKeyUp = function(event) {
        var inst = $.datepicker._getInst(event.target), tp_inst = $.datepicker._get(inst, "timepicker");
        if (tp_inst) {
            if (tp_inst._defaults.timeOnly && inst.input.val() != inst.lastVal) {
                try {
                    $.datepicker._updateDatepicker(inst);
                } catch (err) {
                    $.datepicker.log(err);
                }
            }
        }
        return $.datepicker._base_doKeyUp(event);
    };
    $.datepicker._base_gotoToday = $.datepicker._gotoToday;
    $.datepicker._gotoToday = function(id) {
        var inst = this._getInst($(id)[0]), $dp = inst.dpDiv;
        this._base_gotoToday(id);
        var tp_inst = this._get(inst, "timepicker");
        selectLocalTimeZone(tp_inst);
        var now = new Date();
        this._setTime(inst, now);
        $(".ui-datepicker-today", $dp).click();
    };
    $.datepicker._disableTimepickerDatepicker = function(target) {
        var inst = this._getInst(target);
        if (!inst) {
            return;
        }
        var tp_inst = this._get(inst, "timepicker");
        $(target).datepicker("getDate");
        if (tp_inst) {
            tp_inst._defaults.showTimepicker = false;
            tp_inst._updateDateTime(inst);
        }
    };
    $.datepicker._enableTimepickerDatepicker = function(target) {
        var inst = this._getInst(target);
        if (!inst) {
            return;
        }
        var tp_inst = this._get(inst, "timepicker");
        $(target).datepicker("getDate");
        if (tp_inst) {
            tp_inst._defaults.showTimepicker = true;
            tp_inst._addTimePicker(inst);
            tp_inst._updateDateTime(inst);
        }
    };
    $.datepicker._setTime = function(inst, date) {
        var tp_inst = this._get(inst, "timepicker");
        if (tp_inst) {
            var defaults = tp_inst._defaults, hour = date ? date.getHours() : defaults.hour, minute = date ? date.getMinutes() : defaults.minute, second = date ? date.getSeconds() : defaults.second, millisec = date ? date.getMilliseconds() : defaults.millisec;
            var hourEq = hour === defaults.hourMin, minuteEq = minute === defaults.minuteMin, secondEq = second === defaults.secondMin;
            var reset = false;
            if (hour < defaults.hourMin || hour > defaults.hourMax) reset = true; else if ((minute < defaults.minuteMin || minute > defaults.minuteMax) && hourEq) reset = true; else if ((second < defaults.secondMin || second > defaults.secondMax) && hourEq && minuteEq) reset = true; else if ((millisec < defaults.millisecMin || millisec > defaults.millisecMax) && hourEq && minuteEq && secondEq) reset = true;
            if (reset) {
                hour = defaults.hourMin;
                minute = defaults.minuteMin;
                second = defaults.secondMin;
                millisec = defaults.millisecMin;
            }
            tp_inst.hour = hour;
            tp_inst.minute = minute;
            tp_inst.second = second;
            tp_inst.millisec = millisec;
            if (tp_inst.hour_slider) tp_inst.hour_slider.slider("value", hour);
            if (tp_inst.minute_slider) tp_inst.minute_slider.slider("value", minute);
            if (tp_inst.second_slider) tp_inst.second_slider.slider("value", second);
            if (tp_inst.millisec_slider) tp_inst.millisec_slider.slider("value", millisec);
            tp_inst._onTimeChange();
            tp_inst._updateDateTime(inst);
        }
    };
    $.datepicker._setTimeDatepicker = function(target, date, withDate) {
        var inst = this._getInst(target);
        if (!inst) {
            return;
        }
        var tp_inst = this._get(inst, "timepicker");
        if (tp_inst) {
            this._setDateFromField(inst);
            var tp_date;
            if (date) {
                if (typeof date == "string") {
                    tp_inst._parseTime(date, withDate);
                    tp_date = new Date();
                    tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
                } else {
                    tp_date = new Date(date.getTime());
                }
                if (tp_date.toString() == "Invalid Date") {
                    tp_date = undefined;
                }
                this._setTime(inst, tp_date);
            }
        }
    };
    $.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker;
    $.datepicker._setDateDatepicker = function(target, date) {
        var inst = this._getInst(target);
        if (!inst) {
            return;
        }
        var tp_date = date instanceof Date ? new Date(date.getTime()) : date;
        this._updateDatepicker(inst);
        this._base_setDateDatepicker.apply(this, arguments);
        this._setTimeDatepicker(target, tp_date, true);
    };
    $.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker;
    $.datepicker._getDateDatepicker = function(target, noDefault) {
        var inst = this._getInst(target);
        if (!inst) {
            return;
        }
        var tp_inst = this._get(inst, "timepicker");
        if (tp_inst) {
            var date = this._getDate(inst);
            if (date && tp_inst._parseTime($(target).val(), tp_inst.timeOnly)) {
                date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
            }
            return date;
        }
        return this._base_getDateDatepicker(target, noDefault);
    };
    $.datepicker._base_parseDate = $.datepicker.parseDate;
    $.datepicker.parseDate = function(format, value, settings) {
        var splitRes = splitDateTime(format, value, settings);
        return $.datepicker._base_parseDate(format, splitRes[0], settings);
    };
    $.datepicker._base_formatDate = $.datepicker._formatDate;
    $.datepicker._formatDate = function(inst, day, month, year) {
        var tp_inst = this._get(inst, "timepicker");
        if (tp_inst) {
            tp_inst._updateDateTime(inst);
            return tp_inst.$input.val();
        }
        return this._base_formatDate(inst);
    };
    $.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker;
    $.datepicker._optionDatepicker = function(target, name, value) {
        var inst = this._getInst(target);
        if (!inst) {
            return null;
        }
        var tp_inst = this._get(inst, "timepicker");
        if (tp_inst) {
            var min = null, max = null, onselect = null;
            if (typeof name == "string") {
                if (name === "minDate" || name === "minDateTime") {
                    min = value;
                } else {
                    if (name === "maxDate" || name === "maxDateTime") {
                        max = value;
                    } else {
                        if (name === "onSelect") {
                            onselect = value;
                        }
                    }
                }
            } else {
                if (typeof name == "object") {
                    if (name.minDate) {
                        min = name.minDate;
                    } else {
                        if (name.minDateTime) {
                            min = name.minDateTime;
                        } else {
                            if (name.maxDate) {
                                max = name.maxDate;
                            } else {
                                if (name.maxDateTime) {
                                    max = name.maxDateTime;
                                }
                            }
                        }
                    }
                }
            }
            if (min) {
                if (min === 0) {
                    min = new Date();
                } else {
                    min = new Date(min);
                }
                tp_inst._defaults.minDate = min;
                tp_inst._defaults.minDateTime = min;
            } else if (max) {
                if (max === 0) {
                    max = new Date();
                } else {
                    max = new Date(max);
                }
                tp_inst._defaults.maxDate = max;
                tp_inst._defaults.maxDateTime = max;
            } else if (onselect) {
                tp_inst._defaults.onSelect = onselect;
            }
        }
        if (value === undefined) {
            return this._base_optionDatepicker(target, name);
        }
        return this._base_optionDatepicker(target, name, value);
    };
    function extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) {
            if (props[name] === null || props[name] === undefined) {
                target[name] = props[name];
            }
        }
        return target;
    }
    var splitDateTime = function(dateFormat, dateTimeString, dateSettings, timeSettings) {
        try {
            var separator = timeSettings && timeSettings.separator ? timeSettings.separator : $.timepicker._defaults.separator, format = timeSettings && timeSettings.timeFormat ? timeSettings.timeFormat : $.timepicker._defaults.timeFormat, ampm = timeSettings && timeSettings.ampm ? timeSettings.ampm : $.timepicker._defaults.ampm, timeParts = format.split(separator), timePartsLen = timeParts.length, allParts = dateTimeString.split(separator), allPartsLen = allParts.length;
            if (!ampm) {
                timeParts = $.trim(format.replace(/t/gi, "")).split(separator);
                timePartsLen = timeParts.length;
            }
            if (allPartsLen > 0) {
                return [ allParts.splice(0, allPartsLen - timePartsLen).join(separator), allParts.splice(timePartsLen * -1).join(separator) ];
            }
        } catch (err) {
            if (err.indexOf(":") >= 0) {
                var dateStringLength = dateTimeString.length - (err.length - err.indexOf(":") - 2), timeString = dateTimeString.substring(dateStringLength);
                return [ $.trim(dateTimeString.substring(0, dateStringLength)), $.trim(dateTimeString.substring(dateStringLength)) ];
            } else {
                throw err;
            }
        }
        return [ dateTimeString, "" ];
    };
    var parseDateTimeInternal = function(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
        var date;
        var splitRes = splitDateTime(dateFormat, dateTimeString, dateSettings, timeSettings);
        date = $.datepicker._base_parseDate(dateFormat, splitRes[0], dateSettings);
        if (splitRes[1] !== "") {
            var timeString = splitRes[1], parsedTime = $.datepicker.parseTime(timeFormat, timeString, timeSettings);
            if (parsedTime === null) {
                throw "Wrong time format";
            }
            return {
                date: date,
                timeObj: parsedTime
            };
        } else {
            return {
                date: date
            };
        }
    };
    var selectLocalTimeZone = function(tp_inst, date) {
        if (tp_inst && tp_inst.timezone_select) {
            tp_inst._defaults.useLocalTimezone = true;
            var now = typeof date !== "undefined" ? date : new Date();
            var tzoffset = $.timepicker.timeZoneOffsetString(now);
            if (tp_inst._defaults.timezoneIso8601) {
                tzoffset = tzoffset.substring(0, 3) + ":" + tzoffset.substring(3);
            }
            tp_inst.timezone_select.val(tzoffset);
        }
    };
    $.timepicker = new Timepicker();
    $.timepicker.timeZoneOffsetString = function(date) {
        var off = date.getTimezoneOffset() * -1, minutes = off % 60, hours = (off - minutes) / 60;
        return (off >= 0 ? "+" : "-") + ("0" + (hours * 101).toString()).substr(-2) + ("0" + (minutes * 101).toString()).substr(-2);
    };
    $.timepicker.timeRange = function(startTime, endTime, options) {
        return $.timepicker.handleRange("timepicker", startTime, endTime, options);
    };
    $.timepicker.dateTimeRange = function(startTime, endTime, options) {
        $.timepicker.dateRange(startTime, endTime, options, "datetimepicker");
    };
    $.timepicker.dateRange = function(startTime, endTime, options, method) {
        method = method || "datepicker";
        $.timepicker.handleRange(method, startTime, endTime, options);
    };
    $.timepicker.handleRange = function(method, startTime, endTime, options) {
        $.fn[method].call(startTime, $.extend({
            onClose: function(dateText, inst) {
                checkDates(this, endTime, dateText);
            },
            onSelect: function(selectedDateTime) {
                selected(this, endTime, "minDate");
            }
        }, options, options.start));
        $.fn[method].call(endTime, $.extend({
            onClose: function(dateText, inst) {
                checkDates(this, startTime, dateText);
            },
            onSelect: function(selectedDateTime) {
                selected(this, startTime, "maxDate");
            }
        }, options, options.end));
        if (method != "timepicker" && options.reformat) {
            $([ startTime, endTime ]).each(function() {
                var format = $(this)[method].call($(this), "option", "dateFormat"), date = new Date($(this).val());
                if ($(this).val() && date) {
                    $(this).val($.datepicker.formatDate(format, date));
                }
            });
        }
        checkDates(startTime, endTime, startTime.val());
        function checkDates(changed, other, dateText) {
            if (other.val() && new Date(startTime.val()) > new Date(endTime.val())) {
                other.val(dateText);
            }
        }
        selected(startTime, endTime, "minDate");
        selected(endTime, startTime, "maxDate");
        function selected(changed, other, option) {
            if (!$(changed).val()) {
                return;
            }
            var date = $(changed)[method].call($(changed), "getDate");
            if (date.getTime) {
                $(other)[method].call($(other), "option", option, date);
            }
        }
        return $([ startTime.get(0), endTime.get(0) ]);
    };
    $.timepicker.version = "1.0.3";
})(jQuery);

(function($) {
    $.fn.shuffle = function() {
        return this.each(function() {
            var items = $(this).children();
            return items.length ? $(this).html($.shuffle(items)) : this;
        });
    };
    $.shuffle = function(arr) {
        for (var j, x, i = arr.length; i; j = parseInt(Math.random() * i), x = arr[--i], 
        arr[i] = arr[j], arr[j] = x) ;
        return arr;
    };
})(jQuery);

(function(global, jQuery, undefined) {
    if (jQuery && jQuery.views || global.jsviews) return;
    var versionNumber = "v1.0pre", $, rTag, rTmplString, $extend, delimOpenChar0 = "{", delimOpenChar1 = "{", delimCloseChar0 = "}", delimCloseChar1 = "}", deferChar = "!", $viewsSub = {}, FALSE = false, TRUE = true, rPath = /^(?:null|true|false|\d[\d.]*|([\w$]+|~([\w$]+)|#(view|([\w$]+))?)([\w$.]*?)(?:[.[]([\w$]+)\]?)?|(['"]).*\8)$/g, rParams = /(\()(?=|\s*\()|(?:([([])\s*)?(?:([#~]?[\w$.]+)?\s*((\+\+|--)|\+|-|&&|\|\||===|!==|==|!=|<=|>=|[<>%*!:?\/]|(=))\s*|([#~]?[\w$.]+)([([])?)|(,\s*)|(\(?)\\?(?:(')|("))|(?:\s*([)\]])([([]?))|(\s+)/g, rNewLine = /\r?\n/g, rUnescapeQuotes = /\\(['"])/g, rEscapeQuotes = /\\?(['"])/g, rBuildHash = /\x08(~)?([^\x08]+)\x08/g, autoTmplName = 0, escapeMapForHtml = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;"
    }, tmplAttr = "data-jsv-tmpl", fnDeclStr = "var j=j||" + (jQuery ? "jQuery." : "js") + "views,", htmlSpecialChar = /[\x00"&'<>]/g, slice = Array.prototype.slice, $render = {}, $views = {
        jsviews: versionNumber,
        sub: $viewsSub,
        debugMode: TRUE,
        render: $render,
        templates: $templates,
        tags: $viewsTags,
        helpers: $viewsHelpers,
        converters: $viewsConverters,
        delimiters: $viewsDelimiters,
        View: View,
        _convert: convert,
        _err: function(e) {
            return $views.debugMode ? "Error: " + (e.message || e) + ". " : "";
        },
        _tmplFn: tmplFn,
        _tag: renderTag,
        error: error,
        Error: JsViewsError
    };
    function JsViewsError(message) {
        this.name = "JsRender Error", this.message = message || "JsRender error";
    }
    (JsViewsError.prototype = new Error()).constructor = JsViewsError;
    function $viewsDelimiters(openChars, closeChars, defer) {
        if (!$views.rTag || arguments.length) {
            delimOpenChar0 = openChars ? "\\" + openChars.charAt(0) : delimOpenChar0;
            delimOpenChar1 = openChars ? "\\" + openChars.charAt(1) : delimOpenChar1;
            delimCloseChar0 = closeChars ? "\\" + closeChars.charAt(0) : delimCloseChar0;
            delimCloseChar1 = closeChars ? "\\" + closeChars.charAt(0) : delimCloseChar1;
            defer = defer ? "\\" + defer : deferChar;
            $views.rTag = rTag = "(\\w*" + defer + ")?(?:(?:(\\w+(?=[\\/\\s" + delimCloseChar0 + "]))|(?:(\\w+)?(:)|(>)|(\\*)))" + "\\s*((?:[^" + delimCloseChar0 + "]|" + delimCloseChar0 + "(?!" + delimCloseChar1 + "))*?)";
            rTag = new RegExp(delimOpenChar0 + delimOpenChar1 + rTag + "(\\/)?|(?:\\/(\\w+)))" + delimCloseChar0 + delimCloseChar1, "g");
            rTmplString = new RegExp("<.*>|([^\\\\]|^)[{}]|" + delimOpenChar0 + delimOpenChar1 + ".*" + delimCloseChar0 + delimCloseChar1);
        }
        return [ delimOpenChar0, delimOpenChar1, delimCloseChar0, delimCloseChar1, deferChar ];
    }
    function getHelper(helper) {
        var view = this, tmplHelpers = view.tmpl.helpers || {};
        helper = (view.dynCtx && view.dynCtx[helper] !== undefined ? view.dynCtx : view.ctx[helper] !== undefined ? view.ctx : tmplHelpers[helper] !== undefined ? tmplHelpers : $viewsHelpers[helper] !== undefined ? $viewsHelpers : {})[helper];
        return typeof helper !== "function" ? helper : function() {
            return helper.apply(view, arguments);
        };
    }
    function convert(converter, view, self, text) {
        var linkContext = !self.markup && self || undefined, tmplConverter = view.tmpl.converters;
        tmplConverter = tmplConverter && tmplConverter[converter] || $viewsConverters[converter];
        return tmplConverter ? tmplConverter.call(view, text, linkContext) : (error("Unknown converter: {{" + converter + ":"), 
        text);
    }
    function renderTag(tag, parentView, self, content, tagInstance) {
        var ret, linkCtx = !self.markup && self, parentTmpl = linkCtx ? linkCtx.view.tmpl : self, tmplTags = parentTmpl.tags, nestedTemplates = parentTmpl.templates, props = tagInstance.props = tagInstance.props || {}, tmpl = props.tmpl, args = arguments.length > 5 ? slice.call(arguments, 5) : [], tagObject = tmplTags && tmplTags[tag] || $viewsTags[tag];
        if (!tagObject) {
            error("Unknown tag: {{" + tag + "}}");
            return "";
        }
        content = content && parentTmpl.tmpls[content - 1];
        tmpl = tmpl || content || tagObject.template || undefined;
        tagInstance.view = parentView;
        tmpl = tagInstance.tmpl = "" + tmpl === tmpl ? nestedTemplates && nestedTemplates[tmpl] || $templates[tmpl] || $templates(tmpl) : tmpl;
        tagInstance.attr = self.attr = self.attr || tagObject.attr;
        tagInstance.tagName = tag;
        tagInstance.renderContent = renderContent;
        if (linkCtx) {
            linkCtx.tagCtx = {
                args: args,
                props: props,
                path: tagInstance.path,
                tag: tagObject
            };
        }
        if (tagObject.render) {
            ret = tagObject.render.apply(tagInstance, args);
        }
        return ret || (ret == undefined ? tmpl ? tagInstance.renderContent(args[0], undefined, parentView) : "" : ret.toString());
    }
    function View(context, path, parentView, data, template, key, onRender, isArray) {
        var views, self = {
            data: data,
            tmpl: template,
            views: isArray ? [] : {},
            parent: parentView,
            ctx: context,
            path: path,
            _useKey: isArray ? 0 : 1,
            _onRender: onRender,
            _hlp: getHelper,
            renderLink: function(index) {
                var linkTmpl = this.tmpl.tmpls[index];
                return linkTmpl.render(data, context, this);
            }
        };
        if (parentView) {
            views = parentView.views;
            if (parentView._useKey) {
                views[self.key = "_" + parentView._useKey++] = self;
                self.index = parentView.index;
            } else {
                views.splice(self.key = self.index = key !== undefined ? key : views.length, 0, self);
            }
        }
        return self;
    }
    function addToStore(self, store, name, item, process) {
        var key, onStore;
        if (name && typeof name === "object" && !name.nodeType) {
            for (key in name) {
                store(key, name[key]);
            }
            return self;
        }
        if (item === undefined) {
            item = name;
            name = undefined;
        }
        if (onStore = $viewsSub.onBeforeStoreItem) {
            process = onStore(store, name, item, process) || process;
        }
        if (!name) {
            item = process ? process(item) : item;
        } else if ("" + name === name) {
            if (item === null) {
                delete store[name];
            } else {
                store[name] = process ? item = process(item, name) : item;
            }
        }
        if (onStore = $viewsSub.onStoreItem) {
            onStore(store, name, item, process);
        }
        return item;
    }
    function compileTag(item, name) {
        item = typeof item === "function" ? {
            render: item
        } : item;
        item.name = name;
        item.is = "tag";
        return item;
    }
    function $templates(name, tmpl) {
        return addToStore(this, $templates, name, tmpl, compile);
    }
    function $viewsTags(name, tag) {
        return addToStore(this, $viewsTags, name, tag, compileTag);
    }
    function $viewsHelpers(name, helperFn) {
        return addToStore(this, $viewsHelpers, name, helperFn);
    }
    function $viewsConverters(name, converterFn) {
        return addToStore(this, $viewsConverters, name, converterFn);
    }
    function renderContent(data, context, parentView, key, isLayout, path, onRender) {
        var i, l, dataItem, newView, itemResult, parentContext, tmpl, props, swapContent, mergedCtx, dynCtx, hasContext, self = this, result = "";
        if (key === TRUE) {
            swapContent = TRUE;
            key = 0;
        }
        if (self.tagName) {
            tmpl = self.tmpl;
            if (context || self.ctx) {
                mergedCtx = {};
                if (self.ctx) {
                    $extend(mergedCtx, self.ctx);
                }
                if (context) {
                    $extend(mergedCtx, context);
                }
            }
            context = mergedCtx;
            props = self.props;
            if (props && props.link === FALSE) {
                context = context || {};
                context.link = FALSE;
            }
            parentView = parentView || self.view;
            path = path || self.path;
            key = key || self.key;
            onRender = parentView && parentView._onRender;
        } else {
            tmpl = self.jquery && (self[0] || error('Unknown template: "' + self.selector + '"')) || self;
            onRender = onRender || parentView && parentView._onRender;
        }
        if (tmpl) {
            if (parentView) {
                parentContext = parentView.ctx;
                dynCtx = parentView.dynCtx;
                if (data === parentView) {
                    data = parentView.data;
                    isLayout = TRUE;
                }
            } else {
                parentContext = $viewsHelpers;
            }
            hasContext = context && context !== parentContext;
            if (dynCtx || hasContext) {
                parentContext = $extend({}, parentContext);
                if (hasContext) {
                    $extend(parentContext, context);
                }
                if (dynCtx) {
                    $extend(parentContext, dynCtx);
                }
            }
            context = parentContext;
            if (!tmpl.fn) {
                tmpl = $templates[tmpl] || $templates(tmpl);
            }
            if (tmpl) {
                onRender = context.link !== FALSE && onRender;
                if ($.isArray(data) && !isLayout) {
                    newView = swapContent ? parentView : key !== undefined && parentView || View(context, path, parentView, data, tmpl, key, onRender, TRUE);
                    for (i = 0, l = data.length; i < l; i++) {
                        dataItem = data[i];
                        itemResult = tmpl.fn(dataItem, View(context, path, newView, dataItem, tmpl, (key || 0) + i, onRender), $views);
                        result += onRender ? onRender(itemResult, tmpl, props) : itemResult;
                    }
                } else {
                    newView = swapContent ? parentView : View(context, path, parentView, data, tmpl, key, onRender);
                    newView._onRender = onRender;
                    result += tmpl.fn(data, newView, $views, returnVal);
                }
                return onRender ? onRender(result, tmpl, props, newView.key, path) : result;
            }
        }
        error("No template found");
        return "";
    }
    function returnVal(value) {
        return value;
    }
    function error(message) {
        if ($views.debugMode) {
            throw new $views.Error(message);
        }
    }
    function syntaxError(message) {
        error("Syntax error\n" + message);
    }
    function tmplFn(markup, tmpl, bind) {
        var newNode, allowCode = tmpl && tmpl.allowCode, astTop = [], loc = 0, stack = [], content = astTop, current = [ , , , astTop ];
        function pushPreceedingContent(shift) {
            shift -= loc;
            if (shift) {
                content.push(markup.substr(loc, shift).replace(rNewLine, "\\n"));
            }
        }
        function blockTagCheck(tagName) {
            tagName && syntaxError('Unmatched or missing tag: "{{/' + tagName + '}}" in template:\n' + markup);
        }
        function parseTag(all, defer, tagName, converter, colon, html, code, params, slash, closeBlock, index) {
            if (html) {
                colon = ":";
                converter = "html";
            }
            var current0, hash = "", passedCtx = "", block = !slash && !colon && !bind;
            tagName = tagName || colon;
            pushPreceedingContent(index);
            loc = index + all.length;
            if (code) {
                if (allowCode) {
                    content.push([ "*", params.replace(rUnescapeQuotes, "$1") ]);
                }
            } else if (tagName) {
                if (tagName === "else") {
                    current[5] = markup.substring(current[5], index);
                    current = stack.pop();
                    content = current[3];
                    block = TRUE;
                } else if (defer) {
                    stack.push(current);
                    current = [ "!", , , [], , index ];
                    content.push(current);
                    content = current[3];
                }
                params = params ? parseParams(params, bind, defer).replace(rBuildHash, function(all, isCtx, keyValue) {
                    if (isCtx) {
                        passedCtx += keyValue + ",";
                    } else {
                        hash += keyValue + ",";
                    }
                    return "";
                }) : "";
                hash = hash.slice(0, -1);
                params = params.slice(0, -1);
                newNode = [ tagName, converter || "", params, block && [], "{" + (hash ? "props:{" + hash + "}," : "") + "data: data" + (passedCtx ? ",ctx:{" + passedCtx.slice(0, -1) + "}" : "") + "}" ];
                content.push(newNode);
                if (block) {
                    stack.push(current);
                    current = newNode;
                    current[5] = loc;
                } else if (defer) {
                    current[5] = markup.substring(current[5], loc);
                    current = stack.pop();
                }
            } else if (closeBlock) {
                current0 = current[0];
                blockTagCheck(closeBlock !== current0 && !(closeBlock === "if" && current0 === "else") && current0);
                current[5] = markup.substring(current[5], index);
                if (current0 === "!") {
                    current[5] = markup.substring(current[5], loc);
                    current = stack.pop();
                }
                current = stack.pop();
            }
            blockTagCheck(!current && closeBlock);
            content = current[3];
        }
        markup = markup.replace(rEscapeQuotes, "\\$1");
        blockTagCheck(stack[0] && stack[0][3].pop()[0]);
        markup.replace(rTag, parseTag);
        pushPreceedingContent(markup.length);
        return buildCode(astTop, tmpl);
    }
    function buildCode(ast, tmpl) {
        var node, i, l, code, hasTag, hasEncoder, getsValue, hasConverter, hasViewPath, tag, converter, params, hash, nestedTmpl, allowCode, content, attr, quot, tmplOptions = tmpl ? {
            allowCode: allowCode = tmpl.allowCode,
            debug: tmpl.debug
        } : {}, nested = tmpl && tmpl.tmpls;
        l = ast.length;
        code = l ? "" : '"";';
        for (i = 0; i < l; i++) {
            node = ast[i];
            if ("" + node === node) {
                code += '"' + node + '"+';
            } else {
                tag = node[0];
                if (tag === "*") {
                    code = code.slice(0, i ? -1 : -3) + ";" + node[1] + (i + 1 < l ? "ret+=" : "");
                } else {
                    converter = node[1];
                    params = node[2];
                    content = node[3];
                    hash = node[4];
                    markup = node[5];
                    if (tag.slice(-1) === "!") {
                        nestedTmpl = TmplObject(markup, tmplOptions, tmpl, nested.length);
                        buildCode(content, nestedTmpl);
                        if (attr = /\s+[\w-]*\s*\=\s*\\['"]$/.exec(ast[i - 1])) {
                            error("'{{!' in attribute:\n..." + ast[i - 1] + "{{!...\nUse data-link");
                        }
                        code += "view.renderLink(" + nested.length + ")+";
                        nestedTmpl.bound = TRUE;
                        nestedTmpl.fn.attr = attr || "leaf";
                        nested.push(nestedTmpl);
                    } else {
                        if (content) {
                            nestedTmpl = TmplObject(markup, tmplOptions, tmpl, nested.length);
                            buildCode(content, nestedTmpl);
                            nested.push(nestedTmpl);
                        }
                        hasViewPath = hasViewPath || hash.indexOf("view") > -1;
                        code += (tag === ":" ? converter === "html" ? (hasEncoder = TRUE, "h(" + params) : converter ? (hasConverter = TRUE, 
                        'c("' + converter + '",view,this,' + params) : (getsValue = TRUE, "((v=" + params + ')!=u?v:""') : (hasTag = TRUE, 
                        't("' + tag + '",view,this,' + (content ? nested.length : '""') + "," + hash + (params ? "," : "") + params)) + ")+";
                    }
                }
            }
        }
        code = fnDeclStr + (getsValue ? "v," : "") + (hasTag ? "t=j._tag," : "") + (hasConverter ? "c=j._convert," : "") + (hasEncoder ? "h=j.converters.html," : "") + "ret; try{\n\n" + (tmplOptions.debug ? "debugger;" : "") + (allowCode ? "ret=" : "return ") + code.slice(0, -1) + ";\n\n" + (allowCode ? "return ret;" : "") + "}catch(e){return j._err(e);}";
        try {
            code = new Function("data, view, j, b, u", code);
        } catch (e) {
            syntaxError("Compiled template code:\n\n" + code, e);
        }
        if (tmpl) {
            tmpl.fn = code;
        }
        return code;
    }
    function parseParams(params, bind, defer) {
        var named, fnCall = {}, parenDepth = 0, quoted = FALSE, aposed = FALSE;
        function parseTokens(all, lftPrn0, lftPrn, path, operator, err, eq, path2, prn, comma, lftPrn2, apos, quot, rtPrn, prn2, space) {
            operator = operator || "";
            lftPrn = lftPrn || lftPrn0 || lftPrn2;
            path = path || path2;
            prn = prn || prn2 || "";
            operator = operator || "";
            var bindParam = (bind || defer) && prn !== "(";
            function parsePath(all, object, helper, view, viewProperty, pathTokens, leafToken) {
                if (object) {
                    var leaf, ret = (helper ? 'view._hlp("' + helper + '")' : view ? "view" : "data") + (leafToken ? (viewProperty ? "." + viewProperty : helper ? "" : view ? "" : "." + object) + (pathTokens || "") : (leafToken = helper ? "" : view ? viewProperty || "" : object, 
                    ""));
                    leaf = leafToken ? "." + leafToken : "";
                    if (!bindParam) {
                        ret = ret + leaf;
                    }
                    ret = ret.slice(0, 9) === "view.data" ? ret.slice(5) : ret;
                    if (bindParam) {
                        ret = "b(" + ret + ',"' + leafToken + '")' + leaf;
                    }
                    return ret;
                }
                return all;
            }
            if (err) {
                syntaxError(params);
            } else {
                return aposed ? (aposed = !apos, aposed ? all : '"') : quoted ? (quoted = !quot, 
                quoted ? all : '"') : (lftPrn ? (parenDepth++, lftPrn) : "") + (space ? parenDepth ? "" : named ? (named = FALSE, 
                "\b") : "," : eq ? (parenDepth && syntaxError(params), named = TRUE, "\b" + path + ":") : path ? path.replace(rPath, parsePath) + (prn ? (fnCall[++parenDepth] = TRUE, 
                prn) : operator) : operator ? operator : rtPrn ? (fnCall[parenDepth--] = FALSE, 
                rtPrn) + (prn ? (fnCall[++parenDepth] = TRUE, prn) : "") : comma ? (fnCall[parenDepth] || syntaxError(params), 
                ",") : lftPrn0 ? "" : (aposed = apos, quoted = quot, '"'));
            }
        }
        params = (params + " ").replace(rParams, parseTokens);
        return params;
    }
    function compileNested(items, process, options) {
        var key, nestedItem;
        if (items) {
            for (key in items) {
                nestedItem = items[key];
                if (!nestedItem.is) {
                    items[key] = process(nestedItem, key, options);
                }
            }
        }
    }
    function compile(tmpl, name, parent, options) {
        var tmplOrMarkup, elem;
        function tmplOrMarkupFromStr(value) {
            if ("" + value === value || value.nodeType > 0) {
                try {
                    elem = value.nodeType > 0 ? value : !rTmplString.test(value) && jQuery && jQuery(value)[0];
                } catch (e) {}
                if (elem) {
                    value = $templates[elem.getAttribute(tmplAttr)];
                    if (!value) {
                        name = name || "_" + autoTmplName++;
                        elem.setAttribute(tmplAttr, name);
                        value = compile(elem.innerHTML, name, parent, options);
                        $templates[name] = value;
                    }
                }
                return value;
            }
        }
        tmpl = tmpl || "";
        tmplOrMarkup = tmplOrMarkupFromStr(tmpl);
        options = options || (tmpl.markup ? tmpl : {});
        options.name = name;
        options.is = "tmpl";
        if (!tmplOrMarkup && tmpl.markup && (tmplOrMarkup = tmplOrMarkupFromStr(tmpl.markup))) {
            if (tmplOrMarkup.fn && (tmplOrMarkup.debug !== tmpl.debug || tmplOrMarkup.allowCode !== tmpl.allowCode)) {
                tmplOrMarkup = tmplOrMarkup.markup;
            }
        }
        if (tmplOrMarkup !== undefined) {
            if (name && !parent) {
                $render[name] = function() {
                    return tmpl.render.apply(tmpl, arguments);
                };
            }
            if (tmplOrMarkup.fn || tmpl.fn) {
                if (tmplOrMarkup.fn) {
                    if (name && name !== tmplOrMarkup.name) {
                        tmpl = $extend($extend({}, tmplOrMarkup), options);
                    } else {
                        tmpl = tmplOrMarkup;
                    }
                }
            } else {
                tmpl = TmplObject(tmplOrMarkup, options, parent, 0);
                tmplFn(tmplOrMarkup, tmpl);
            }
            compileNested(options.templates, compile, tmpl);
            compileNested(options.tags, compileTag);
            return tmpl;
        }
    }
    function TmplObject(markup, options, parent, key) {
        function extendStore(storeName) {
            if (parent[storeName]) {
                tmpl[storeName] = $extend($extend({}, parent[storeName]), options[storeName]);
            }
        }
        options = options || {};
        var tmpl = {
            markup: markup,
            tmpls: [],
            links: [],
            render: renderContent
        };
        if (parent) {
            if (parent.templates) {
                tmpl.templates = $extend($extend({}, parent.templates), options.templates);
            }
            tmpl.parent = parent;
            tmpl.name = parent.name + "[" + key + "]";
            tmpl.key = key;
        }
        $extend(tmpl, options);
        if (parent) {
            extendStore("templates");
            extendStore("tags");
            extendStore("helpers");
            extendStore("converters");
        }
        return tmpl;
    }
    if (jQuery) {
        $ = jQuery;
        $.templates = $templates;
        $.render = $render;
        $.views = $views;
        $.fn.render = renderContent;
    } else {
        $ = global.jsviews = $views;
        $.extend = function(target, source) {
            var name;
            target = target || {};
            for (name in source) {
                target[name] = source[name];
            }
            return target;
        };
        $.isArray = Array && Array.isArray || function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
        };
    }
    $extend = $.extend;
    function replacerForHtml(ch) {
        return escapeMapForHtml[ch] || (escapeMapForHtml[ch] = "&#" + ch.charCodeAt(0) + ";");
    }
    $viewsTags({
        "if": function() {
            var ifTag = this, view = ifTag.view;
            view.onElse = function(tagInstance, args) {
                var i = 0, l = args.length;
                while (l && !args[i++]) {
                    if (i === l) {
                        return "";
                    }
                }
                view.onElse = undefined;
                tagInstance.path = "";
                return tagInstance.renderContent(view);
            };
            return view.onElse(this, arguments);
        },
        "else": function() {
            var view = this.view;
            return view.onElse ? view.onElse(this, arguments) : "";
        },
        "for": function() {
            var i, self = this, result = "", args = arguments, l = args.length;
            if (l === 0) {
                l = 1;
            }
            for (i = 0; i < l; i++) {
                result += self.renderContent(args[i]);
            }
            return result;
        },
        "*": function(value) {
            return value;
        }
    });
    $viewsConverters({
        html: function(text) {
            return text != undefined ? String(text).replace(htmlSpecialChar, replacerForHtml) : "";
        }
    });
    $viewsDelimiters();
})(this, this.jQuery);

d3 = function() {
    var d3 = {
        version: "3.1.9"
    };
    if (!Date.now) Date.now = function() {
        return +new Date();
    };
    var d3_document = document, d3_window = window;
    try {
        d3_document.createElement("div").style.setProperty("opacity", 0, "");
    } catch (error) {
        var d3_style_prototype = d3_window.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
        d3_style_prototype.setProperty = function(name, value, priority) {
            d3_style_setProperty.call(this, name, value + "", priority);
        };
    }
    d3.ascending = function(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    };
    d3.descending = function(a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    };
    d3.min = function(array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
            while (++i < n) if ((b = array[i]) != null && a > b) a = b;
        } else {
            while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
        }
        return a;
    };
    d3.max = function(array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
            while (++i < n) if ((b = array[i]) != null && b > a) a = b;
        } else {
            while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
        }
        return a;
    };
    d3.extent = function(array, f) {
        var i = -1, n = array.length, a, b, c;
        if (arguments.length === 1) {
            while (++i < n && ((a = c = array[i]) == null || a != a)) a = c = undefined;
            while (++i < n) if ((b = array[i]) != null) {
                if (a > b) a = b;
                if (c < b) c = b;
            }
        } else {
            while (++i < n && ((a = c = f.call(array, array[i], i)) == null || a != a)) a = undefined;
            while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
                if (a > b) a = b;
                if (c < b) c = b;
            }
        }
        return [ a, c ];
    };
    d3.sum = function(array, f) {
        var s = 0, n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n) if (!isNaN(a = +array[i])) s += a;
        } else {
            while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;
        }
        return s;
    };
    function d3_number(x) {
        return x != null && !isNaN(x);
    }
    d3.mean = function(array, f) {
        var n = array.length, a, m = 0, i = -1, j = 0;
        if (arguments.length === 1) {
            while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;
        } else {
            while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;
        }
        return j ? m : undefined;
    };
    d3.quantile = function(values, p) {
        var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
        return e ? v + e * (values[h] - v) : v;
    };
    d3.median = function(array, f) {
        if (arguments.length > 1) array = array.map(f);
        array = array.filter(d3_number);
        return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;
    };
    d3.bisector = function(f) {
        return {
            left: function(a, x, lo, hi) {
                if (arguments.length < 3) lo = 0;
                if (arguments.length < 4) hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (f.call(a, a[mid], mid) < x) lo = mid + 1; else hi = mid;
                }
                return lo;
            },
            right: function(a, x, lo, hi) {
                if (arguments.length < 3) lo = 0;
                if (arguments.length < 4) hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (x < f.call(a, a[mid], mid)) hi = mid; else lo = mid + 1;
                }
                return lo;
            }
        };
    };
    var d3_bisector = d3.bisector(function(d) {
        return d;
    });
    d3.bisectLeft = d3_bisector.left;
    d3.bisect = d3.bisectRight = d3_bisector.right;
    d3.shuffle = function(array) {
        var m = array.length, t, i;
        while (m) {
            i = Math.random() * m-- | 0;
            t = array[m], array[m] = array[i], array[i] = t;
        }
        return array;
    };
    d3.permute = function(array, indexes) {
        var permutes = [], i = -1, n = indexes.length;
        while (++i < n) permutes[i] = array[indexes[i]];
        return permutes;
    };
    d3.zip = function() {
        if (!(n = arguments.length)) return [];
        for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
            for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
                zip[j] = arguments[j][i];
            }
        }
        return zips;
    };
    function d3_zipLength(d) {
        return d.length;
    }
    d3.transpose = function(matrix) {
        return d3.zip.apply(d3, matrix);
    };
    d3.keys = function(map) {
        var keys = [];
        for (var key in map) keys.push(key);
        return keys;
    };
    d3.values = function(map) {
        var values = [];
        for (var key in map) values.push(map[key]);
        return values;
    };
    d3.entries = function(map) {
        var entries = [];
        for (var key in map) entries.push({
            key: key,
            value: map[key]
        });
        return entries;
    };
    d3.merge = function(arrays) {
        return Array.prototype.concat.apply([], arrays);
    };
    d3.range = function(start, stop, step) {
        if (arguments.length < 3) {
            step = 1;
            if (arguments.length < 2) {
                stop = start;
                start = 0;
            }
        }
        if ((stop - start) / step === Infinity) throw new Error("infinite range");
        var range = [], k = d3_range_integerScale(Math.abs(step)), i = -1, j;
        start *= k, stop *= k, step *= k;
        if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
        return range;
    };
    function d3_range_integerScale(x) {
        var k = 1;
        while (x * k % 1) k *= 10;
        return k;
    }
    function d3_class(ctor, properties) {
        try {
            for (var key in properties) {
                Object.defineProperty(ctor.prototype, key, {
                    value: properties[key],
                    enumerable: false
                });
            }
        } catch (e) {
            ctor.prototype = properties;
        }
    }
    d3.map = function(object) {
        var map = new d3_Map();
        for (var key in object) map.set(key, object[key]);
        return map;
    };
    function d3_Map() {}
    d3_class(d3_Map, {
        has: function(key) {
            return d3_map_prefix + key in this;
        },
        get: function(key) {
            return this[d3_map_prefix + key];
        },
        set: function(key, value) {
            return this[d3_map_prefix + key] = value;
        },
        remove: function(key) {
            key = d3_map_prefix + key;
            return key in this && delete this[key];
        },
        keys: function() {
            var keys = [];
            this.forEach(function(key) {
                keys.push(key);
            });
            return keys;
        },
        values: function() {
            var values = [];
            this.forEach(function(key, value) {
                values.push(value);
            });
            return values;
        },
        entries: function() {
            var entries = [];
            this.forEach(function(key, value) {
                entries.push({
                    key: key,
                    value: value
                });
            });
            return entries;
        },
        forEach: function(f) {
            for (var key in this) {
                if (key.charCodeAt(0) === d3_map_prefixCode) {
                    f.call(this, key.substring(1), this[key]);
                }
            }
        }
    });
    var d3_map_prefix = "\0", d3_map_prefixCode = d3_map_prefix.charCodeAt(0);
    d3.nest = function() {
        var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
        function map(mapType, array, depth) {
            if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
            var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
            while (++i < n) {
                if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
                    values.push(object);
                } else {
                    valuesByKey.set(keyValue, [ object ]);
                }
            }
            if (mapType) {
                object = mapType();
                setter = function(keyValue, values) {
                    object.set(keyValue, map(mapType, values, depth));
                };
            } else {
                object = {};
                setter = function(keyValue, values) {
                    object[keyValue] = map(mapType, values, depth);
                };
            }
            valuesByKey.forEach(setter);
            return object;
        }
        function entries(map, depth) {
            if (depth >= keys.length) return map;
            var array = [], sortKey = sortKeys[depth++];
            map.forEach(function(key, keyMap) {
                array.push({
                    key: key,
                    values: entries(keyMap, depth)
                });
            });
            return sortKey ? array.sort(function(a, b) {
                return sortKey(a.key, b.key);
            }) : array;
        }
        nest.map = function(array, mapType) {
            return map(mapType, array, 0);
        };
        nest.entries = function(array) {
            return entries(map(d3.map, array, 0), 0);
        };
        nest.key = function(d) {
            keys.push(d);
            return nest;
        };
        nest.sortKeys = function(order) {
            sortKeys[keys.length - 1] = order;
            return nest;
        };
        nest.sortValues = function(order) {
            sortValues = order;
            return nest;
        };
        nest.rollup = function(f) {
            rollup = f;
            return nest;
        };
        return nest;
    };
    d3.set = function(array) {
        var set = new d3_Set();
        if (array) for (var i = 0; i < array.length; i++) set.add(array[i]);
        return set;
    };
    function d3_Set() {}
    d3_class(d3_Set, {
        has: function(value) {
            return d3_map_prefix + value in this;
        },
        add: function(value) {
            this[d3_map_prefix + value] = true;
            return value;
        },
        remove: function(value) {
            value = d3_map_prefix + value;
            return value in this && delete this[value];
        },
        values: function() {
            var values = [];
            this.forEach(function(value) {
                values.push(value);
            });
            return values;
        },
        forEach: function(f) {
            for (var value in this) {
                if (value.charCodeAt(0) === d3_map_prefixCode) {
                    f.call(this, value.substring(1));
                }
            }
        }
    });
    d3.behavior = {};
    d3.rebind = function(target, source) {
        var i = 1, n = arguments.length, method;
        while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
    };
    function d3_rebind(target, source, method) {
        return function() {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
        };
    }
    d3.dispatch = function() {
        var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
        while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
    };
    function d3_dispatch() {}
    d3_dispatch.prototype.on = function(type, listener) {
        var i = type.indexOf("."), name = "";
        if (i >= 0) {
            name = type.substring(i + 1);
            type = type.substring(0, i);
        }
        if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
            if (listener == null) for (type in this) {
                if (this.hasOwnProperty(type)) this[type].on(name, null);
            }
            return this;
        }
    };
    function d3_dispatch_event(dispatch) {
        var listeners = [], listenerByName = new d3_Map();
        function event() {
            var z = listeners, i = -1, n = z.length, l;
            while (++i < n) if (l = z[i].on) l.apply(this, arguments);
            return dispatch;
        }
        event.on = function(name, listener) {
            var l = listenerByName.get(name), i;
            if (arguments.length < 2) return l && l.on;
            if (l) {
                l.on = null;
                listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
                listenerByName.remove(name);
            }
            if (listener) listeners.push(listenerByName.set(name, {
                on: listener
            }));
            return dispatch;
        };
        return event;
    }
    d3.event = null;
    function d3_eventCancel() {
        d3.event.stopPropagation();
        d3.event.preventDefault();
    }
    function d3_eventSource() {
        var e = d3.event, s;
        while (s = e.sourceEvent) e = s;
        return e;
    }
    function d3_eventSuppress(target, type) {
        function off() {
            target.on(type, null);
        }
        target.on(type, function() {
            d3_eventCancel();
            off();
        }, true);
        setTimeout(off, 0);
    }
    function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
        while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function(thiz, argumentz) {
            return function(e1) {
                try {
                    var e0 = e1.sourceEvent = d3.event;
                    e1.target = target;
                    d3.event = e1;
                    dispatch[e1.type].apply(thiz, argumentz);
                } finally {
                    d3.event = e0;
                }
            };
        };
        return dispatch;
    }
    d3.mouse = function(container) {
        return d3_mousePoint(container, d3_eventSource());
    };
    var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;
    function d3_mousePoint(container, e) {
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            if (d3_mouse_bug44083 < 0 && (d3_window.scrollX || d3_window.scrollY)) {
                svg = d3.select(d3_document.body).append("svg").style("position", "absolute").style("top", 0).style("left", 0);
                var ctm = svg[0][0].getScreenCTM();
                d3_mouse_bug44083 = !(ctm.f || ctm.e);
                svg.remove();
            }
            if (d3_mouse_bug44083) {
                point.x = e.pageX;
                point.y = e.pageY;
            } else {
                point.x = e.clientX;
                point.y = e.clientY;
            }
            point = point.matrixTransform(container.getScreenCTM().inverse());
            return [ point.x, point.y ];
        }
        var rect = container.getBoundingClientRect();
        return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
    }
    var d3_array = d3_arraySlice;
    function d3_arrayCopy(pseudoarray) {
        var i = -1, n = pseudoarray.length, array = [];
        while (++i < n) array.push(pseudoarray[i]);
        return array;
    }
    function d3_arraySlice(pseudoarray) {
        return Array.prototype.slice.call(pseudoarray);
    }
    try {
        d3_array(d3_document.documentElement.childNodes)[0].nodeType;
    } catch (e) {
        d3_array = d3_arrayCopy;
    }
    var d3_arraySubclass = [].__proto__ ? function(array, prototype) {
        array.__proto__ = prototype;
    } : function(array, prototype) {
        for (var property in prototype) array[property] = prototype[property];
    };
    d3.touches = function(container, touches) {
        if (arguments.length < 2) touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function(touch) {
            var point = d3_mousePoint(container, touch);
            point.identifier = touch.identifier;
            return point;
        }) : [];
    };
    d3.behavior.drag = function() {
        var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null;
        function drag() {
            this.on("mousedown.drag", mousedown).on("touchstart.drag", mousedown);
        }
        function mousedown() {
            var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, touchId = d3.event.touches ? d3.event.changedTouches[0].identifier : null, offset, origin_ = point(), moved = 0;
            var w = d3.select(d3_window).on(touchId != null ? "touchmove.drag-" + touchId : "mousemove.drag", dragmove).on(touchId != null ? "touchend.drag-" + touchId : "mouseup.drag", dragend, true);
            if (origin) {
                offset = origin.apply(target, arguments);
                offset = [ offset.x - origin_[0], offset.y - origin_[1] ];
            } else {
                offset = [ 0, 0 ];
            }
            if (touchId == null) d3_eventCancel();
            event_({
                type: "dragstart"
            });
            function point() {
                var p = target.parentNode;
                return touchId != null ? d3.touches(p).filter(function(p) {
                    return p.identifier === touchId;
                })[0] : d3.mouse(p);
            }
            function dragmove() {
                if (!target.parentNode) return dragend();
                var p = point(), dx = p[0] - origin_[0], dy = p[1] - origin_[1];
                moved |= dx | dy;
                origin_ = p;
                d3_eventCancel();
                event_({
                    type: "drag",
                    x: p[0] + offset[0],
                    y: p[1] + offset[1],
                    dx: dx,
                    dy: dy
                });
            }
            function dragend() {
                event_({
                    type: "dragend"
                });
                if (moved) {
                    d3_eventCancel();
                    if (d3.event.target === eventTarget) d3_eventSuppress(w, "click");
                }
                w.on(touchId != null ? "touchmove.drag-" + touchId : "mousemove.drag", null).on(touchId != null ? "touchend.drag-" + touchId : "mouseup.drag", null);
            }
        }
        drag.origin = function(x) {
            if (!arguments.length) return origin;
            origin = x;
            return drag;
        };
        return d3.rebind(drag, event, "on");
    };
    function d3_selection(groups) {
        d3_arraySubclass(groups, d3_selectionPrototype);
        return groups;
    }
    var d3_select = function(s, n) {
        return n.querySelector(s);
    }, d3_selectAll = function(s, n) {
        return n.querySelectorAll(s);
    }, d3_selectRoot = d3_document.documentElement, d3_selectMatcher = d3_selectRoot.matchesSelector || d3_selectRoot.webkitMatchesSelector || d3_selectRoot.mozMatchesSelector || d3_selectRoot.msMatchesSelector || d3_selectRoot.oMatchesSelector, d3_selectMatches = function(n, s) {
        return d3_selectMatcher.call(n, s);
    };
    if (typeof Sizzle === "function") {
        d3_select = function(s, n) {
            return Sizzle(s, n)[0] || null;
        };
        d3_selectAll = function(s, n) {
            return Sizzle.uniqueSort(Sizzle(s, n));
        };
        d3_selectMatches = Sizzle.matchesSelector;
    }
    d3.selection = function() {
        return d3_selectionRoot;
    };
    var d3_selectionPrototype = d3.selection.prototype = [];
    d3_selectionPrototype.select = function(selector) {
        var subgroups = [], subgroup, subnode, group, node;
        if (typeof selector !== "function") selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    subgroup.push(subnode = selector.call(node, node.__data__, i));
                    if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selector(selector) {
        return function() {
            return d3_select(selector, this);
        };
    }
    d3_selectionPrototype.selectAll = function(selector) {
        var subgroups = [], subgroup, node;
        if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i)));
                    subgroup.parentNode = node;
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selectorAll(selector) {
        return function() {
            return d3_selectAll(selector, this);
        };
    }
    var d3_nsPrefix = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: "http://www.w3.org/1999/xhtml",
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };
    d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function(name) {
            var i = name.indexOf(":"), prefix = name;
            if (i >= 0) {
                prefix = name.substring(0, i);
                name = name.substring(i + 1);
            }
            return d3_nsPrefix.hasOwnProperty(prefix) ? {
                space: d3_nsPrefix[prefix],
                local: name
            } : name;
        }
    };
    d3_selectionPrototype.attr = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") {
                var node = this.node();
                name = d3.ns.qualify(name);
                return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
            }
            for (value in name) this.each(d3_selection_attr(value, name[value]));
            return this;
        }
        return this.each(d3_selection_attr(name, value));
    };
    function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
            this.setAttribute(name, value);
        }
        function attrConstantNS() {
            this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
        }
        function attrFunctionNS() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
    }
    function d3_collapse(s) {
        return s.trim().replace(/\s+/g, " ");
    }
    d3.requote = function(s) {
        return s.replace(d3_requote_re, "\\$&");
    };
    var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    d3_selectionPrototype.classed = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") {
                var node = this.node(), n = (name = name.trim().split(/^|\s+/g)).length, i = -1;
                if (value = node.classList) {
                    while (++i < n) if (!value.contains(name[i])) return false;
                } else {
                    value = node.getAttribute("class");
                    while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
                }
                return true;
            }
            for (value in name) this.each(d3_selection_classed(value, name[value]));
            return this;
        }
        return this.each(d3_selection_classed(name, value));
    };
    function d3_selection_classedRe(name) {
        return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
    }
    function d3_selection_classed(name, value) {
        name = name.trim().split(/\s+/).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
            var i = -1;
            while (++i < n) name[i](this, value);
        }
        function classedFunction() {
            var i = -1, x = value.apply(this, arguments);
            while (++i < n) name[i](this, x);
        }
        return typeof value === "function" ? classedFunction : classedConstant;
    }
    function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function(node, value) {
            if (c = node.classList) return value ? c.add(name) : c.remove(name);
            var c = node.getAttribute("class") || "";
            if (value) {
                re.lastIndex = 0;
                if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
            } else {
                node.setAttribute("class", d3_collapse(c.replace(re, " ")));
            }
        };
    }
    d3_selectionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== "string") {
                if (n < 2) value = "";
                for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
                return this;
            }
            if (n < 2) return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);
            priority = "";
        }
        return this.each(d3_selection_style(name, value, priority));
    };
    function d3_selection_style(name, value, priority) {
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleConstant() {
            this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
    }
    d3_selectionPrototype.property = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") return this.node()[name];
            for (value in name) this.each(d3_selection_property(value, name[value]));
            return this;
        }
        return this.each(d3_selection_property(name, value));
    };
    function d3_selection_property(name, value) {
        function propertyNull() {
            delete this[name];
        }
        function propertyConstant() {
            this[name] = value;
        }
        function propertyFunction() {
            var x = value.apply(this, arguments);
            if (x == null) delete this[name]; else this[name] = x;
        }
        return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
    }
    d3_selectionPrototype.text = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
        } : value == null ? function() {
            this.textContent = "";
        } : function() {
            this.textContent = value;
        }) : this.node().textContent;
    };
    d3_selectionPrototype.html = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
        } : value == null ? function() {
            this.innerHTML = "";
        } : function() {
            this.innerHTML = value;
        }) : this.node().innerHTML;
    };
    d3_selectionPrototype.append = function(name) {
        name = d3.ns.qualify(name);
        function append() {
            return this.appendChild(d3_document.createElementNS(this.namespaceURI, name));
        }
        function appendNS() {
            return this.appendChild(d3_document.createElementNS(name.space, name.local));
        }
        return this.select(name.local ? appendNS : append);
    };
    d3_selectionPrototype.insert = function(name, before) {
        name = d3.ns.qualify(name);
        if (typeof before !== "function") before = d3_selection_selector(before);
        function insert(d, i) {
            return this.insertBefore(d3_document.createElementNS(this.namespaceURI, name), before.call(this, d, i));
        }
        function insertNS(d, i) {
            return this.insertBefore(d3_document.createElementNS(name.space, name.local), before.call(this, d, i));
        }
        return this.select(name.local ? insertNS : insert);
    };
    d3_selectionPrototype.remove = function() {
        return this.each(function() {
            var parent = this.parentNode;
            if (parent) parent.removeChild(this);
        });
    };
    d3_selectionPrototype.data = function(value, key) {
        var i = -1, n = this.length, group, node;
        if (!arguments.length) {
            value = new Array(n = (group = this[0]).length);
            while (++i < n) {
                if (node = group[i]) {
                    value[i] = node.__data__;
                }
            }
            return value;
        }
        function bind(group, groupData) {
            var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
            if (key) {
                var nodeByKeyValue = new d3_Map(), dataByKeyValue = new d3_Map(), keyValues = [], keyValue;
                for (i = -1; ++i < n; ) {
                    keyValue = key.call(node = group[i], node.__data__, i);
                    if (nodeByKeyValue.has(keyValue)) {
                        exitNodes[i] = node;
                    } else {
                        nodeByKeyValue.set(keyValue, node);
                    }
                    keyValues.push(keyValue);
                }
                for (i = -1; ++i < m; ) {
                    keyValue = key.call(groupData, nodeData = groupData[i], i);
                    if (node = nodeByKeyValue.get(keyValue)) {
                        updateNodes[i] = node;
                        node.__data__ = nodeData;
                    } else if (!dataByKeyValue.has(keyValue)) {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    }
                    dataByKeyValue.set(keyValue, nodeData);
                    nodeByKeyValue.remove(keyValue);
                }
                for (i = -1; ++i < n; ) {
                    if (nodeByKeyValue.has(keyValues[i])) {
                        exitNodes[i] = group[i];
                    }
                }
            } else {
                for (i = -1; ++i < n0; ) {
                    node = group[i];
                    nodeData = groupData[i];
                    if (node) {
                        node.__data__ = nodeData;
                        updateNodes[i] = node;
                    } else {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    }
                }
                for (;i < m; ++i) {
                    enterNodes[i] = d3_selection_dataNode(groupData[i]);
                }
                for (;i < n; ++i) {
                    exitNodes[i] = group[i];
                }
            }
            enterNodes.update = updateNodes;
            enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
            enter.push(enterNodes);
            update.push(updateNodes);
            exit.push(exitNodes);
        }
        var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
        if (typeof value === "function") {
            while (++i < n) {
                bind(group = this[i], value.call(group, group.parentNode.__data__, i));
            }
        } else {
            while (++i < n) {
                bind(group = this[i], value);
            }
        }
        update.enter = function() {
            return enter;
        };
        update.exit = function() {
            return exit;
        };
        return update;
    };
    function d3_selection_dataNode(data) {
        return {
            __data__: data
        };
    }
    d3_selectionPrototype.datum = function(value) {
        return arguments.length ? this.property("__data__", value) : this.property("__data__");
    };
    d3_selectionPrototype.filter = function(filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== "function") filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_filter(selector) {
        return function() {
            return d3_selectMatches(this, selector);
        };
    }
    d3_selectionPrototype.order = function() {
        for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
                if (node = group[i]) {
                    if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    };
    d3_selectionPrototype.sort = function(comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
        return this.order();
    };
    function d3_selection_sortComparator(comparator) {
        if (!arguments.length) comparator = d3.ascending;
        return function(a, b) {
            return !a - !b || comparator(a.__data__, b.__data__);
        };
    }
    function d3_noop() {}
    d3_selectionPrototype.on = function(type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof type !== "string") {
                if (n < 2) listener = false;
                for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
                return this;
            }
            if (n < 2) return (n = this.node()["__on" + type]) && n._;
            capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
    };
    function d3_selection_on(type, listener, capture) {
        var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
        if (i > 0) type = type.substring(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter) type = filter, wrap = d3_selection_onFilter;
        function onRemove() {
            var l = this[name];
            if (l) {
                this.removeEventListener(type, l, l.$);
                delete this[name];
            }
        }
        function onAdd() {
            var l = wrap(listener, d3_array(arguments));
            onRemove.call(this);
            this.addEventListener(type, this[name] = l, l.$ = capture);
            l._ = listener;
        }
        function removeAll() {
            var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
            for (var name in this) {
                if (match = name.match(re)) {
                    var l = this[name];
                    this.removeEventListener(match[1], l, l.$);
                    delete this[name];
                }
            }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
    }
    var d3_selection_onFilters = d3.map({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    });
    d3_selection_onFilters.forEach(function(k) {
        if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
    function d3_selection_onListener(listener, argumentz) {
        return function(e) {
            var o = d3.event;
            d3.event = e;
            argumentz[0] = this.__data__;
            try {
                listener.apply(this, argumentz);
            } finally {
                d3.event = o;
            }
        };
    }
    function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function(e) {
            var target = this, related = e.relatedTarget;
            if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
                l.call(target, e);
            }
        };
    }
    d3_selectionPrototype.each = function(callback) {
        return d3_selection_each(this, function(node, i, j) {
            callback.call(node, node.__data__, i, j);
        });
    };
    function d3_selection_each(groups, callback) {
        for (var j = 0, m = groups.length; j < m; j++) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
                if (node = group[i]) callback(node, i, j);
            }
        }
        return groups;
    }
    d3_selectionPrototype.call = function(callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
    };
    d3_selectionPrototype.empty = function() {
        return !this.node();
    };
    d3_selectionPrototype.node = function() {
        for (var j = 0, m = this.length; j < m; j++) {
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                var node = group[i];
                if (node) return node;
            }
        }
        return null;
    };
    function d3_selection_enter(selection) {
        d3_arraySubclass(selection, d3_selection_enterPrototype);
        return selection;
    }
    var d3_selection_enterPrototype = [];
    d3.selection.enter = d3_selection_enter;
    d3.selection.enter.prototype = d3_selection_enterPrototype;
    d3_selection_enterPrototype.append = d3_selectionPrototype.append;
    d3_selection_enterPrototype.insert = d3_selectionPrototype.insert;
    d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
    d3_selection_enterPrototype.node = d3_selectionPrototype.node;
    d3_selection_enterPrototype.select = function(selector) {
        var subgroups = [], subgroup, subnode, upgroup, group, node;
        for (var j = -1, m = this.length; ++j < m; ) {
            upgroup = (group = this[j]).update;
            subgroups.push(subgroup = []);
            subgroup.parentNode = group.parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i));
                    subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    d3_selectionPrototype.transition = function() {
        var id = d3_transitionInheritId || ++d3_transitionId, subgroups = [], subgroup, node, transition = Object.create(d3_transitionInherit);
        transition.time = Date.now();
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) d3_transitionNode(node, i, id, transition);
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, id);
    };
    d3.select = function(node) {
        var group = [ typeof node === "string" ? d3_select(node, d3_document) : node ];
        group.parentNode = d3_selectRoot;
        return d3_selection([ group ]);
    };
    d3.selectAll = function(nodes) {
        var group = d3_array(typeof nodes === "string" ? d3_selectAll(nodes, d3_document) : nodes);
        group.parentNode = d3_selectRoot;
        return d3_selection([ group ]);
    };
    var d3_selectionRoot = d3.select(d3_selectRoot);
    d3.behavior.zoom = function() {
        var translate = [ 0, 0 ], translate0, scale = 1, scale0, scaleExtent = d3_behavior_zoomInfinity, event = d3_eventDispatch(zoom, "zoom"), x0, x1, y0, y1, touchtime;
        function zoom() {
            this.on("mousedown.zoom", mousedown).on("mousemove.zoom", mousemove).on(d3_behavior_zoomWheel + ".zoom", mousewheel).on("dblclick.zoom", dblclick).on("touchstart.zoom", touchstart).on("touchmove.zoom", touchmove).on("touchend.zoom", touchstart);
        }
        zoom.translate = function(x) {
            if (!arguments.length) return translate;
            translate = x.map(Number);
            rescale();
            return zoom;
        };
        zoom.scale = function(x) {
            if (!arguments.length) return scale;
            scale = +x;
            rescale();
            return zoom;
        };
        zoom.scaleExtent = function(x) {
            if (!arguments.length) return scaleExtent;
            scaleExtent = x == null ? d3_behavior_zoomInfinity : x.map(Number);
            return zoom;
        };
        zoom.x = function(z) {
            if (!arguments.length) return x1;
            x1 = z;
            x0 = z.copy();
            translate = [ 0, 0 ];
            scale = 1;
            return zoom;
        };
        zoom.y = function(z) {
            if (!arguments.length) return y1;
            y1 = z;
            y0 = z.copy();
            translate = [ 0, 0 ];
            scale = 1;
            return zoom;
        };
        function location(p) {
            return [ (p[0] - translate[0]) / scale, (p[1] - translate[1]) / scale ];
        }
        function point(l) {
            return [ l[0] * scale + translate[0], l[1] * scale + translate[1] ];
        }
        function scaleTo(s) {
            scale = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
            l = point(l);
            translate[0] += p[0] - l[0];
            translate[1] += p[1] - l[1];
        }
        function rescale() {
            if (x1) x1.domain(x0.range().map(function(x) {
                return (x - translate[0]) / scale;
            }).map(x0.invert));
            if (y1) y1.domain(y0.range().map(function(y) {
                return (y - translate[1]) / scale;
            }).map(y0.invert));
        }
        function dispatch(event) {
            rescale();
            d3.event.preventDefault();
            event({
                type: "zoom",
                scale: scale,
                translate: translate
            });
        }
        function mousedown() {
            var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, moved = 0, w = d3.select(d3_window).on("mousemove.zoom", mousemove).on("mouseup.zoom", mouseup), l = location(d3.mouse(target));
            d3_window.focus();
            d3_eventCancel();
            function mousemove() {
                moved = 1;
                translateTo(d3.mouse(target), l);
                dispatch(event_);
            }
            function mouseup() {
                if (moved) d3_eventCancel();
                w.on("mousemove.zoom", null).on("mouseup.zoom", null);
                if (moved && d3.event.target === eventTarget) d3_eventSuppress(w, "click.zoom");
            }
        }
        function mousewheel() {
            if (!translate0) translate0 = location(d3.mouse(this));
            scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * scale);
            translateTo(d3.mouse(this), translate0);
            dispatch(event.of(this, arguments));
        }
        function mousemove() {
            translate0 = null;
        }
        function dblclick() {
            var p = d3.mouse(this), l = location(p), k = Math.log(scale) / Math.LN2;
            scaleTo(Math.pow(2, d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1));
            translateTo(p, l);
            dispatch(event.of(this, arguments));
        }
        function touchstart() {
            var touches = d3.touches(this), now = Date.now();
            scale0 = scale;
            translate0 = {};
            touches.forEach(function(t) {
                translate0[t.identifier] = location(t);
            });
            d3_eventCancel();
            if (touches.length === 1) {
                if (now - touchtime < 500) {
                    var p = touches[0], l = location(touches[0]);
                    scaleTo(scale * 2);
                    translateTo(p, l);
                    dispatch(event.of(this, arguments));
                }
                touchtime = now;
            }
        }
        function touchmove() {
            var touches = d3.touches(this), p0 = touches[0], l0 = translate0[p0.identifier];
            if (p1 = touches[1]) {
                var p1, l1 = translate0[p1.identifier];
                p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
                l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
                scaleTo(d3.event.scale * scale0);
            }
            translateTo(p0, l0);
            touchtime = null;
            dispatch(event.of(this, arguments));
        }
        return d3.rebind(zoom, event, "on");
    };
    var d3_behavior_zoomInfinity = [ 0, Infinity ];
    var d3_behavior_zoomDelta, d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
    }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return d3.event.wheelDelta;
    }, "mousewheel") : (d3_behavior_zoomDelta = function() {
        return -d3.event.detail;
    }, "MozMousePixelScroll");
    function d3_Color() {}
    d3_Color.prototype.toString = function() {
        return this.rgb() + "";
    };
    d3.hsl = function(h, s, l) {
        return arguments.length === 1 ? h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : d3_hsl(+h, +s, +l);
    };
    function d3_hsl(h, s, l) {
        return new d3_Hsl(h, s, l);
    }
    function d3_Hsl(h, s, l) {
        this.h = h;
        this.s = s;
        this.l = l;
    }
    var d3_hslPrototype = d3_Hsl.prototype = new d3_Color();
    d3_hslPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return d3_hsl(this.h, this.s, this.l / k);
    };
    d3_hslPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return d3_hsl(this.h, this.s, k * this.l);
    };
    d3_hslPrototype.rgb = function() {
        return d3_hsl_rgb(this.h, this.s, this.l);
    };
    function d3_hsl_rgb(h, s, l) {
        var m1, m2;
        h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
            if (h > 360) h -= 360; else if (h < 0) h += 360;
            if (h < 60) return m1 + (m2 - m1) * h / 60;
            if (h < 180) return m2;
            if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
            return m1;
        }
        function vv(h) {
            return Math.round(v(h) * 255);
        }
        return d3_rgb(vv(h + 120), vv(h), vv(h - 120));
    }
    var π = Math.PI, ε = 1e-6, d3_radians = π / 180, d3_degrees = 180 / π;
    function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function d3_acos(x) {
        return Math.acos(Math.max(-1, Math.min(1, x)));
    }
    function d3_asin(x) {
        return x > 1 ? π / 2 : x < -1 ? -π / 2 : Math.asin(x);
    }
    function d3_sinh(x) {
        return (Math.exp(x) - Math.exp(-x)) / 2;
    }
    function d3_cosh(x) {
        return (Math.exp(x) + Math.exp(-x)) / 2;
    }
    function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
    }
    d3.hcl = function(h, c, l) {
        return arguments.length === 1 ? h instanceof d3_Hcl ? d3_hcl(h.h, h.c, h.l) : h instanceof d3_Lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : d3_hcl(+h, +c, +l);
    };
    function d3_hcl(h, c, l) {
        return new d3_Hcl(h, c, l);
    }
    function d3_Hcl(h, c, l) {
        this.h = h;
        this.c = c;
        this.l = l;
    }
    var d3_hclPrototype = d3_Hcl.prototype = new d3_Color();
    d3_hclPrototype.brighter = function(k) {
        return d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.darker = function(k) {
        return d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.rgb = function() {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
    };
    function d3_hcl_lab(h, c, l) {
        if (isNaN(h)) h = 0;
        if (isNaN(c)) c = 0;
        return d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
    }
    d3.lab = function(l, a, b) {
        return arguments.length === 1 ? l instanceof d3_Lab ? d3_lab(l.l, l.a, l.b) : l instanceof d3_Hcl ? d3_hcl_lab(l.l, l.c, l.h) : d3_rgb_lab((l = d3.rgb(l)).r, l.g, l.b) : d3_lab(+l, +a, +b);
    };
    function d3_lab(l, a, b) {
        return new d3_Lab(l, a, b);
    }
    function d3_Lab(l, a, b) {
        this.l = l;
        this.a = a;
        this.b = b;
    }
    var d3_lab_K = 18;
    var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
    var d3_labPrototype = d3_Lab.prototype = new d3_Color();
    d3_labPrototype.brighter = function(k) {
        return d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.darker = function(k) {
        return d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.rgb = function() {
        return d3_lab_rgb(this.l, this.a, this.b);
    };
    function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
    }
    function d3_lab_hcl(l, a, b) {
        return l > 0 ? d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : d3_hcl(NaN, NaN, l);
    }
    function d3_lab_xyz(x) {
        return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
    }
    function d3_xyz_lab(x) {
        return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
    }
    function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
    }
    d3.rgb = function(r, g, b) {
        return arguments.length === 1 ? r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : d3_rgb(~~r, ~~g, ~~b);
    };
    function d3_rgb(r, g, b) {
        return new d3_Rgb(r, g, b);
    }
    function d3_Rgb(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
    }
    var d3_rgbPrototype = d3_Rgb.prototype = new d3_Color();
    d3_rgbPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        var r = this.r, g = this.g, b = this.b, i = 30;
        if (!r && !g && !b) return d3_rgb(i, i, i);
        if (r && r < i) r = i;
        if (g && g < i) g = i;
        if (b && b < i) b = i;
        return d3_rgb(Math.min(255, Math.floor(r / k)), Math.min(255, Math.floor(g / k)), Math.min(255, Math.floor(b / k)));
    };
    d3_rgbPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return d3_rgb(Math.floor(k * this.r), Math.floor(k * this.g), Math.floor(k * this.b));
    };
    d3_rgbPrototype.hsl = function() {
        return d3_rgb_hsl(this.r, this.g, this.b);
    };
    d3_rgbPrototype.toString = function() {
        return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
    };
    function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
    }
    function d3_rgb_parse(format, rgb, hsl) {
        var r = 0, g = 0, b = 0, m1, m2, name;
        m1 = /([a-z]+)\((.*)\)/i.exec(format);
        if (m1) {
            m2 = m1[2].split(",");
            switch (m1[1]) {
              case "hsl":
                {
                    return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
                }

              case "rgb":
                {
                    return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
                }
            }
        }
        if (name = d3_rgb_names.get(format)) return rgb(name.r, name.g, name.b);
        if (format != null && format.charAt(0) === "#") {
            if (format.length === 4) {
                r = format.charAt(1);
                r += r;
                g = format.charAt(2);
                g += g;
                b = format.charAt(3);
                b += b;
            } else if (format.length === 7) {
                r = format.substring(1, 3);
                g = format.substring(3, 5);
                b = format.substring(5, 7);
            }
            r = parseInt(r, 16);
            g = parseInt(g, 16);
            b = parseInt(b, 16);
        }
        return rgb(r, g, b);
    }
    function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
        if (d) {
            s = l < .5 ? d / (max + min) : d / (2 - max - min);
            if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
            h *= 60;
        } else {
            h = NaN;
            s = l > 0 && l < 1 ? 0 : h;
        }
        return d3_hsl(h, s, l);
    }
    function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
    }
    function d3_rgb_xyz(r) {
        return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
    }
    function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
    }
    var d3_rgb_names = d3.map({
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavender: "#e6e6fa",
        lavenderblush: "#fff0f5",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
    });
    d3_rgb_names.forEach(function(key, value) {
        d3_rgb_names.set(key, d3_rgb_parse(value, d3_rgb, d3_hsl_rgb));
    });
    function d3_functor(v) {
        return typeof v === "function" ? v : function() {
            return v;
        };
    }
    d3.functor = d3_functor;
    function d3_identity(d) {
        return d;
    }
    d3.xhr = function(url, mimeType, callback) {
        var xhr = {}, dispatch = d3.dispatch("progress", "load", "error"), headers = {}, response = d3_identity, request = new (d3_window.XDomainRequest && /^(http(s)?:)?\/\//.test(url) ? XDomainRequest : XMLHttpRequest)();
        "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
            request.readyState > 3 && respond();
        };
        function respond() {
            var s = request.status;
            !s && request.responseText || s >= 200 && s < 300 || s === 304 ? dispatch.load.call(xhr, response.call(xhr, request)) : dispatch.error.call(xhr, request);
        }
        request.onprogress = function(event) {
            var o = d3.event;
            d3.event = event;
            try {
                dispatch.progress.call(xhr, request);
            } finally {
                d3.event = o;
            }
        };
        xhr.header = function(name, value) {
            name = (name + "").toLowerCase();
            if (arguments.length < 2) return headers[name];
            if (value == null) delete headers[name]; else headers[name] = value + "";
            return xhr;
        };
        xhr.mimeType = function(value) {
            if (!arguments.length) return mimeType;
            mimeType = value == null ? null : value + "";
            return xhr;
        };
        xhr.response = function(value) {
            response = value;
            return xhr;
        };
        [ "get", "post" ].forEach(function(method) {
            xhr[method] = function() {
                return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
            };
        });
        xhr.send = function(method, data, callback) {
            if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
            request.open(method, url, true);
            if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
            if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
            if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
            if (callback != null) xhr.on("error", callback).on("load", function(request) {
                callback(null, request);
            });
            request.send(data == null ? null : data);
            return xhr;
        };
        xhr.abort = function() {
            request.abort();
            return xhr;
        };
        d3.rebind(xhr, dispatch, "on");
        if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
        mimeType = null;
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
    };
    function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function(error, request) {
            callback(error == null ? request : null);
        } : callback;
    }
    function d3_dsv(delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
            if (arguments.length < 3) callback = row, row = null;
            var xhr = d3.xhr(url, mimeType, callback);
            xhr.row = function(_) {
                return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
            };
            return xhr.row(row);
        }
        function response(request) {
            return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
            return function(request) {
                return dsv.parse(request.responseText, f);
            };
        }
        dsv.parse = function(text, f) {
            var o;
            return dsv.parseRows(text, function(row, i) {
                if (o) return o(row, i - 1);
                var a = new Function("d", "return {" + row.map(function(name, i) {
                    return JSON.stringify(name) + ": d[" + i + "]";
                }).join(",") + "}");
                o = f ? function(row, i) {
                    return f(a(row), i);
                } : a;
            });
        };
        dsv.parseRows = function(text, f) {
            var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
            function token() {
                if (I >= N) return EOF;
                if (eol) return eol = false, EOL;
                var j = I;
                if (text.charCodeAt(j) === 34) {
                    var i = j;
                    while (i++ < N) {
                        if (text.charCodeAt(i) === 34) {
                            if (text.charCodeAt(i + 1) !== 34) break;
                            ++i;
                        }
                    }
                    I = i + 2;
                    var c = text.charCodeAt(i + 1);
                    if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(i + 2) === 10) ++I;
                    } else if (c === 10) {
                        eol = true;
                    }
                    return text.substring(j + 1, i).replace(/""/g, '"');
                }
                while (I < N) {
                    var c = text.charCodeAt(I++), k = 1;
                    if (c === 10) eol = true; else if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(I) === 10) ++I, ++k;
                    } else if (c !== delimiterCode) continue;
                    return text.substring(j, I - k);
                }
                return text.substring(j);
            }
            while ((t = token()) !== EOF) {
                var a = [];
                while (t !== EOL && t !== EOF) {
                    a.push(t);
                    t = token();
                }
                if (f && !(a = f(a, n++))) continue;
                rows.push(a);
            }
            return rows;
        };
        dsv.format = function(rows) {
            if (Array.isArray(rows[0])) return dsv.formatRows(rows);
            var fieldSet = new d3_Set(), fields = [];
            rows.forEach(function(row) {
                for (var field in row) {
                    if (!fieldSet.has(field)) {
                        fields.push(fieldSet.add(field));
                    }
                }
            });
            return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
                return fields.map(function(field) {
                    return formatValue(row[field]);
                }).join(delimiter);
            })).join("\n");
        };
        dsv.formatRows = function(rows) {
            return rows.map(formatRow).join("\n");
        };
        function formatRow(row) {
            return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
            return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
    }
    d3.csv = d3_dsv(",", "text/csv");
    d3.tsv = d3_dsv("	", "text/tab-separated-values");
    var d3_timer_id = 0, d3_timer_byId = {}, d3_timer_queue = null, d3_timer_interval, d3_timer_timeout;
    d3.timer = function(callback, delay, then) {
        if (arguments.length < 3) {
            if (arguments.length < 2) delay = 0; else if (!isFinite(delay)) return;
            then = Date.now();
        }
        var timer = d3_timer_byId[callback.id];
        if (timer && timer.callback === callback) {
            timer.then = then;
            timer.delay = delay;
        } else d3_timer_byId[callback.id = ++d3_timer_id] = d3_timer_queue = {
            callback: callback,
            then: then,
            delay: delay,
            next: d3_timer_queue
        };
        if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    };
    function d3_timer_step() {
        var elapsed, now = Date.now(), t1 = d3_timer_queue;
        while (t1) {
            elapsed = now - t1.then;
            if (elapsed >= t1.delay) t1.flush = t1.callback(elapsed);
            t1 = t1.next;
        }
        var delay = d3_timer_flush() - now;
        if (delay > 24) {
            if (isFinite(delay)) {
                clearTimeout(d3_timer_timeout);
                d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
        } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    }
    d3.timer.flush = function() {
        var elapsed, now = Date.now(), t1 = d3_timer_queue;
        while (t1) {
            elapsed = now - t1.then;
            if (!t1.delay) t1.flush = t1.callback(elapsed);
            t1 = t1.next;
        }
        d3_timer_flush();
    };
    function d3_timer_flush() {
        var t0 = null, t1 = d3_timer_queue, then = Infinity;
        while (t1) {
            if (t1.flush) {
                delete d3_timer_byId[t1.callback.id];
                t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;
            } else {
                then = Math.min(then, t1.then + t1.delay);
                t1 = (t0 = t1).next;
            }
        }
        return then;
    }
    var d3_timer_frame = d3_window.requestAnimationFrame || d3_window.webkitRequestAnimationFrame || d3_window.mozRequestAnimationFrame || d3_window.oRequestAnimationFrame || d3_window.msRequestAnimationFrame || function(callback) {
        setTimeout(callback, 17);
    };
    var d3_format_decimalPoint = ".", d3_format_thousandsSeparator = ",", d3_format_grouping = [ 3, 3 ];
    var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
    d3.formatPrefix = function(value, precision) {
        var i = 0;
        if (value) {
            if (value < 0) value *= -1;
            if (precision) value = d3.round(value, d3_format_precision(value, precision));
            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
            i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
    };
    function d3_formatPrefix(d, i) {
        var k = Math.pow(10, Math.abs(8 - i) * 3);
        return {
            scale: i > 8 ? function(d) {
                return d / k;
            } : function(d) {
                return d * k;
            },
            symbol: d
        };
    }
    d3.round = function(x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
    };
    d3.format = function(specifier) {
        var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "", basePrefix = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, suffix = "", integer = false;
        if (precision) precision = +precision.substring(1);
        if (zfill || fill === "0" && align === "=") {
            zfill = fill = "0";
            align = "=";
            if (comma) width -= Math.floor((width - 1) / 4);
        }
        switch (type) {
          case "n":
            comma = true;
            type = "g";
            break;

          case "%":
            scale = 100;
            suffix = "%";
            type = "f";
            break;

          case "p":
            scale = 100;
            suffix = "%";
            type = "r";
            break;

          case "b":
          case "o":
          case "x":
          case "X":
            if (basePrefix) basePrefix = "0" + type.toLowerCase();

          case "c":
          case "d":
            integer = true;
            precision = 0;
            break;

          case "s":
            scale = -1;
            type = "r";
            break;
        }
        if (basePrefix === "#") basePrefix = "";
        if (type == "r" && !precision) type = "g";
        if (precision != null) {
            if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
        }
        type = d3_format_types.get(type) || d3_format_typeDefault;
        var zcomma = zfill && comma;
        return function(value) {
            if (integer && value % 1) return "";
            var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign;
            if (scale < 0) {
                var prefix = d3.formatPrefix(value, precision);
                value = prefix.scale(value);
                suffix = prefix.symbol;
            } else {
                value *= scale;
            }
            value = type(value, precision);
            if (!zfill && comma) value = d3_format_group(value);
            var length = basePrefix.length + value.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
            if (zcomma) value = d3_format_group(padding + value);
            if (d3_format_decimalPoint) value.replace(".", d3_format_decimalPoint);
            negative += basePrefix;
            return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + suffix;
        };
    };
    var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?(#)?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
    var d3_format_types = d3.map({
        b: function(x) {
            return x.toString(2);
        },
        c: function(x) {
            return String.fromCharCode(x);
        },
        o: function(x) {
            return x.toString(8);
        },
        x: function(x) {
            return x.toString(16);
        },
        X: function(x) {
            return x.toString(16).toUpperCase();
        },
        g: function(x, p) {
            return x.toPrecision(p);
        },
        e: function(x, p) {
            return x.toExponential(p);
        },
        f: function(x, p) {
            return x.toFixed(p);
        },
        r: function(x, p) {
            return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
        }
    });
    function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
    }
    function d3_format_typeDefault(x) {
        return x + "";
    }
    var d3_format_group = d3_identity;
    if (d3_format_grouping) {
        var d3_format_groupingLength = d3_format_grouping.length;
        d3_format_group = function(value) {
            var i = value.lastIndexOf("."), f = i >= 0 ? "." + value.substring(i + 1) : (i = value.length, 
            ""), t = [], j = 0, g = d3_format_grouping[0];
            while (i > 0 && g > 0) {
                t.push(value.substring(i -= g, i + g));
                g = d3_format_grouping[j = (j + 1) % d3_format_groupingLength];
            }
            return t.reverse().join(d3_format_thousandsSeparator || "") + f;
        };
    }
    d3.geo = {};
    d3.geo.stream = function(object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
            d3_geo_streamObjectType[object.type](object, listener);
        } else {
            d3_geo_streamGeometry(object, listener);
        }
    };
    function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
            d3_geo_streamGeometryType[geometry.type](geometry, listener);
        }
    }
    var d3_geo_streamObjectType = {
        Feature: function(feature, listener) {
            d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function(object, listener) {
            var features = object.features, i = -1, n = features.length;
            while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
        }
    };
    var d3_geo_streamGeometryType = {
        Sphere: function(object, listener) {
            listener.sphere();
        },
        Point: function(object, listener) {
            var coordinate = object.coordinates;
            listener.point(coordinate[0], coordinate[1]);
        },
        MultiPoint: function(object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length, coordinate;
            while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1]);
        },
        LineString: function(object, listener) {
            d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function(object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function(object, listener) {
            d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function(object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function(object, listener) {
            var geometries = object.geometries, i = -1, n = geometries.length;
            while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
        }
    };
    function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1, n = coordinates.length - closed, coordinate;
        listener.lineStart();
        while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1]);
        listener.lineEnd();
    }
    function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1, n = coordinates.length;
        listener.polygonStart();
        while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
    }
    d3.geo.area = function(object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
    };
    var d3_geo_areaSum, d3_geo_areaRingSum;
    var d3_geo_area = {
        sphere: function() {
            d3_geo_areaSum += 4 * π;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
            d3_geo_areaRingSum = 0;
            d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function() {
            var area = 2 * d3_geo_areaRingSum;
            d3_geo_areaSum += area < 0 ? 4 * π + area : area;
            d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
    };
    function d3_geo_areaRingStart() {
        var λ00, φ00, λ0, cosφ0, sinφ0;
        d3_geo_area.point = function(λ, φ) {
            d3_geo_area.point = nextPoint;
            λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
            sinφ0 = Math.sin(φ);
        };
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            φ = φ * d3_radians / 2 + π / 4;
            var dλ = λ - λ0, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(dλ), v = k * Math.sin(dλ);
            d3_geo_areaRingSum += Math.atan2(v, u);
            λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
        }
        d3_geo_area.lineEnd = function() {
            nextPoint(λ00, φ00);
        };
    }
    function d3_geo_cartesian(spherical) {
        var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
        return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
    }
    function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    function d3_geo_cartesianCross(a, b) {
        return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
    }
    function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
    }
    function d3_geo_cartesianScale(vector, k) {
        return [ vector[0] * k, vector[1] * k, vector[2] * k ];
    }
    function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
    }
    function d3_geo_spherical(cartesian) {
        return [ Math.atan2(cartesian[1], cartesian[0]), Math.asin(Math.max(-1, Math.min(1, cartesian[2]))) ];
    }
    function d3_geo_sphericalEqual(a, b) {
        return Math.abs(a[0] - b[0]) < ε && Math.abs(a[1] - b[1]) < ε;
    }
    d3.geo.bounds = function() {
        var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
        var bound = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
                bound.point = ringPoint;
                bound.lineStart = ringStart;
                bound.lineEnd = ringEnd;
                dλSum = 0;
                d3_geo_area.polygonStart();
            },
            polygonEnd: function() {
                d3_geo_area.polygonEnd();
                bound.point = point;
                bound.lineStart = lineStart;
                bound.lineEnd = lineEnd;
                if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
                range[0] = λ0, range[1] = λ1;
            }
        };
        function point(λ, φ) {
            ranges.push(range = [ λ0 = λ, λ1 = λ ]);
            if (φ < φ0) φ0 = φ;
            if (φ > φ1) φ1 = φ;
        }
        function linePoint(λ, φ) {
            var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
            if (p0) {
                var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
                d3_geo_cartesianNormalize(inflection);
                inflection = d3_geo_spherical(inflection);
                var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = Math.abs(dλ) > 180;
                if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                    var φi = inflection[1] * d3_degrees;
                    if (φi > φ1) φ1 = φi;
                } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                    var φi = -inflection[1] * d3_degrees;
                    if (φi < φ0) φ0 = φi;
                } else {
                    if (φ < φ0) φ0 = φ;
                    if (φ > φ1) φ1 = φ;
                }
                if (antimeridian) {
                    if (λ < λ_) {
                        if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
                    } else {
                        if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
                    }
                } else {
                    if (λ1 >= λ0) {
                        if (λ < λ0) λ0 = λ;
                        if (λ > λ1) λ1 = λ;
                    } else {
                        if (λ > λ_) {
                            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
                        } else {
                            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
                        }
                    }
                }
            } else {
                point(λ, φ);
            }
            p0 = p, λ_ = λ;
        }
        function lineStart() {
            bound.point = linePoint;
        }
        function lineEnd() {
            range[0] = λ0, range[1] = λ1;
            bound.point = point;
            p0 = null;
        }
        function ringPoint(λ, φ) {
            if (p0) {
                var dλ = λ - λ_;
                dλSum += Math.abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
            } else λ__ = λ, φ__ = φ;
            d3_geo_area.point(λ, φ);
            linePoint(λ, φ);
        }
        function ringStart() {
            d3_geo_area.lineStart();
        }
        function ringEnd() {
            ringPoint(λ__, φ__);
            d3_geo_area.lineEnd();
            if (Math.abs(dλSum) > ε) λ0 = -(λ1 = 180);
            range[0] = λ0, range[1] = λ1;
            p0 = null;
        }
        function angle(λ0, λ1) {
            return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
        }
        function compareRanges(a, b) {
            return a[0] - b[0];
        }
        function withinRange(x, range) {
            return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function(feature) {
            φ1 = λ1 = -(λ0 = φ0 = Infinity);
            ranges = [];
            d3.geo.stream(feature, bound);
            ranges.sort(compareRanges);
            for (var i = 1, n = ranges.length, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
                b = ranges[i];
                if (withinRange(b[0], a) || withinRange(b[1], a)) {
                    if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
                    if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
                } else {
                    merged.push(a = b);
                }
            }
            var best = -Infinity, dλ;
            for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
                b = merged[i];
                if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
            }
            ranges = range = null;
            return [ [ λ0, φ0 ], [ λ1, φ1 ] ];
        };
    }();
    d3.geo.centroid = function(object) {
        d3_geo_centroidDimension = d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var m;
        if (d3_geo_centroidW && Math.abs(m = Math.sqrt(d3_geo_centroidX * d3_geo_centroidX + d3_geo_centroidY * d3_geo_centroidY + d3_geo_centroidZ * d3_geo_centroidZ)) > ε) {
            return [ Math.atan2(d3_geo_centroidY, d3_geo_centroidX) * d3_degrees, Math.asin(Math.max(-1, Math.min(1, d3_geo_centroidZ / m))) * d3_degrees ];
        }
    };
    var d3_geo_centroidDimension, d3_geo_centroidW, d3_geo_centroidX, d3_geo_centroidY, d3_geo_centroidZ;
    var d3_geo_centroid = {
        sphere: function() {
            if (d3_geo_centroidDimension < 2) {
                d3_geo_centroidDimension = 2;
                d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
            }
        },
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function() {
            if (d3_geo_centroidDimension < 2) {
                d3_geo_centroidDimension = 2;
                d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
            }
            d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function() {
            d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
    };
    function d3_geo_centroidPoint(λ, φ) {
        if (d3_geo_centroidDimension) return;
        ++d3_geo_centroidW;
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians);
        d3_geo_centroidX += (cosφ * Math.cos(λ) - d3_geo_centroidX) / d3_geo_centroidW;
        d3_geo_centroidY += (cosφ * Math.sin(λ) - d3_geo_centroidY) / d3_geo_centroidW;
        d3_geo_centroidZ += (Math.sin(φ) - d3_geo_centroidZ) / d3_geo_centroidW;
    }
    function d3_geo_centroidRingStart() {
        var λ00, φ00;
        d3_geo_centroidDimension = 1;
        d3_geo_centroidLineStart();
        d3_geo_centroidDimension = 2;
        var linePoint = d3_geo_centroid.point;
        d3_geo_centroid.point = function(λ, φ) {
            linePoint(λ00 = λ, φ00 = φ);
        };
        d3_geo_centroid.lineEnd = function() {
            d3_geo_centroid.point(λ00, φ00);
            d3_geo_centroidLineEnd();
            d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
        };
    }
    function d3_geo_centroidLineStart() {
        var x0, y0, z0;
        if (d3_geo_centroidDimension > 1) return;
        if (d3_geo_centroidDimension < 1) {
            d3_geo_centroidDimension = 1;
            d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
        }
        d3_geo_centroid.point = function(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians);
            x0 = cosφ * Math.cos(λ);
            y0 = cosφ * Math.sin(λ);
            z0 = Math.sin(φ);
            d3_geo_centroid.point = nextPoint;
        };
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
            d3_geo_centroidW += w;
            d3_geo_centroidX += w * (x0 + (x0 = x));
            d3_geo_centroidY += w * (y0 + (y0 = y));
            d3_geo_centroidZ += w * (z0 + (z0 = z));
        }
    }
    function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
    }
    function d3_true() {
        return true;
    }
    function d3_geo_clipPolygon(segments, compare, inside, interpolate, listener) {
        var subject = [], clip = [];
        segments.forEach(function(segment) {
            if ((n = segment.length - 1) <= 0) return;
            var n, p0 = segment[0], p1 = segment[n];
            if (d3_geo_sphericalEqual(p0, p1)) {
                listener.lineStart();
                for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
                listener.lineEnd();
                return;
            }
            var a = {
                point: p0,
                points: segment,
                other: null,
                visited: false,
                entry: true,
                subject: true
            }, b = {
                point: p0,
                points: [ p0 ],
                other: a,
                visited: false,
                entry: false,
                subject: false
            };
            a.other = b;
            subject.push(a);
            clip.push(b);
            a = {
                point: p1,
                points: [ p1 ],
                other: null,
                visited: false,
                entry: false,
                subject: true
            };
            b = {
                point: p1,
                points: [ p1 ],
                other: a,
                visited: false,
                entry: true,
                subject: false
            };
            a.other = b;
            subject.push(a);
            clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length) return;
        if (inside) for (var i = 1, e = !inside(clip[0].point), n = clip.length; i < n; ++i) {
            clip[i].entry = e = !e;
        }
        var start = subject[0], current, points, point;
        while (1) {
            current = start;
            while (current.visited) if ((current = current.next) === start) return;
            points = current.points;
            listener.lineStart();
            do {
                current.visited = current.other.visited = true;
                if (current.entry) {
                    if (current.subject) {
                        for (var i = 0; i < points.length; i++) listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.point, current.next.point, 1, listener);
                    }
                    current = current.next;
                } else {
                    if (current.subject) {
                        points = current.prev.points;
                        for (var i = points.length; --i >= 0; ) listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.point, current.prev.point, -1, listener);
                    }
                    current = current.prev;
                }
                current = current.other;
                points = current.points;
            } while (!current.visited);
            listener.lineEnd();
        }
    }
    function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length)) return;
        var n, i = 0, a = array[0], b;
        while (++i < n) {
            a.next = b = array[i];
            b.prev = a;
            a = b;
        }
        a.next = b = array[0];
        b.prev = a;
    }
    function d3_geo_clip(pointVisible, clipLine, interpolate) {
        return function(listener) {
            var line = clipLine(listener);
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    clip.point = pointRing;
                    clip.lineStart = ringStart;
                    clip.lineEnd = ringEnd;
                    invisible = false;
                    invisibleArea = visibleArea = 0;
                    segments = [];
                    listener.polygonStart();
                },
                polygonEnd: function() {
                    clip.point = point;
                    clip.lineStart = lineStart;
                    clip.lineEnd = lineEnd;
                    segments = d3.merge(segments);
                    if (segments.length) {
                        d3_geo_clipPolygon(segments, d3_geo_clipSort, null, interpolate, listener);
                    } else if (visibleArea < -ε || invisible && invisibleArea < -ε) {
                        listener.lineStart();
                        interpolate(null, null, 1, listener);
                        listener.lineEnd();
                    }
                    listener.polygonEnd();
                    segments = null;
                },
                sphere: function() {
                    listener.polygonStart();
                    listener.lineStart();
                    interpolate(null, null, 1, listener);
                    listener.lineEnd();
                    listener.polygonEnd();
                }
            };
            function point(λ, φ) {
                if (pointVisible(λ, φ)) listener.point(λ, φ);
            }
            function pointLine(λ, φ) {
                line.point(λ, φ);
            }
            function lineStart() {
                clip.point = pointLine;
                line.lineStart();
            }
            function lineEnd() {
                clip.point = point;
                line.lineEnd();
            }
            var segments, visibleArea, invisibleArea, invisible;
            var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), ring;
            function pointRing(λ, φ) {
                ringListener.point(λ, φ);
                ring.push([ λ, φ ]);
            }
            function ringStart() {
                ringListener.lineStart();
                ring = [];
            }
            function ringEnd() {
                pointRing(ring[0][0], ring[0][1]);
                ringListener.lineEnd();
                var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
                if (!n) {
                    invisible = true;
                    invisibleArea += d3_geo_clipAreaRing(ring, -1);
                    ring = null;
                    return;
                }
                ring = null;
                if (clean & 1) {
                    segment = ringSegments[0];
                    visibleArea += d3_geo_clipAreaRing(segment, 1);
                    var n = segment.length - 1, i = -1, point;
                    listener.lineStart();
                    while (++i < n) listener.point((point = segment[i])[0], point[1]);
                    listener.lineEnd();
                    return;
                }
                if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
            }
            return clip;
        };
    }
    function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
    }
    function d3_geo_clipBufferListener() {
        var lines = [], line;
        return {
            lineStart: function() {
                lines.push(line = []);
            },
            point: function(λ, φ) {
                line.push([ λ, φ ]);
            },
            lineEnd: d3_noop,
            buffer: function() {
                var buffer = lines;
                lines = [];
                line = null;
                return buffer;
            },
            rejoin: function() {
                if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
            }
        };
    }
    function d3_geo_clipAreaRing(ring, invisible) {
        if (!(n = ring.length)) return 0;
        var n, i = 0, area = 0, p = ring[0], λ = p[0], φ = p[1], cosφ = Math.cos(φ), x0 = Math.atan2(invisible * Math.sin(λ) * cosφ, Math.sin(φ)), y0 = 1 - invisible * Math.cos(λ) * cosφ, x1 = x0, x, y;
        while (++i < n) {
            p = ring[i];
            cosφ = Math.cos(φ = p[1]);
            x = Math.atan2(invisible * Math.sin(λ = p[0]) * cosφ, Math.sin(φ));
            y = 1 - invisible * Math.cos(λ) * cosφ;
            if (Math.abs(y0 - 2) < ε && Math.abs(y - 2) < ε) continue;
            if (Math.abs(y) < ε || Math.abs(y0) < ε) {} else if (Math.abs(Math.abs(x - x0) - π) < ε) {
                if (y + y0 > 2) area += 4 * (x - x0);
            } else if (Math.abs(y0 - 2) < ε) area += 4 * (x - x1); else area += ((3 * π + x - x0) % (2 * π) - π) * (y0 + y);
            x1 = x0, x0 = x, y0 = y;
        }
        return area;
    }
    function d3_geo_clipSort(a, b) {
        return ((a = a.point)[0] < 0 ? a[1] - π / 2 - ε : π / 2 - a[1]) - ((b = b.point)[0] < 0 ? b[1] - π / 2 - ε : π / 2 - b[1]);
    }
    var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate);
    function d3_geo_clipAntimeridianLine(listener) {
        var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
        return {
            lineStart: function() {
                listener.lineStart();
                clean = 1;
            },
            point: function(λ1, φ1) {
                var sλ1 = λ1 > 0 ? π : -π, dλ = Math.abs(λ1 - λ0);
                if (Math.abs(dλ - π) < ε) {
                    listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? π / 2 : -π / 2);
                    listener.point(sλ0, φ0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(sλ1, φ0);
                    listener.point(λ1, φ0);
                    clean = 0;
                } else if (sλ0 !== sλ1 && dλ >= π) {
                    if (Math.abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
                    if (Math.abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
                    φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
                    listener.point(sλ0, φ0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(sλ1, φ0);
                    clean = 0;
                }
                listener.point(λ0 = λ1, φ0 = φ1);
                sλ0 = sλ1;
            },
            lineEnd: function() {
                listener.lineEnd();
                λ0 = φ0 = NaN;
            },
            clean: function() {
                return 2 - clean;
            }
        };
    }
    function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
        var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
        return Math.abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
    }
    function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var φ;
        if (from == null) {
            φ = direction * π / 2;
            listener.point(-π, φ);
            listener.point(0, φ);
            listener.point(π, φ);
            listener.point(π, 0);
            listener.point(π, -φ);
            listener.point(0, -φ);
            listener.point(-π, -φ);
            listener.point(-π, 0);
            listener.point(-π, φ);
        } else if (Math.abs(from[0] - to[0]) > ε) {
            var s = (from[0] < to[0] ? 1 : -1) * π;
            φ = direction * s / 2;
            listener.point(-s, φ);
            listener.point(0, φ);
            listener.point(s, φ);
        } else {
            listener.point(to[0], to[1]);
        }
    }
    function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = Math.abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate);
        function visible(λ, φ) {
            return Math.cos(λ) * Math.cos(φ) > cr;
        }
        function clipLine(listener) {
            var point0, c0, v0, v00, clean;
            return {
                lineStart: function() {
                    v00 = v0 = false;
                    clean = 1;
                },
                point: function(λ, φ) {
                    var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
                    if (!point0 && (v00 = v0 = v)) listener.lineStart();
                    if (v !== v0) {
                        point2 = intersect(point0, point1);
                        if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                            point1[0] += ε;
                            point1[1] += ε;
                            v = visible(point1[0], point1[1]);
                        }
                    }
                    if (v !== v0) {
                        clean = 0;
                        if (v) {
                            listener.lineStart();
                            point2 = intersect(point1, point0);
                            listener.point(point2[0], point2[1]);
                        } else {
                            point2 = intersect(point0, point1);
                            listener.point(point2[0], point2[1]);
                            listener.lineEnd();
                        }
                        point0 = point2;
                    } else if (notHemisphere && point0 && smallRadius ^ v) {
                        var t;
                        if (!(c & c0) && (t = intersect(point1, point0, true))) {
                            clean = 0;
                            if (smallRadius) {
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                            } else {
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                            }
                        }
                    }
                    if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                        listener.point(point1[0], point1[1]);
                    }
                    point0 = point1, v0 = v, c0 = c;
                },
                lineEnd: function() {
                    if (v0) listener.lineEnd();
                    point0 = null;
                },
                clean: function() {
                    return clean | (v00 && v0) << 1;
                }
            };
        }
        function intersect(a, b, two) {
            var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
            var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
            if (!determinant) return !two && a;
            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
            d3_geo_cartesianAdd(A, B);
            var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
            if (t2 < 0) return;
            var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
            d3_geo_cartesianAdd(q, A);
            q = d3_geo_spherical(q);
            if (!two) return q;
            var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
            if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
            var δλ = λ1 - λ0, polar = Math.abs(δλ - π) < ε, meridian = polar || δλ < ε;
            if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
            if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (Math.abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
                var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
                d3_geo_cartesianAdd(q1, A);
                return [ q, d3_geo_spherical(q1) ];
            }
        }
        function code(λ, φ) {
            var r = smallRadius ? radius : π - radius, code = 0;
            if (λ < -r) code |= 1; else if (λ > r) code |= 2;
            if (φ < -r) code |= 4; else if (φ > r) code |= 8;
            return code;
        }
    }
    var d3_geo_clipViewMAX = 1e9;
    function d3_geo_clipView(x0, y0, x1, y1) {
        return function(listener) {
            var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), segments, polygon, ring;
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    listener = bufferListener;
                    segments = [];
                    polygon = [];
                },
                polygonEnd: function() {
                    listener = listener_;
                    if ((segments = d3.merge(segments)).length) {
                        listener.polygonStart();
                        d3_geo_clipPolygon(segments, compare, inside, interpolate, listener);
                        listener.polygonEnd();
                    } else if (insidePolygon([ x0, y0 ])) {
                        listener.polygonStart(), listener.lineStart();
                        interpolate(null, null, 1, listener);
                        listener.lineEnd(), listener.polygonEnd();
                    }
                    segments = polygon = ring = null;
                }
            };
            function inside(point) {
                var a = corner(point, -1), i = insidePolygon([ a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0 ]);
                return i;
            }
            function insidePolygon(p) {
                var wn = 0, n = polygon.length, y = p[1];
                for (var i = 0; i < n; ++i) {
                    for (var j = 1, v = polygon[i], m = v.length, a = v[0]; j < m; ++j) {
                        b = v[j];
                        if (a[1] <= y) {
                            if (b[1] > y && isLeft(a, b, p) > 0) ++wn;
                        } else {
                            if (b[1] <= y && isLeft(a, b, p) < 0) --wn;
                        }
                        a = b;
                    }
                }
                return wn !== 0;
            }
            function isLeft(a, b, c) {
                return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
            }
            function interpolate(from, to, direction, listener) {
                var a = 0, a1 = 0;
                if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
                    do {
                        listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
                    } while ((a = (a + direction + 4) % 4) !== a1);
                } else {
                    listener.point(to[0], to[1]);
                }
            }
            function visible(x, y) {
                return x0 <= x && x <= x1 && y0 <= y && y <= y1;
            }
            function point(x, y) {
                if (visible(x, y)) listener.point(x, y);
            }
            var x__, y__, v__, x_, y_, v_, first;
            function lineStart() {
                clip.point = linePoint;
                if (polygon) polygon.push(ring = []);
                first = true;
                v_ = false;
                x_ = y_ = NaN;
            }
            function lineEnd() {
                if (segments) {
                    linePoint(x__, y__);
                    if (v__ && v_) bufferListener.rejoin();
                    segments.push(bufferListener.buffer());
                }
                clip.point = point;
                if (v_) listener.lineEnd();
            }
            function linePoint(x, y) {
                x = Math.max(-d3_geo_clipViewMAX, Math.min(d3_geo_clipViewMAX, x));
                y = Math.max(-d3_geo_clipViewMAX, Math.min(d3_geo_clipViewMAX, y));
                var v = visible(x, y);
                if (polygon) ring.push([ x, y ]);
                if (first) {
                    x__ = x, y__ = y, v__ = v;
                    first = false;
                    if (v) {
                        listener.lineStart();
                        listener.point(x, y);
                    }
                } else {
                    if (v && v_) listener.point(x, y); else {
                        var a = [ x_, y_ ], b = [ x, y ];
                        if (clipLine(a, b)) {
                            if (!v_) {
                                listener.lineStart();
                                listener.point(a[0], a[1]);
                            }
                            listener.point(b[0], b[1]);
                            if (!v) listener.lineEnd();
                        } else if (v) {
                            listener.lineStart();
                            listener.point(x, y);
                        }
                    }
                }
                x_ = x, y_ = y, v_ = v;
            }
            return clip;
        };
        function corner(p, direction) {
            return Math.abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : Math.abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : Math.abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
            return comparePoints(a.point, b.point);
        }
        function comparePoints(a, b) {
            var ca = corner(a, 1), cb = corner(b, 1);
            return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
        function clipLine(a, b) {
            var dx = b[0] - a[0], dy = b[1] - a[1], t = [ 0, 1 ];
            if (Math.abs(dx) < ε && Math.abs(dy) < ε) return x0 <= a[0] && a[0] <= x1 && y0 <= a[1] && a[1] <= y1;
            if (d3_geo_clipViewT(x0 - a[0], dx, t) && d3_geo_clipViewT(a[0] - x1, -dx, t) && d3_geo_clipViewT(y0 - a[1], dy, t) && d3_geo_clipViewT(a[1] - y1, -dy, t)) {
                if (t[1] < 1) {
                    b[0] = a[0] + t[1] * dx;
                    b[1] = a[1] + t[1] * dy;
                }
                if (t[0] > 0) {
                    a[0] += t[0] * dx;
                    a[1] += t[0] * dy;
                }
                return true;
            }
            return false;
        }
    }
    function d3_geo_clipViewT(num, denominator, t) {
        if (Math.abs(denominator) < ε) return num <= 0;
        var u = num / denominator;
        if (denominator > 0) {
            if (u > t[1]) return false;
            if (u > t[0]) t[0] = u;
        } else {
            if (u < t[0]) return false;
            if (u < t[1]) t[1] = u;
        }
        return true;
    }
    function d3_geo_compose(a, b) {
        function compose(x, y) {
            return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert) compose.invert = function(x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1]);
        };
        return compose;
    }
    function d3_geo_resample(project) {
        var δ2 = .5, maxDepth = 16;
        function resample(stream) {
            var λ0, x0, y0, a0, b0, c0;
            var resample = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    stream.polygonStart();
                    resample.lineStart = polygonLineStart;
                },
                polygonEnd: function() {
                    stream.polygonEnd();
                    resample.lineStart = lineStart;
                }
            };
            function point(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            }
            function lineStart() {
                x0 = NaN;
                resample.point = linePoint;
                stream.lineStart();
            }
            function linePoint(λ, φ) {
                var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
                resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                stream.point(x0, y0);
            }
            function lineEnd() {
                resample.point = point;
                stream.lineEnd();
            }
            function polygonLineStart() {
                var λ00, φ00, x00, y00, a00, b00, c00;
                lineStart();
                resample.point = function(λ, φ) {
                    linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
                    resample.point = linePoint;
                };
                resample.lineEnd = function() {
                    resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
                    resample.lineEnd = lineEnd;
                    lineEnd();
                };
            }
            return resample;
        }
        function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
            if (d2 > 4 * δ2 && depth--) {
                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = Math.abs(Math.abs(c) - 1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
                if (dz * dz / d2 > δ2 || Math.abs((dx * dx2 + dy * dy2) / d2 - .5) > .3) {
                    resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
                    stream.point(x2, y2);
                    resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
                }
            }
        }
        resample.precision = function(_) {
            if (!arguments.length) return Math.sqrt(δ2);
            maxDepth = (δ2 = _ * _) > 0 && 16;
            return resample;
        };
        return resample;
    }
    d3.geo.projection = d3_geo_projection;
    d3.geo.projectionMutator = d3_geo_projectionMutator;
    function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function() {
            return project;
        })();
    }
    function d3_geo_projectionMutator(projectAt) {
        var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
            x = project(x, y);
            return [ x[0] * k + δx, δy - x[1] * k ];
        }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null;
        function projection(point) {
            point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
            return [ point[0] * k + δx, δy - point[1] * k ];
        }
        function invert(point) {
            point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
            return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
        }
        projection.stream = function(stream) {
            return d3_geo_projectionRadiansRotate(rotate, preclip(projectResample(postclip(stream))));
        };
        projection.clipAngle = function(_) {
            if (!arguments.length) return clipAngle;
            preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
            return projection;
        };
        projection.clipExtent = function(_) {
            if (!arguments.length) return clipExtent;
            clipExtent = _;
            postclip = _ == null ? d3_identity : d3_geo_clipView(_[0][0], _[0][1], _[1][0], _[1][1]);
            return projection;
        };
        projection.scale = function(_) {
            if (!arguments.length) return k;
            k = +_;
            return reset();
        };
        projection.translate = function(_) {
            if (!arguments.length) return [ x, y ];
            x = +_[0];
            y = +_[1];
            return reset();
        };
        projection.center = function(_) {
            if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
            λ = _[0] % 360 * d3_radians;
            φ = _[1] % 360 * d3_radians;
            return reset();
        };
        projection.rotate = function(_) {
            if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
            δλ = _[0] % 360 * d3_radians;
            δφ = _[1] % 360 * d3_radians;
            δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
            return reset();
        };
        d3.rebind(projection, projectResample, "precision");
        function reset() {
            projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
            var center = project(λ, φ);
            δx = x - center[0] * k;
            δy = y + center[1] * k;
            return projection;
        }
        return function() {
            project = projectAt.apply(this, arguments);
            projection.invert = project.invert && invert;
            return reset();
        };
    }
    function d3_geo_projectionRadiansRotate(rotate, stream) {
        return {
            point: function(x, y) {
                y = rotate(x * d3_radians, y * d3_radians), x = y[0];
                stream.point(x > π ? x - 2 * π : x < -π ? x + 2 * π : x, y[1]);
            },
            sphere: function() {
                stream.sphere();
            },
            lineStart: function() {
                stream.lineStart();
            },
            lineEnd: function() {
                stream.lineEnd();
            },
            polygonStart: function() {
                stream.polygonStart();
            },
            polygonEnd: function() {
                stream.polygonEnd();
            }
        };
    }
    function d3_geo_equirectangular(λ, φ) {
        return [ λ, φ ];
    }
    (d3.geo.equirectangular = function() {
        return d3_geo_projection(d3_geo_equirectangular);
    }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
    d3.geo.rotation = function(rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
            coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        }
        forward.invert = function(coordinates) {
            coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        };
        return forward;
    };
    function d3_geo_rotation(δλ, δφ, δγ) {
        return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_equirectangular;
    }
    function d3_geo_forwardRotationλ(δλ) {
        return function(λ, φ) {
            return λ += δλ, [ λ > π ? λ - 2 * π : λ < -π ? λ + 2 * π : λ, φ ];
        };
    }
    function d3_geo_rotationλ(δλ) {
        var rotation = d3_geo_forwardRotationλ(δλ);
        rotation.invert = d3_geo_forwardRotationλ(-δλ);
        return rotation;
    }
    function d3_geo_rotationφγ(δφ, δγ) {
        var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
        function rotation(λ, φ) {
            var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
            return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), Math.asin(Math.max(-1, Math.min(1, k * cosδγ + y * sinδγ))) ];
        }
        rotation.invert = function(λ, φ) {
            var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
            return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), Math.asin(Math.max(-1, Math.min(1, k * cosδφ - x * sinδφ))) ];
        };
        return rotation;
    }
    d3.geo.circle = function() {
        var origin = [ 0, 0 ], angle, precision = 6, interpolate;
        function circle() {
            var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
            interpolate(null, null, 1, {
                point: function(x, y) {
                    ring.push(x = rotate(x, y));
                    x[0] *= d3_degrees, x[1] *= d3_degrees;
                }
            });
            return {
                type: "Polygon",
                coordinates: [ ring ]
            };
        }
        circle.origin = function(x) {
            if (!arguments.length) return origin;
            origin = x;
            return circle;
        };
        circle.angle = function(x) {
            if (!arguments.length) return angle;
            interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
            return circle;
        };
        circle.precision = function(_) {
            if (!arguments.length) return precision;
            interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
            return circle;
        };
        return circle.angle(90);
    };
    function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius), sr = Math.sin(radius);
        return function(from, to, direction, listener) {
            if (from != null) {
                from = d3_geo_circleAngle(cr, from);
                to = d3_geo_circleAngle(cr, to);
                if (direction > 0 ? from < to : from > to) from += direction * 2 * π;
            } else {
                from = radius + direction * 2 * π;
                to = radius;
            }
            var point;
            for (var step = direction * precision, t = from; direction > 0 ? t > to : t < to; t -= step) {
                listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
            }
        };
    }
    function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
    }
    d3.geo.distance = function(a, b) {
        var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
        return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
    };
    d3.geo.graticule = function() {
        var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
        function graticule() {
            return {
                type: "MultiLineString",
                coordinates: lines()
            };
        }
        function lines() {
            return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
                return Math.abs(x % DX) > ε;
            }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
                return Math.abs(y % DY) > ε;
            }).map(y));
        }
        graticule.lines = function() {
            return lines().map(function(coordinates) {
                return {
                    type: "LineString",
                    coordinates: coordinates
                };
            });
        };
        graticule.outline = function() {
            return {
                type: "Polygon",
                coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
            };
        };
        graticule.extent = function(_) {
            if (!arguments.length) return graticule.minorExtent();
            return graticule.majorExtent(_).minorExtent(_);
        };
        graticule.majorExtent = function(_) {
            if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
            X0 = +_[0][0], X1 = +_[1][0];
            Y0 = +_[0][1], Y1 = +_[1][1];
            if (X0 > X1) _ = X0, X0 = X1, X1 = _;
            if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
            return graticule.precision(precision);
        };
        graticule.minorExtent = function(_) {
            if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
            x0 = +_[0][0], x1 = +_[1][0];
            y0 = +_[0][1], y1 = +_[1][1];
            if (x0 > x1) _ = x0, x0 = x1, x1 = _;
            if (y0 > y1) _ = y0, y0 = y1, y1 = _;
            return graticule.precision(precision);
        };
        graticule.step = function(_) {
            if (!arguments.length) return graticule.minorStep();
            return graticule.majorStep(_).minorStep(_);
        };
        graticule.majorStep = function(_) {
            if (!arguments.length) return [ DX, DY ];
            DX = +_[0], DY = +_[1];
            return graticule;
        };
        graticule.minorStep = function(_) {
            if (!arguments.length) return [ dx, dy ];
            dx = +_[0], dy = +_[1];
            return graticule;
        };
        graticule.precision = function(_) {
            if (!arguments.length) return precision;
            precision = +_;
            x = d3_geo_graticuleX(y0, y1, 90);
            y = d3_geo_graticuleY(x0, x1, precision);
            X = d3_geo_graticuleX(Y0, Y1, 90);
            Y = d3_geo_graticuleY(X0, X1, precision);
            return graticule;
        };
        return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
    };
    function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - ε, dy).concat(y1);
        return function(x) {
            return y.map(function(y) {
                return [ x, y ];
            });
        };
    }
    function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - ε, dx).concat(x1);
        return function(y) {
            return x.map(function(x) {
                return [ x, y ];
            });
        };
    }
    function d3_source(d) {
        return d.source;
    }
    function d3_target(d) {
        return d.target;
    }
    d3.geo.greatArc = function() {
        var source = d3_source, source_, target = d3_target, target_;
        function greatArc() {
            return {
                type: "LineString",
                coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
            };
        }
        greatArc.distance = function() {
            return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        };
        greatArc.source = function(_) {
            if (!arguments.length) return source;
            source = _, source_ = typeof _ === "function" ? null : _;
            return greatArc;
        };
        greatArc.target = function(_) {
            if (!arguments.length) return target;
            target = _, target_ = typeof _ === "function" ? null : _;
            return greatArc;
        };
        greatArc.precision = function() {
            return arguments.length ? greatArc : 0;
        };
        return greatArc;
    };
    d3.geo.interpolate = function(source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
    };
    function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
        var interpolate = d ? function(t) {
            var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
            return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
        } : function() {
            return [ x0 * d3_degrees, y0 * d3_degrees ];
        };
        interpolate.distance = d;
        return interpolate;
    }
    d3.geo.length = function(object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
    };
    var d3_geo_lengthSum;
    var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_lengthLineStart() {
        var λ0, sinφ0, cosφ0;
        d3_geo_length.point = function(λ, φ) {
            λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
            d3_geo_length.point = nextPoint;
        };
        d3_geo_length.lineEnd = function() {
            d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        };
        function nextPoint(λ, φ) {
            var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = Math.abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
            d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
            λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
        }
    }
    function d3_geo_conic(projectAt) {
        var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
        p.parallels = function(_) {
            if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
            return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
        };
        return p;
    }
    function d3_geo_conicEqualArea(φ0, φ1) {
        var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
        function forward(λ, φ) {
            var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
            return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
        }
        forward.invert = function(x, y) {
            var ρ0_y = ρ0 - y;
            return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
        };
        return forward;
    }
    (d3.geo.conicEqualArea = function() {
        return d3_geo_conic(d3_geo_conicEqualArea);
    }).raw = d3_geo_conicEqualArea;
    d3.geo.albers = function() {
        return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
    };
    d3.geo.albersUsa = function() {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
        var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
        var point, pointStream = {
            point: function(x, y) {
                point = [ x, y ];
            }
        }, lower48Point, alaskaPoint, hawaiiPoint;
        function albersUsa(coordinates) {
            var x = coordinates[0], y = coordinates[1];
            point = null;
            (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
            return point;
        }
        albersUsa.invert = function(coordinates) {
            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
            return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function(stream) {
            var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
            return {
                point: function(x, y) {
                    lower48Stream.point(x, y);
                    alaskaStream.point(x, y);
                    hawaiiStream.point(x, y);
                },
                sphere: function() {
                    lower48Stream.sphere();
                    alaskaStream.sphere();
                    hawaiiStream.sphere();
                },
                lineStart: function() {
                    lower48Stream.lineStart();
                    alaskaStream.lineStart();
                    hawaiiStream.lineStart();
                },
                lineEnd: function() {
                    lower48Stream.lineEnd();
                    alaskaStream.lineEnd();
                    hawaiiStream.lineEnd();
                },
                polygonStart: function() {
                    lower48Stream.polygonStart();
                    alaskaStream.polygonStart();
                    hawaiiStream.polygonStart();
                },
                polygonEnd: function() {
                    lower48Stream.polygonEnd();
                    alaskaStream.polygonEnd();
                    hawaiiStream.polygonEnd();
                }
            };
        };
        albersUsa.precision = function(_) {
            if (!arguments.length) return lower48.precision();
            lower48.precision(_);
            alaska.precision(_);
            hawaii.precision(_);
            return albersUsa;
        };
        albersUsa.scale = function(_) {
            if (!arguments.length) return lower48.scale();
            lower48.scale(_);
            alaska.scale(_ * .35);
            hawaii.scale(_);
            return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function(_) {
            if (!arguments.length) return lower48.translate();
            var k = lower48.scale(), x = +_[0], y = +_[1];
            lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
            alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
            hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
            return albersUsa;
        };
        return albersUsa.scale(1070);
    };
    var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
            d3_geo_pathAreaPolygon = 0;
            d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
        },
        polygonEnd: function() {
            d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
            d3_geo_pathAreaSum += Math.abs(d3_geo_pathAreaPolygon / 2);
        }
    };
    function d3_geo_pathAreaRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathArea.point = function(x, y) {
            d3_geo_pathArea.point = nextPoint;
            x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
            d3_geo_pathAreaPolygon += y0 * x - x0 * y;
            x0 = x, y0 = y;
        }
        d3_geo_pathArea.lineEnd = function() {
            nextPoint(x00, y00);
        };
    }
    var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
    var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
    }
    function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
        var stream = {
            point: point,
            lineStart: function() {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function() {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function() {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function(_) {
                pointCircle = d3_geo_pathBufferCircle(_);
                return stream;
            },
            result: function() {
                if (buffer.length) {
                    var result = buffer.join("");
                    buffer = [];
                    return result;
                }
            }
        };
        function point(x, y) {
            buffer.push("M", x, ",", y, pointCircle);
        }
        function pointLineStart(x, y) {
            buffer.push("M", x, ",", y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            buffer.push("L", x, ",", y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            buffer.push("Z");
        }
        return stream;
    }
    function d3_geo_pathBufferCircle(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
    }
    var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function() {
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function() {
            d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
            d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
    };
    function d3_geo_pathCentroidPoint(x, y) {
        if (d3_geo_centroidDimension) return;
        d3_geo_centroidX += x;
        d3_geo_centroidY += y;
        ++d3_geo_centroidZ;
    }
    function d3_geo_pathCentroidLineStart() {
        var x0, y0;
        if (d3_geo_centroidDimension !== 1) {
            if (d3_geo_centroidDimension < 1) {
                d3_geo_centroidDimension = 1;
                d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
            } else return;
        }
        d3_geo_pathCentroid.point = function(x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            x0 = x, y0 = y;
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX += z * (x0 + x) / 2;
            d3_geo_centroidY += z * (y0 + y) / 2;
            d3_geo_centroidZ += z;
            x0 = x, y0 = y;
        }
    }
    function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
    }
    function d3_geo_pathCentroidRingStart() {
        var x00, y00, x0, y0;
        if (d3_geo_centroidDimension < 2) {
            d3_geo_centroidDimension = 2;
            d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
        }
        d3_geo_pathCentroid.point = function(x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
            var z = y0 * x - x0 * y;
            d3_geo_centroidX += z * (x0 + x);
            d3_geo_centroidY += z * (y0 + y);
            d3_geo_centroidZ += z * 3;
            x0 = x, y0 = y;
        }
        d3_geo_pathCentroid.lineEnd = function() {
            nextPoint(x00, y00);
        };
    }
    function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
            point: point,
            lineStart: function() {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function() {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function() {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function(_) {
                pointRadius = _;
                return stream;
            },
            result: d3_noop
        };
        function point(x, y) {
            context.moveTo(x, y);
            context.arc(x, y, pointRadius, 0, 2 * π);
        }
        function pointLineStart(x, y) {
            context.moveTo(x, y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            context.lineTo(x, y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            context.closePath();
        }
        return stream;
    }
    d3.geo.path = function() {
        var pointRadius = 4.5, projection, context, projectStream, contextStream;
        function path(object) {
            if (object) d3.geo.stream(object, projectStream(contextStream.pointRadius(typeof pointRadius === "function" ? +pointRadius.apply(this, arguments) : pointRadius)));
            return contextStream.result();
        }
        path.area = function(object) {
            d3_geo_pathAreaSum = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathArea));
            return d3_geo_pathAreaSum;
        };
        path.centroid = function(object) {
            d3_geo_centroidDimension = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
            return d3_geo_centroidZ ? [ d3_geo_centroidX / d3_geo_centroidZ, d3_geo_centroidY / d3_geo_centroidZ ] : undefined;
        };
        path.bounds = function(object) {
            d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
            d3.geo.stream(object, projectStream(d3_geo_pathBounds));
            return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
        };
        path.projection = function(_) {
            if (!arguments.length) return projection;
            projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
            return path;
        };
        path.context = function(_) {
            if (!arguments.length) return context;
            contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
            return path;
        };
        path.pointRadius = function(_) {
            if (!arguments.length) return pointRadius;
            pointRadius = typeof _ === "function" ? _ : +_;
            return path;
        };
        return path.projection(d3.geo.albersUsa()).context(null);
    };
    function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function(λ, φ) {
            return project([ λ * d3_degrees, φ * d3_degrees ]);
        });
        return function(stream) {
            stream = resample(stream);
            return {
                point: function(λ, φ) {
                    stream.point(λ * d3_radians, φ * d3_radians);
                },
                sphere: function() {
                    stream.sphere();
                },
                lineStart: function() {
                    stream.lineStart();
                },
                lineEnd: function() {
                    stream.lineEnd();
                },
                polygonStart: function() {
                    stream.polygonStart();
                },
                polygonEnd: function() {
                    stream.polygonEnd();
                }
            };
        };
    }
    function d3_geo_azimuthal(scale, angle) {
        function azimuthal(λ, φ) {
            var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
            return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
        }
        azimuthal.invert = function(x, y) {
            var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
            return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
        };
        return azimuthal;
    }
    var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
        return Math.sqrt(2 / (1 + cosλcosφ));
    }, function(ρ) {
        return 2 * Math.asin(ρ / 2);
    });
    (d3.geo.azimuthalEqualArea = function() {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
    }).raw = d3_geo_azimuthalEqualArea;
    var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
        var c = Math.acos(cosλcosφ);
        return c && c / Math.sin(c);
    }, d3_identity);
    (d3.geo.azimuthalEquidistant = function() {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
    }).raw = d3_geo_azimuthalEquidistant;
    function d3_geo_conicConformal(φ0, φ1) {
        var cosφ0 = Math.cos(φ0), t = function(φ) {
            return Math.tan(π / 4 + φ / 2);
        }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
        if (!n) return d3_geo_mercator;
        function forward(λ, φ) {
            var ρ = Math.abs(Math.abs(φ) - π / 2) < ε ? 0 : F / Math.pow(t(φ), n);
            return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
        }
        forward.invert = function(x, y) {
            var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
            return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - π / 2 ];
        };
        return forward;
    }
    (d3.geo.conicConformal = function() {
        return d3_geo_conic(d3_geo_conicConformal);
    }).raw = d3_geo_conicConformal;
    function d3_geo_conicEquidistant(φ0, φ1) {
        var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
        if (Math.abs(n) < ε) return d3_geo_equirectangular;
        function forward(λ, φ) {
            var ρ = G - φ;
            return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
        }
        forward.invert = function(x, y) {
            var ρ0_y = G - y;
            return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
        };
        return forward;
    }
    (d3.geo.conicEquidistant = function() {
        return d3_geo_conic(d3_geo_conicEquidistant);
    }).raw = d3_geo_conicEquidistant;
    var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / cosλcosφ;
    }, Math.atan);
    (d3.geo.gnomonic = function() {
        return d3_geo_projection(d3_geo_gnomonic);
    }).raw = d3_geo_gnomonic;
    function d3_geo_mercator(λ, φ) {
        return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
    }
    d3_geo_mercator.invert = function(x, y) {
        return [ x, 2 * Math.atan(Math.exp(y)) - π / 2 ];
    };
    function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
        m.scale = function() {
            var v = scale.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.translate = function() {
            var v = translate.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.clipExtent = function(_) {
            var v = clipExtent.apply(m, arguments);
            if (v === m) {
                if (clipAuto = _ == null) {
                    var k = π * scale(), t = translate();
                    clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
                }
            } else if (clipAuto) {
                v = null;
            }
            return v;
        };
        return m.clipExtent(null);
    }
    (d3.geo.mercator = function() {
        return d3_geo_mercatorProjection(d3_geo_mercator);
    }).raw = d3_geo_mercator;
    var d3_geo_orthographic = d3_geo_azimuthal(function() {
        return 1;
    }, Math.asin);
    (d3.geo.orthographic = function() {
        return d3_geo_projection(d3_geo_orthographic);
    }).raw = d3_geo_orthographic;
    var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / (1 + cosλcosφ);
    }, function(ρ) {
        return 2 * Math.atan(ρ);
    });
    (d3.geo.stereographic = function() {
        return d3_geo_projection(d3_geo_stereographic);
    }).raw = d3_geo_stereographic;
    function d3_geo_transverseMercator(λ, φ) {
        var B = Math.cos(φ) * Math.sin(λ);
        return [ Math.log((1 + B) / (1 - B)) / 2, Math.atan2(Math.tan(φ), Math.cos(λ)) ];
    }
    d3_geo_transverseMercator.invert = function(x, y) {
        return [ Math.atan2(d3_sinh(x), Math.cos(y)), d3_asin(Math.sin(y) / d3_cosh(x)) ];
    };
    (d3.geo.transverseMercator = function() {
        return d3_geo_mercatorProjection(d3_geo_transverseMercator);
    }).raw = d3_geo_transverseMercator;
    d3.geom = {};
    d3.svg = {};
    function d3_svg_line(projection) {
        var x = d3_svg_lineX, y = d3_svg_lineY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
        function line(data) {
            var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
            function segment() {
                segments.push("M", interpolate(projection(points), tension));
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
                } else if (points.length) {
                    segment();
                    points = [];
                }
            }
            if (points.length) segment();
            return segments.length ? segments.join("") : null;
        }
        line.x = function(_) {
            if (!arguments.length) return x;
            x = _;
            return line;
        };
        line.y = function(_) {
            if (!arguments.length) return y;
            y = _;
            return line;
        };
        line.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return line;
        };
        line.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            return line;
        };
        line.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return line;
        };
        return line;
    }
    d3.svg.line = function() {
        return d3_svg_line(d3_identity);
    };
    function d3_svg_lineX(d) {
        return d[0];
    }
    function d3_svg_lineY(d) {
        return d[1];
    }
    var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        "linear-closed": d3_svg_lineLinearClosed,
        "step-before": d3_svg_lineStepBefore,
        "step-after": d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        "basis-open": d3_svg_lineBasisOpen,
        "basis-closed": d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        "cardinal-open": d3_svg_lineCardinalOpen,
        "cardinal-closed": d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
    });
    d3_svg_lineInterpolators.forEach(function(key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
    });
    function d3_svg_lineLinear(points) {
        return points.join("L");
    }
    function d3_svg_lineLinearClosed(points) {
        return d3_svg_lineLinear(points) + "Z";
    }
    function d3_svg_lineStepBefore(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
        return path.join("");
    }
    function d3_svg_lineStepAfter(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
        return path.join("");
    }
    function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1), d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
        points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
    }
    function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
            return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
        if (quad) {
            path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
            p0 = points[1];
            pi = 2;
        }
        if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            for (var i = 2; i < tangents.length; i++, pi++) {
                p = points[pi];
                t = tangents[i];
                path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            }
        }
        if (quad) {
            var lp = points[pi];
            path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
        }
        return path;
    }
    function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
        while (++i < n) {
            p0 = p1;
            p1 = p2;
            p2 = points[i];
            tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
        }
        return tangents;
    }
    function d3_svg_lineBasis(points) {
        if (points.length < 3) return d3_svg_lineLinear(points);
        var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0 ];
        d3_svg_lineBasisBezier(path, px, py);
        while (++i < n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        i = -1;
        while (++i < 2) {
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBasisOpen(points) {
        if (points.length < 4) return d3_svg_lineLinear(points);
        var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
        while (++i < 3) {
            pi = points[i];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBasisClosed(points) {
        var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
        while (++i < 4) {
            pi = points[i % n];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
        --i;
        while (++i < m) {
            pi = points[i % n];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
            while (++i <= n) {
                p = points[i];
                t = i / n;
                p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
                p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            }
        }
        return d3_svg_lineBasis(points);
    }
    function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    }
    var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
    function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
    }
    function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
    }
    function d3_svg_lineFiniteDifferences(points) {
        var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
    }
    function d3_svg_lineMonotoneTangents(points) {
        var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
        while (++i < j) {
            d = d3_svg_lineSlope(points[i], points[i + 1]);
            if (Math.abs(d) < 1e-6) {
                m[i] = m[i + 1] = 0;
            } else {
                a = m[i] / d;
                b = m[i + 1] / d;
                s = a * a + b * b;
                if (s > 9) {
                    s = d * 3 / Math.sqrt(s);
                    m[i] = s * a;
                    m[i + 1] = s * b;
                }
            }
        }
        i = -1;
        while (++i <= j) {
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
            tangents.push([ s || 0, m[i] * s || 0 ]);
        }
        return tangents;
    }
    function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
    }
    d3.geom.hull = function(vertices) {
        var x = d3_svg_lineX, y = d3_svg_lineY;
        if (arguments.length) return hull(vertices);
        function hull(data) {
            if (data.length < 3) return [];
            var fx = d3_functor(x), fy = d3_functor(y), n = data.length, vertices, plen = n - 1, points = [], stack = [], d, i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;
            if (fx === d3_svg_lineX && y === d3_svg_lineY) vertices = data; else for (i = 0, 
            vertices = []; i < n; ++i) {
                vertices.push([ +fx.call(this, d = data[i], i), +fy.call(this, d, i) ]);
            }
            for (i = 1; i < n; ++i) {
                if (vertices[i][1] < vertices[h][1] || vertices[i][1] == vertices[h][1] && vertices[i][0] < vertices[h][0]) h = i;
            }
            for (i = 0; i < n; ++i) {
                if (i === h) continue;
                y1 = vertices[i][1] - vertices[h][1];
                x1 = vertices[i][0] - vertices[h][0];
                points.push({
                    angle: Math.atan2(y1, x1),
                    index: i
                });
            }
            points.sort(function(a, b) {
                return a.angle - b.angle;
            });
            a = points[0].angle;
            v = points[0].index;
            u = 0;
            for (i = 1; i < plen; ++i) {
                j = points[i].index;
                if (a == points[i].angle) {
                    x1 = vertices[v][0] - vertices[h][0];
                    y1 = vertices[v][1] - vertices[h][1];
                    x2 = vertices[j][0] - vertices[h][0];
                    y2 = vertices[j][1] - vertices[h][1];
                    if (x1 * x1 + y1 * y1 >= x2 * x2 + y2 * y2) {
                        points[i].index = -1;
                        continue;
                    } else {
                        points[u].index = -1;
                    }
                }
                a = points[i].angle;
                u = i;
                v = j;
            }
            stack.push(h);
            for (i = 0, j = 0; i < 2; ++j) {
                if (points[j].index > -1) {
                    stack.push(points[j].index);
                    i++;
                }
            }
            sp = stack.length;
            for (;j < plen; ++j) {
                if (points[j].index < 0) continue;
                while (!d3_geom_hullCCW(stack[sp - 2], stack[sp - 1], points[j].index, vertices)) {
                    --sp;
                }
                stack[sp++] = points[j].index;
            }
            var poly = [];
            for (i = sp - 1; i >= 0; --i) poly.push(data[stack[i]]);
            return poly;
        }
        hull.x = function(_) {
            return arguments.length ? (x = _, hull) : x;
        };
        hull.y = function(_) {
            return arguments.length ? (y = _, hull) : y;
        };
        return hull;
    };
    function d3_geom_hullCCW(i1, i2, i3, v) {
        var t, a, b, c, d, e, f;
        t = v[i1];
        a = t[0];
        b = t[1];
        t = v[i2];
        c = t[0];
        d = t[1];
        t = v[i3];
        e = t[0];
        f = t[1];
        return (f - b) * (c - a) - (d - b) * (e - a) > 0;
    }
    d3.geom.polygon = function(coordinates) {
        coordinates.area = function() {
            var i = 0, n = coordinates.length, area = coordinates[n - 1][1] * coordinates[0][0] - coordinates[n - 1][0] * coordinates[0][1];
            while (++i < n) {
                area += coordinates[i - 1][1] * coordinates[i][0] - coordinates[i - 1][0] * coordinates[i][1];
            }
            return area * .5;
        };
        coordinates.centroid = function(k) {
            var i = -1, n = coordinates.length, x = 0, y = 0, a, b = coordinates[n - 1], c;
            if (!arguments.length) k = -1 / (6 * coordinates.area());
            while (++i < n) {
                a = b;
                b = coordinates[i];
                c = a[0] * b[1] - b[0] * a[1];
                x += (a[0] + b[0]) * c;
                y += (a[1] + b[1]) * c;
            }
            return [ x * k, y * k ];
        };
        coordinates.clip = function(subject) {
            var input, i = -1, n = coordinates.length, j, m, a = coordinates[n - 1], b, c, d;
            while (++i < n) {
                input = subject.slice();
                subject.length = 0;
                b = coordinates[i];
                c = input[(m = input.length) - 1];
                j = -1;
                while (++j < m) {
                    d = input[j];
                    if (d3_geom_polygonInside(d, a, b)) {
                        if (!d3_geom_polygonInside(c, a, b)) {
                            subject.push(d3_geom_polygonIntersect(c, d, a, b));
                        }
                        subject.push(d);
                    } else if (d3_geom_polygonInside(c, a, b)) {
                        subject.push(d3_geom_polygonIntersect(c, d, a, b));
                    }
                    c = d;
                }
                a = b;
            }
            return subject;
        };
        return coordinates;
    };
    function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
    }
    function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [ x1 + ua * x21, y1 + ua * y21 ];
    }
    d3.geom.delaunay = function(vertices) {
        var edges = vertices.map(function() {
            return [];
        }), triangles = [];
        d3_geom_voronoiTessellate(vertices, function(e) {
            edges[e.region.l.index].push(vertices[e.region.r.index]);
        });
        edges.forEach(function(edge, i) {
            var v = vertices[i], cx = v[0], cy = v[1];
            edge.forEach(function(v) {
                v.angle = Math.atan2(v[0] - cx, v[1] - cy);
            });
            edge.sort(function(a, b) {
                return a.angle - b.angle;
            });
            for (var j = 0, m = edge.length - 1; j < m; j++) {
                triangles.push([ v, edge[j], edge[j + 1] ]);
            }
        });
        return triangles;
    };
    d3.geom.voronoi = function(points) {
        var size = null, x = d3_svg_lineX, y = d3_svg_lineY, clip;
        if (arguments.length) return voronoi(points);
        function voronoi(data) {
            var points, polygons = data.map(function() {
                return [];
            }), fx = d3_functor(x), fy = d3_functor(y), d, i, n = data.length, Z = 1e6;
            if (fx === d3_svg_lineX && fy === d3_svg_lineY) points = data; else for (points = [], 
            i = 0; i < n; ++i) {
                points.push([ +fx.call(this, d = data[i], i), +fy.call(this, d, i) ]);
            }
            d3_geom_voronoiTessellate(points, function(e) {
                var s1, s2, x1, x2, y1, y2;
                if (e.a === 1 && e.b >= 0) {
                    s1 = e.ep.r;
                    s2 = e.ep.l;
                } else {
                    s1 = e.ep.l;
                    s2 = e.ep.r;
                }
                if (e.a === 1) {
                    y1 = s1 ? s1.y : -Z;
                    x1 = e.c - e.b * y1;
                    y2 = s2 ? s2.y : Z;
                    x2 = e.c - e.b * y2;
                } else {
                    x1 = s1 ? s1.x : -Z;
                    y1 = e.c - e.a * x1;
                    x2 = s2 ? s2.x : Z;
                    y2 = e.c - e.a * x2;
                }
                var v1 = [ x1, y1 ], v2 = [ x2, y2 ];
                polygons[e.region.l.index].push(v1, v2);
                polygons[e.region.r.index].push(v1, v2);
            });
            polygons = polygons.map(function(polygon, i) {
                var cx = points[i][0], cy = points[i][1], angle = polygon.map(function(v) {
                    return Math.atan2(v[0] - cx, v[1] - cy);
                }), order = d3.range(polygon.length).sort(function(a, b) {
                    return angle[a] - angle[b];
                });
                return order.filter(function(d, i) {
                    return !i || angle[d] - angle[order[i - 1]] > ε;
                }).map(function(d) {
                    return polygon[d];
                });
            });
            polygons.forEach(function(polygon, i) {
                var n = polygon.length;
                if (!n) return polygon.push([ -Z, -Z ], [ -Z, Z ], [ Z, Z ], [ Z, -Z ]);
                if (n > 2) return;
                var p0 = points[i], p1 = polygon[0], p2 = polygon[1], x0 = p0[0], y0 = p0[1], x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1], dx = Math.abs(x2 - x1), dy = y2 - y1;
                if (Math.abs(dy) < ε) {
                    var y = y0 < y1 ? -Z : Z;
                    polygon.push([ -Z, y ], [ Z, y ]);
                } else if (dx < ε) {
                    var x = x0 < x1 ? -Z : Z;
                    polygon.push([ x, -Z ], [ x, Z ]);
                } else {
                    var y = (x2 - x1) * (y1 - y0) < (x1 - x0) * (y2 - y1) ? Z : -Z, z = Math.abs(dy) - dx;
                    if (Math.abs(z) < ε) {
                        polygon.push([ dy < 0 ? y : -y, y ]);
                    } else {
                        if (z > 0) y *= -1;
                        polygon.push([ -Z, y ], [ Z, y ]);
                    }
                }
            });
            if (clip) for (i = 0; i < n; ++i) clip(polygons[i]);
            for (i = 0; i < n; ++i) polygons[i].point = data[i];
            return polygons;
        }
        voronoi.x = function(_) {
            return arguments.length ? (x = _, voronoi) : x;
        };
        voronoi.y = function(_) {
            return arguments.length ? (y = _, voronoi) : y;
        };
        voronoi.size = function(_) {
            if (!arguments.length) return size;
            if (_ == null) {
                clip = null;
            } else {
                size = [ +_[0], +_[1] ];
                clip = d3.geom.polygon([ [ 0, 0 ], [ 0, size[1] ], size, [ size[0], 0 ] ]).clip;
            }
            return voronoi;
        };
        voronoi.links = function(data) {
            var points, graph = data.map(function() {
                return [];
            }), links = [], fx = d3_functor(x), fy = d3_functor(y), d, i, n = data.length;
            if (fx === d3_svg_lineX && fy === d3_svg_lineY) points = data; else for (i = 0; i < n; ++i) {
                points.push([ +fx.call(this, d = data[i], i), +fy.call(this, d, i) ]);
            }
            d3_geom_voronoiTessellate(points, function(e) {
                var l = e.region.l.index, r = e.region.r.index;
                if (graph[l][r]) return;
                graph[l][r] = graph[r][l] = true;
                links.push({
                    source: data[l],
                    target: data[r]
                });
            });
            return links;
        };
        voronoi.triangles = function(data) {
            if (x === d3_svg_lineX && y === d3_svg_lineY) return d3.geom.delaunay(data);
            var points, point, fx = d3_functor(x), fy = d3_functor(y), d, i, n;
            for (i = 0, points = [], n = data.length; i < n; ++i) {
                point = [ +fx.call(this, d = data[i], i), +fy.call(this, d, i) ];
                point.data = d;
                points.push(point);
            }
            return d3.geom.delaunay(points).map(function(triangle) {
                return triangle.map(function(point) {
                    return point.data;
                });
            });
        };
        return voronoi;
    };
    var d3_geom_voronoiOpposite = {
        l: "r",
        r: "l"
    };
    function d3_geom_voronoiTessellate(points, callback) {
        var Sites = {
            list: points.map(function(v, i) {
                return {
                    index: i,
                    x: v[0],
                    y: v[1]
                };
            }).sort(function(a, b) {
                return a.y < b.y ? -1 : a.y > b.y ? 1 : a.x < b.x ? -1 : a.x > b.x ? 1 : 0;
            }),
            bottomSite: null
        };
        var EdgeList = {
            list: [],
            leftEnd: null,
            rightEnd: null,
            init: function() {
                EdgeList.leftEnd = EdgeList.createHalfEdge(null, "l");
                EdgeList.rightEnd = EdgeList.createHalfEdge(null, "l");
                EdgeList.leftEnd.r = EdgeList.rightEnd;
                EdgeList.rightEnd.l = EdgeList.leftEnd;
                EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd);
            },
            createHalfEdge: function(edge, side) {
                return {
                    edge: edge,
                    side: side,
                    vertex: null,
                    l: null,
                    r: null
                };
            },
            insert: function(lb, he) {
                he.l = lb;
                he.r = lb.r;
                lb.r.l = he;
                lb.r = he;
            },
            leftBound: function(p) {
                var he = EdgeList.leftEnd;
                do {
                    he = he.r;
                } while (he != EdgeList.rightEnd && Geom.rightOf(he, p));
                he = he.l;
                return he;
            },
            del: function(he) {
                he.l.r = he.r;
                he.r.l = he.l;
                he.edge = null;
            },
            right: function(he) {
                return he.r;
            },
            left: function(he) {
                return he.l;
            },
            leftRegion: function(he) {
                return he.edge == null ? Sites.bottomSite : he.edge.region[he.side];
            },
            rightRegion: function(he) {
                return he.edge == null ? Sites.bottomSite : he.edge.region[d3_geom_voronoiOpposite[he.side]];
            }
        };
        var Geom = {
            bisect: function(s1, s2) {
                var newEdge = {
                    region: {
                        l: s1,
                        r: s2
                    },
                    ep: {
                        l: null,
                        r: null
                    }
                };
                var dx = s2.x - s1.x, dy = s2.y - s1.y, adx = dx > 0 ? dx : -dx, ady = dy > 0 ? dy : -dy;
                newEdge.c = s1.x * dx + s1.y * dy + (dx * dx + dy * dy) * .5;
                if (adx > ady) {
                    newEdge.a = 1;
                    newEdge.b = dy / dx;
                    newEdge.c /= dx;
                } else {
                    newEdge.b = 1;
                    newEdge.a = dx / dy;
                    newEdge.c /= dy;
                }
                return newEdge;
            },
            intersect: function(el1, el2) {
                var e1 = el1.edge, e2 = el2.edge;
                if (!e1 || !e2 || e1.region.r == e2.region.r) {
                    return null;
                }
                var d = e1.a * e2.b - e1.b * e2.a;
                if (Math.abs(d) < 1e-10) {
                    return null;
                }
                var xint = (e1.c * e2.b - e2.c * e1.b) / d, yint = (e2.c * e1.a - e1.c * e2.a) / d, e1r = e1.region.r, e2r = e2.region.r, el, e;
                if (e1r.y < e2r.y || e1r.y == e2r.y && e1r.x < e2r.x) {
                    el = el1;
                    e = e1;
                } else {
                    el = el2;
                    e = e2;
                }
                var rightOfSite = xint >= e.region.r.x;
                if (rightOfSite && el.side === "l" || !rightOfSite && el.side === "r") {
                    return null;
                }
                return {
                    x: xint,
                    y: yint
                };
            },
            rightOf: function(he, p) {
                var e = he.edge, topsite = e.region.r, rightOfSite = p.x > topsite.x;
                if (rightOfSite && he.side === "l") {
                    return 1;
                }
                if (!rightOfSite && he.side === "r") {
                    return 0;
                }
                if (e.a === 1) {
                    var dyp = p.y - topsite.y, dxp = p.x - topsite.x, fast = 0, above = 0;
                    if (!rightOfSite && e.b < 0 || rightOfSite && e.b >= 0) {
                        above = fast = dyp >= e.b * dxp;
                    } else {
                        above = p.x + p.y * e.b > e.c;
                        if (e.b < 0) {
                            above = !above;
                        }
                        if (!above) {
                            fast = 1;
                        }
                    }
                    if (!fast) {
                        var dxs = topsite.x - e.region.l.x;
                        above = e.b * (dxp * dxp - dyp * dyp) < dxs * dyp * (1 + 2 * dxp / dxs + e.b * e.b);
                        if (e.b < 0) {
                            above = !above;
                        }
                    }
                } else {
                    var yl = e.c - e.a * p.x, t1 = p.y - yl, t2 = p.x - topsite.x, t3 = yl - topsite.y;
                    above = t1 * t1 > t2 * t2 + t3 * t3;
                }
                return he.side === "l" ? above : !above;
            },
            endPoint: function(edge, side, site) {
                edge.ep[side] = site;
                if (!edge.ep[d3_geom_voronoiOpposite[side]]) return;
                callback(edge);
            },
            distance: function(s, t) {
                var dx = s.x - t.x, dy = s.y - t.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
        };
        var EventQueue = {
            list: [],
            insert: function(he, site, offset) {
                he.vertex = site;
                he.ystar = site.y + offset;
                for (var i = 0, list = EventQueue.list, l = list.length; i < l; i++) {
                    var next = list[i];
                    if (he.ystar > next.ystar || he.ystar == next.ystar && site.x > next.vertex.x) {
                        continue;
                    } else {
                        break;
                    }
                }
                list.splice(i, 0, he);
            },
            del: function(he) {
                for (var i = 0, ls = EventQueue.list, l = ls.length; i < l && ls[i] != he; ++i) {}
                ls.splice(i, 1);
            },
            empty: function() {
                return EventQueue.list.length === 0;
            },
            nextEvent: function(he) {
                for (var i = 0, ls = EventQueue.list, l = ls.length; i < l; ++i) {
                    if (ls[i] == he) return ls[i + 1];
                }
                return null;
            },
            min: function() {
                var elem = EventQueue.list[0];
                return {
                    x: elem.vertex.x,
                    y: elem.ystar
                };
            },
            extractMin: function() {
                return EventQueue.list.shift();
            }
        };
        EdgeList.init();
        Sites.bottomSite = Sites.list.shift();
        var newSite = Sites.list.shift(), newIntStar;
        var lbnd, rbnd, llbnd, rrbnd, bisector;
        var bot, top, temp, p, v;
        var e, pm;
        while (true) {
            if (!EventQueue.empty()) {
                newIntStar = EventQueue.min();
            }
            if (newSite && (EventQueue.empty() || newSite.y < newIntStar.y || newSite.y == newIntStar.y && newSite.x < newIntStar.x)) {
                lbnd = EdgeList.leftBound(newSite);
                rbnd = EdgeList.right(lbnd);
                bot = EdgeList.rightRegion(lbnd);
                e = Geom.bisect(bot, newSite);
                bisector = EdgeList.createHalfEdge(e, "l");
                EdgeList.insert(lbnd, bisector);
                p = Geom.intersect(lbnd, bisector);
                if (p) {
                    EventQueue.del(lbnd);
                    EventQueue.insert(lbnd, p, Geom.distance(p, newSite));
                }
                lbnd = bisector;
                bisector = EdgeList.createHalfEdge(e, "r");
                EdgeList.insert(lbnd, bisector);
                p = Geom.intersect(bisector, rbnd);
                if (p) {
                    EventQueue.insert(bisector, p, Geom.distance(p, newSite));
                }
                newSite = Sites.list.shift();
            } else if (!EventQueue.empty()) {
                lbnd = EventQueue.extractMin();
                llbnd = EdgeList.left(lbnd);
                rbnd = EdgeList.right(lbnd);
                rrbnd = EdgeList.right(rbnd);
                bot = EdgeList.leftRegion(lbnd);
                top = EdgeList.rightRegion(rbnd);
                v = lbnd.vertex;
                Geom.endPoint(lbnd.edge, lbnd.side, v);
                Geom.endPoint(rbnd.edge, rbnd.side, v);
                EdgeList.del(lbnd);
                EventQueue.del(rbnd);
                EdgeList.del(rbnd);
                pm = "l";
                if (bot.y > top.y) {
                    temp = bot;
                    bot = top;
                    top = temp;
                    pm = "r";
                }
                e = Geom.bisect(bot, top);
                bisector = EdgeList.createHalfEdge(e, pm);
                EdgeList.insert(llbnd, bisector);
                Geom.endPoint(e, d3_geom_voronoiOpposite[pm], v);
                p = Geom.intersect(llbnd, bisector);
                if (p) {
                    EventQueue.del(llbnd);
                    EventQueue.insert(llbnd, p, Geom.distance(p, bot));
                }
                p = Geom.intersect(bisector, rrbnd);
                if (p) {
                    EventQueue.insert(bisector, p, Geom.distance(p, bot));
                }
            } else {
                break;
            }
        }
        for (lbnd = EdgeList.right(EdgeList.leftEnd); lbnd != EdgeList.rightEnd; lbnd = EdgeList.right(lbnd)) {
            callback(lbnd.edge);
        }
    }
    d3.geom.quadtree = function(points, x1, y1, x2, y2) {
        var x = d3_svg_lineX, y = d3_svg_lineY, compat;
        if (compat = arguments.length) {
            x = d3_geom_quadtreeCompatX;
            y = d3_geom_quadtreeCompatY;
            if (compat === 3) {
                y2 = y1;
                x2 = x1;
                y1 = x1 = 0;
            }
            return quadtree(points);
        }
        function quadtree(data) {
            var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
            if (x1 != null) {
                x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
            } else {
                x2_ = y2_ = -(x1_ = y1_ = Infinity);
                xs = [], ys = [];
                n = data.length;
                if (compat) for (i = 0; i < n; ++i) {
                    d = data[i];
                    if (d.x < x1_) x1_ = d.x;
                    if (d.y < y1_) y1_ = d.y;
                    if (d.x > x2_) x2_ = d.x;
                    if (d.y > y2_) y2_ = d.y;
                    xs.push(d.x);
                    ys.push(d.y);
                } else for (i = 0; i < n; ++i) {
                    var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                    if (x_ < x1_) x1_ = x_;
                    if (y_ < y1_) y1_ = y_;
                    if (x_ > x2_) x2_ = x_;
                    if (y_ > y2_) y2_ = y_;
                    xs.push(x_);
                    ys.push(y_);
                }
            }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
            function insert(n, d, x, y, x1, y1, x2, y2) {
                if (isNaN(x) || isNaN(y)) return;
                if (n.leaf) {
                    var nx = n.x, ny = n.y;
                    if (nx != null) {
                        if (Math.abs(nx - x) + Math.abs(ny - y) < .01) {
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        } else {
                            var nPoint = n.point;
                            n.x = n.y = n.point = null;
                            insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        }
                    } else {
                        n.x = x, n.y = y, n.point = d;
                    }
                } else {
                    insertChild(n, d, x, y, x1, y1, x2, y2);
                }
            }
            function insertChild(n, d, x, y, x1, y1, x2, y2) {
                var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, right = x >= sx, bottom = y >= sy, i = (bottom << 1) + right;
                n.leaf = false;
                n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
                if (right) x1 = sx; else x2 = sx;
                if (bottom) y1 = sy; else y2 = sy;
                insert(n, d, x, y, x1, y1, x2, y2);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function(d) {
                insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
            };
            root.visit = function(f) {
                d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
            };
            i = -1;
            if (x1 == null) {
                while (++i < n) {
                    insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                }
                --i;
            } else data.forEach(root.add);
            xs = ys = data = d = null;
            return root;
        }
        quadtree.x = function(_) {
            return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function(_) {
            return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.size = function(_) {
            if (!arguments.length) return x1 == null ? null : [ x2, y2 ];
            if (_ == null) {
                x1 = y1 = x2 = y2 = null;
            } else {
                x1 = y1 = 0;
                x2 = +_[0], y2 = +_[1];
            }
            return quadtree;
        };
        return quadtree;
    };
    function d3_geom_quadtreeCompatX(d) {
        return d.x;
    }
    function d3_geom_quadtreeCompatY(d) {
        return d.y;
    }
    function d3_geom_quadtreeNode() {
        return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
        };
    }
    function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
            if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
            if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
            if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
            if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
    }
    d3.interpolateRgb = d3_interpolateRgb;
    function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
        return function(t) {
            return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
    }
    d3.transform = function(string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
        return (d3.transform = function(string) {
            if (string != null) {
                g.setAttribute("transform", string);
                var t = g.transform.baseVal.consolidate();
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
    };
    function d3_transform(m) {
        var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [ m.e, m.f ];
        this.scale = [ kx, ky ];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
    }
    d3_transform.prototype.toString = function() {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
    };
    function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    }
    function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
            a[0] /= k;
            a[1] /= k;
        }
        return k;
    }
    function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
    }
    var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
    };
    d3.interpolateNumber = d3_interpolateNumber;
    function d3_interpolateNumber(a, b) {
        b -= a = +a;
        return function(t) {
            return a + b * t;
        };
    }
    d3.interpolateTransform = d3_interpolateTransform;
    function d3_interpolateTransform(a, b) {
        var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
        if (ta[0] != tb[0] || ta[1] != tb[1]) {
            s.push("translate(", null, ",", null, ")");
            q.push({
                i: 1,
                x: d3_interpolateNumber(ta[0], tb[0])
            }, {
                i: 3,
                x: d3_interpolateNumber(ta[1], tb[1])
            });
        } else if (tb[0] || tb[1]) {
            s.push("translate(" + tb + ")");
        } else {
            s.push("");
        }
        if (ra != rb) {
            if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
            q.push({
                i: s.push(s.pop() + "rotate(", null, ")") - 2,
                x: d3_interpolateNumber(ra, rb)
            });
        } else if (rb) {
            s.push(s.pop() + "rotate(" + rb + ")");
        }
        if (wa != wb) {
            q.push({
                i: s.push(s.pop() + "skewX(", null, ")") - 2,
                x: d3_interpolateNumber(wa, wb)
            });
        } else if (wb) {
            s.push(s.pop() + "skewX(" + wb + ")");
        }
        if (ka[0] != kb[0] || ka[1] != kb[1]) {
            n = s.push(s.pop() + "scale(", null, ",", null, ")");
            q.push({
                i: n - 4,
                x: d3_interpolateNumber(ka[0], kb[0])
            }, {
                i: n - 2,
                x: d3_interpolateNumber(ka[1], kb[1])
            });
        } else if (kb[0] != 1 || kb[1] != 1) {
            s.push(s.pop() + "scale(" + kb + ")");
        }
        n = q.length;
        return function(t) {
            var i = -1, o;
            while (++i < n) s[(o = q[i]).i] = o.x(t);
            return s.join("");
        };
    }
    d3.interpolateObject = d3_interpolateObject;
    function d3_interpolateObject(a, b) {
        var i = {}, c = {}, k;
        for (k in a) {
            if (k in b) {
                i[k] = d3_interpolateByName(k)(a[k], b[k]);
            } else {
                c[k] = a[k];
            }
        }
        for (k in b) {
            if (!(k in a)) {
                c[k] = b[k];
            }
        }
        return function(t) {
            for (k in i) c[k] = i[k](t);
            return c;
        };
    }
    d3.interpolateString = d3_interpolateString;
    function d3_interpolateString(a, b) {
        var m, i, j, s0 = 0, s1 = 0, s = [], q = [], n, o;
        a = a + "", b = b + "";
        d3_interpolate_number.lastIndex = 0;
        for (i = 0; m = d3_interpolate_number.exec(b); ++i) {
            if (m.index) s.push(b.substring(s0, s1 = m.index));
            q.push({
                i: s.length,
                x: m[0]
            });
            s.push(null);
            s0 = d3_interpolate_number.lastIndex;
        }
        if (s0 < b.length) s.push(b.substring(s0));
        for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {
            o = q[i];
            if (o.x == m[0]) {
                if (o.i) {
                    if (s[o.i + 1] == null) {
                        s[o.i - 1] += o.x;
                        s.splice(o.i, 1);
                        for (j = i + 1; j < n; ++j) q[j].i--;
                    } else {
                        s[o.i - 1] += o.x + s[o.i + 1];
                        s.splice(o.i, 2);
                        for (j = i + 1; j < n; ++j) q[j].i -= 2;
                    }
                } else {
                    if (s[o.i + 1] == null) {
                        s[o.i] = o.x;
                    } else {
                        s[o.i] = o.x + s[o.i + 1];
                        s.splice(o.i + 1, 1);
                        for (j = i + 1; j < n; ++j) q[j].i--;
                    }
                }
                q.splice(i, 1);
                n--;
                i--;
            } else {
                o.x = d3_interpolateNumber(parseFloat(m[0]), parseFloat(o.x));
            }
        }
        while (i < n) {
            o = q.pop();
            if (s[o.i + 1] == null) {
                s[o.i] = o.x;
            } else {
                s[o.i] = o.x + s[o.i + 1];
                s.splice(o.i + 1, 1);
            }
            n--;
        }
        if (s.length === 1) {
            return s[0] == null ? (o = q[0].x, function(t) {
                return o(t) + "";
            }) : function() {
                return b;
            };
        }
        return function(t) {
            for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);
            return s.join("");
        };
    }
    var d3_interpolate_number = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
    d3.interpolate = d3_interpolate;
    function d3_interpolate(a, b) {
        var i = d3.interpolators.length, f;
        while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
        return f;
    }
    function d3_interpolateByName(name) {
        return name == "transform" ? d3_interpolateTransform : d3_interpolate;
    }
    d3.interpolators = [ function(a, b) {
        var t = typeof b;
        return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_Color ? d3_interpolateRgb : t === "object" ? Array.isArray(b) ? d3_interpolateArray : d3_interpolateObject : d3_interpolateNumber)(a, b);
    } ];
    d3.interpolateArray = d3_interpolateArray;
    function d3_interpolateArray(a, b) {
        var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
        for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
        for (;i < na; ++i) c[i] = a[i];
        for (;i < nb; ++i) c[i] = b[i];
        return function(t) {
            for (i = 0; i < n0; ++i) c[i] = x[i](t);
            return c;
        };
    }
    var d3_ease_default = function() {
        return d3_identity;
    };
    var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function() {
            return d3_ease_quad;
        },
        cubic: function() {
            return d3_ease_cubic;
        },
        sin: function() {
            return d3_ease_sin;
        },
        exp: function() {
            return d3_ease_exp;
        },
        circle: function() {
            return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function() {
            return d3_ease_bounce;
        }
    });
    var d3_ease_mode = d3.map({
        "in": d3_identity,
        out: d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function(f) {
            return d3_ease_reflect(d3_ease_reverse(f));
        }
    });
    d3.ease = function(name) {
        var i = name.indexOf("-"), t = i >= 0 ? name.substring(0, i) : name, m = i >= 0 ? name.substring(i + 1) : "in";
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, Array.prototype.slice.call(arguments, 1))));
    };
    function d3_ease_clamp(f) {
        return function(t) {
            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
    }
    function d3_ease_reverse(f) {
        return function(t) {
            return 1 - f(1 - t);
        };
    }
    function d3_ease_reflect(f) {
        return function(t) {
            return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
    }
    function d3_ease_quad(t) {
        return t * t;
    }
    function d3_ease_cubic(t) {
        return t * t * t;
    }
    function d3_ease_cubicInOut(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        var t2 = t * t, t3 = t2 * t;
        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
    }
    function d3_ease_poly(e) {
        return function(t) {
            return Math.pow(t, e);
        };
    }
    function d3_ease_sin(t) {
        return 1 - Math.cos(t * π / 2);
    }
    function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
    }
    function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2) p = .45;
        if (arguments.length) s = p / (2 * π) * Math.asin(1 / a); else a = 1, s = p / 4;
        return function(t) {
            return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * π / p);
        };
    }
    function d3_ease_back(s) {
        if (!s) s = 1.70158;
        return function(t) {
            return t * t * ((s + 1) * t - s);
        };
    }
    function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
    }
    d3.interpolateHcl = d3_interpolateHcl;
    function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
        if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
        return function(t) {
            return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
        };
    }
    d3.interpolateHsl = d3_interpolateHsl;
    function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
        if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
        if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
        return function(t) {
            return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
        };
    }
    d3.interpolateLab = d3_interpolateLab;
    function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
        return function(t) {
            return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
        };
    }
    d3.interpolateRound = d3_interpolateRound;
    function d3_interpolateRound(a, b) {
        b -= a;
        return function(t) {
            return Math.round(a + b * t);
        };
    }
    function d3_uninterpolateNumber(a, b) {
        b = b - (a = +a) ? 1 / (b - a) : 0;
        return function(x) {
            return (x - a) * b;
        };
    }
    function d3_uninterpolateClamp(a, b) {
        b = b - (a = +a) ? 1 / (b - a) : 0;
        return function(x) {
            return Math.max(0, Math.min(1, (x - a) * b));
        };
    }
    d3.layout = {};
    d3.layout.bundle = function() {
        return function(links) {
            var paths = [], i = -1, n = links.length;
            while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
            return paths;
        };
    };
    function d3_layout_bundlePath(link) {
        var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
        while (start !== lca) {
            start = start.parent;
            points.push(start);
        }
        var k = points.length;
        while (end !== lca) {
            points.splice(k, 0, end);
            end = end.parent;
        }
        return points;
    }
    function d3_layout_bundleAncestors(node) {
        var ancestors = [], parent = node.parent;
        while (parent != null) {
            ancestors.push(node);
            node = parent;
            parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
    }
    function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b) return a;
        var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
        while (aNode === bNode) {
            sharedNode = aNode;
            aNode = aNodes.pop();
            bNode = bNodes.pop();
        }
        return sharedNode;
    }
    d3.layout.chord = function() {
        var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
        function relayout() {
            var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
            chords = [];
            groups = [];
            k = 0, i = -1;
            while (++i < n) {
                x = 0, j = -1;
                while (++j < n) {
                    x += matrix[i][j];
                }
                groupSums.push(x);
                subgroupIndex.push(d3.range(n));
                k += x;
            }
            if (sortGroups) {
                groupIndex.sort(function(a, b) {
                    return sortGroups(groupSums[a], groupSums[b]);
                });
            }
            if (sortSubgroups) {
                subgroupIndex.forEach(function(d, i) {
                    d.sort(function(a, b) {
                        return sortSubgroups(matrix[i][a], matrix[i][b]);
                    });
                });
            }
            k = (2 * π - padding * n) / k;
            x = 0, i = -1;
            while (++i < n) {
                x0 = x, j = -1;
                while (++j < n) {
                    var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                    subgroups[di + "-" + dj] = {
                        index: di,
                        subindex: dj,
                        startAngle: a0,
                        endAngle: a1,
                        value: v
                    };
                }
                groups[di] = {
                    index: di,
                    startAngle: x0,
                    endAngle: x,
                    value: (x - x0) / k
                };
                x += padding;
            }
            i = -1;
            while (++i < n) {
                j = i - 1;
                while (++j < n) {
                    var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
                    if (source.value || target.value) {
                        chords.push(source.value < target.value ? {
                            source: target,
                            target: source
                        } : {
                            source: source,
                            target: target
                        });
                    }
                }
            }
            if (sortChords) resort();
        }
        function resort() {
            chords.sort(function(a, b) {
                return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
            });
        }
        chord.matrix = function(x) {
            if (!arguments.length) return matrix;
            n = (matrix = x) && matrix.length;
            chords = groups = null;
            return chord;
        };
        chord.padding = function(x) {
            if (!arguments.length) return padding;
            padding = x;
            chords = groups = null;
            return chord;
        };
        chord.sortGroups = function(x) {
            if (!arguments.length) return sortGroups;
            sortGroups = x;
            chords = groups = null;
            return chord;
        };
        chord.sortSubgroups = function(x) {
            if (!arguments.length) return sortSubgroups;
            sortSubgroups = x;
            chords = null;
            return chord;
        };
        chord.sortChords = function(x) {
            if (!arguments.length) return sortChords;
            sortChords = x;
            if (chords) resort();
            return chord;
        };
        chord.chords = function() {
            if (!chords) relayout();
            return chords;
        };
        chord.groups = function() {
            if (!groups) relayout();
            return groups;
        };
        return chord;
    };
    d3.layout.force = function() {
        var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, gravity = .1, theta = .8, nodes = [], links = [], distances, strengths, charges;
        function repulse(node) {
            return function(quad, x1, _, x2) {
                if (quad.point !== node) {
                    var dx = quad.cx - node.x, dy = quad.cy - node.y, dn = 1 / Math.sqrt(dx * dx + dy * dy);
                    if ((x2 - x1) * dn < theta) {
                        var k = quad.charge * dn * dn;
                        node.px -= dx * k;
                        node.py -= dy * k;
                        return true;
                    }
                    if (quad.point && isFinite(dn)) {
                        var k = quad.pointCharge * dn * dn;
                        node.px -= dx * k;
                        node.py -= dy * k;
                    }
                }
                return !quad.charge;
            };
        }
        force.tick = function() {
            if ((alpha *= .99) < .005) {
                event.end({
                    type: "end",
                    alpha: alpha = 0
                });
                return true;
            }
            var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
            for (i = 0; i < m; ++i) {
                o = links[i];
                s = o.source;
                t = o.target;
                x = t.x - s.x;
                y = t.y - s.y;
                if (l = x * x + y * y) {
                    l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
                    x *= l;
                    y *= l;
                    t.x -= x * (k = s.weight / (t.weight + s.weight));
                    t.y -= y * k;
                    s.x += x * (k = 1 - k);
                    s.y += y * k;
                }
            }
            if (k = alpha * gravity) {
                x = size[0] / 2;
                y = size[1] / 2;
                i = -1;
                if (k) while (++i < n) {
                    o = nodes[i];
                    o.x += (x - o.x) * k;
                    o.y += (y - o.y) * k;
                }
            }
            if (charge) {
                d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
                i = -1;
                while (++i < n) {
                    if (!(o = nodes[i]).fixed) {
                        q.visit(repulse(o));
                    }
                }
            }
            i = -1;
            while (++i < n) {
                o = nodes[i];
                if (o.fixed) {
                    o.x = o.px;
                    o.y = o.py;
                } else {
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }
            }
            event.tick({
                type: "tick",
                alpha: alpha
            });
        };
        force.nodes = function(x) {
            if (!arguments.length) return nodes;
            nodes = x;
            return force;
        };
        force.links = function(x) {
            if (!arguments.length) return links;
            links = x;
            return force;
        };
        force.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return force;
        };
        force.linkDistance = function(x) {
            if (!arguments.length) return linkDistance;
            linkDistance = typeof x === "function" ? x : +x;
            return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function(x) {
            if (!arguments.length) return linkStrength;
            linkStrength = typeof x === "function" ? x : +x;
            return force;
        };
        force.friction = function(x) {
            if (!arguments.length) return friction;
            friction = +x;
            return force;
        };
        force.charge = function(x) {
            if (!arguments.length) return charge;
            charge = typeof x === "function" ? x : +x;
            return force;
        };
        force.gravity = function(x) {
            if (!arguments.length) return gravity;
            gravity = +x;
            return force;
        };
        force.theta = function(x) {
            if (!arguments.length) return theta;
            theta = +x;
            return force;
        };
        force.alpha = function(x) {
            if (!arguments.length) return alpha;
            x = +x;
            if (alpha) {
                if (x > 0) alpha = x; else alpha = 0;
            } else if (x > 0) {
                event.start({
                    type: "start",
                    alpha: alpha = x
                });
                d3.timer(force.tick);
            }
            return force;
        };
        force.start = function() {
            var i, j, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
            for (i = 0; i < n; ++i) {
                (o = nodes[i]).index = i;
                o.weight = 0;
            }
            for (i = 0; i < m; ++i) {
                o = links[i];
                if (typeof o.source == "number") o.source = nodes[o.source];
                if (typeof o.target == "number") o.target = nodes[o.target];
                ++o.source.weight;
                ++o.target.weight;
            }
            for (i = 0; i < n; ++i) {
                o = nodes[i];
                if (isNaN(o.x)) o.x = position("x", w);
                if (isNaN(o.y)) o.y = position("y", h);
                if (isNaN(o.px)) o.px = o.x;
                if (isNaN(o.py)) o.py = o.y;
            }
            distances = [];
            if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
            strengths = [];
            if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
            charges = [];
            if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
            function position(dimension, size) {
                var neighbors = neighbor(i), j = -1, m = neighbors.length, x;
                while (++j < m) if (!isNaN(x = neighbors[j][dimension])) return x;
                return Math.random() * size;
            }
            function neighbor() {
                if (!neighbors) {
                    neighbors = [];
                    for (j = 0; j < n; ++j) {
                        neighbors[j] = [];
                    }
                    for (j = 0; j < m; ++j) {
                        var o = links[j];
                        neighbors[o.source.index].push(o.target);
                        neighbors[o.target.index].push(o.source);
                    }
                }
                return neighbors[i];
            }
            return force.resume();
        };
        force.resume = function() {
            return force.alpha(.1);
        };
        force.stop = function() {
            return force.alpha(0);
        };
        force.drag = function() {
            if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
            if (!arguments.length) return drag;
            this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
        };
        function dragmove(d) {
            d.px = d3.event.x, d.py = d3.event.y;
            force.resume();
        }
        return d3.rebind(force, event, "on");
    };
    function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
    }
    function d3_layout_forceDragend(d) {
        d.fixed &= ~6;
    }
    function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
    }
    function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
    }
    function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0, cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
            var nodes = quad.nodes, n = nodes.length, i = -1, c;
            while (++i < n) {
                c = nodes[i];
                if (c == null) continue;
                d3_layout_forceAccumulate(c, alpha, charges);
                quad.charge += c.charge;
                cx += c.charge * c.cx;
                cy += c.charge * c.cy;
            }
        }
        if (quad.point) {
            if (!quad.leaf) {
                quad.point.x += Math.random() - .5;
                quad.point.y += Math.random() - .5;
            }
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
    }
    var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1;
    d3.layout.hierarchy = function() {
        var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
        function recurse(node, depth, nodes) {
            var childs = children.call(hierarchy, node, depth);
            node.depth = depth;
            nodes.push(node);
            if (childs && (n = childs.length)) {
                var i = -1, n, c = node.children = [], v = 0, j = depth + 1, d;
                while (++i < n) {
                    d = recurse(childs[i], j, nodes);
                    d.parent = node;
                    c.push(d);
                    v += d.value;
                }
                if (sort) c.sort(sort);
                if (value) node.value = v;
            } else if (value) {
                node.value = +value.call(hierarchy, node, depth) || 0;
            }
            return node;
        }
        function revalue(node, depth) {
            var children = node.children, v = 0;
            if (children && (n = children.length)) {
                var i = -1, n, j = depth + 1;
                while (++i < n) v += revalue(children[i], j);
            } else if (value) {
                v = +value.call(hierarchy, node, depth) || 0;
            }
            if (value) node.value = v;
            return v;
        }
        function hierarchy(d) {
            var nodes = [];
            recurse(d, 0, nodes);
            return nodes;
        }
        hierarchy.sort = function(x) {
            if (!arguments.length) return sort;
            sort = x;
            return hierarchy;
        };
        hierarchy.children = function(x) {
            if (!arguments.length) return children;
            children = x;
            return hierarchy;
        };
        hierarchy.value = function(x) {
            if (!arguments.length) return value;
            value = x;
            return hierarchy;
        };
        hierarchy.revalue = function(root) {
            revalue(root, 0);
            return root;
        };
        return hierarchy;
    };
    function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
    }
    function d3_layout_hierarchyChildren(d) {
        return d.children;
    }
    function d3_layout_hierarchyValue(d) {
        return d.value;
    }
    function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
    }
    function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function(parent) {
            return (parent.children || []).map(function(child) {
                return {
                    source: parent,
                    target: child
                };
            });
        }));
    }
    d3.layout.partition = function() {
        var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
        function position(node, x, dx, dy) {
            var children = node.children;
            node.x = x;
            node.y = node.depth * dy;
            node.dx = dx;
            node.dy = dy;
            if (children && (n = children.length)) {
                var i = -1, n, c, d;
                dx = node.value ? dx / node.value : 0;
                while (++i < n) {
                    position(c = children[i], x, d = c.value * dx, dy);
                    x += d;
                }
            }
        }
        function depth(node) {
            var children = node.children, d = 0;
            if (children && (n = children.length)) {
                var i = -1, n;
                while (++i < n) d = Math.max(d, depth(children[i]));
            }
            return 1 + d;
        }
        function partition(d, i) {
            var nodes = hierarchy.call(this, d, i);
            position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
            return nodes;
        }
        partition.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return partition;
        };
        return d3_layout_hierarchyRebind(partition, hierarchy);
    };
    d3.layout.pie = function() {
        var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = 2 * π;
        function pie(data) {
            var values = data.map(function(d, i) {
                return +value.call(pie, d, i);
            });
            var a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle);
            var k = ((typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a) / d3.sum(values);
            var index = d3.range(data.length);
            if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
                return values[j] - values[i];
            } : function(i, j) {
                return sort(data[i], data[j]);
            });
            var arcs = [];
            index.forEach(function(i) {
                var d;
                arcs[i] = {
                    data: data[i],
                    value: d = values[i],
                    startAngle: a,
                    endAngle: a += d * k
                };
            });
            return arcs;
        }
        pie.value = function(x) {
            if (!arguments.length) return value;
            value = x;
            return pie;
        };
        pie.sort = function(x) {
            if (!arguments.length) return sort;
            sort = x;
            return pie;
        };
        pie.startAngle = function(x) {
            if (!arguments.length) return startAngle;
            startAngle = x;
            return pie;
        };
        pie.endAngle = function(x) {
            if (!arguments.length) return endAngle;
            endAngle = x;
            return pie;
        };
        return pie;
    };
    var d3_layout_pieSortByValue = {};
    d3.layout.stack = function() {
        var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
        function stack(data, index) {
            var series = data.map(function(d, i) {
                return values.call(stack, d, i);
            });
            var points = series.map(function(d) {
                return d.map(function(v, i) {
                    return [ x.call(stack, v, i), y.call(stack, v, i) ];
                });
            });
            var orders = order.call(stack, points, index);
            series = d3.permute(series, orders);
            points = d3.permute(points, orders);
            var offsets = offset.call(stack, points, index);
            var n = series.length, m = series[0].length, i, j, o;
            for (j = 0; j < m; ++j) {
                out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
                for (i = 1; i < n; ++i) {
                    out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
                }
            }
            return data;
        }
        stack.values = function(x) {
            if (!arguments.length) return values;
            values = x;
            return stack;
        };
        stack.order = function(x) {
            if (!arguments.length) return order;
            order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
            return stack;
        };
        stack.offset = function(x) {
            if (!arguments.length) return offset;
            offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
            return stack;
        };
        stack.x = function(z) {
            if (!arguments.length) return x;
            x = z;
            return stack;
        };
        stack.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            return stack;
        };
        stack.out = function(z) {
            if (!arguments.length) return out;
            out = z;
            return stack;
        };
        return stack;
    };
    function d3_layout_stackX(d) {
        return d.x;
    }
    function d3_layout_stackY(d) {
        return d.y;
    }
    function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
    }
    var d3_layout_stackOrders = d3.map({
        "inside-out": function(data) {
            var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
                return max[a] - max[b];
            }), top = 0, bottom = 0, tops = [], bottoms = [];
            for (i = 0; i < n; ++i) {
                j = index[i];
                if (top < bottom) {
                    top += sums[j];
                    tops.push(j);
                } else {
                    bottom += sums[j];
                    bottoms.push(j);
                }
            }
            return bottoms.reverse().concat(tops);
        },
        reverse: function(data) {
            return d3.range(data.length).reverse();
        },
        "default": d3_layout_stackOrderDefault
    });
    var d3_layout_stackOffsets = d3.map({
        silhouette: function(data) {
            var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
                if (o > max) max = o;
                sums.push(o);
            }
            for (j = 0; j < m; ++j) {
                y0[j] = (max - sums[j]) / 2;
            }
            return y0;
        },
        wiggle: function(data) {
            var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
            y0[0] = o = o0 = 0;
            for (j = 1; j < m; ++j) {
                for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
                for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
                    for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                        s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                    }
                    s2 += s3 * data[i][j][1];
                }
                y0[j] = o -= s1 ? s2 / s1 * dx : 0;
                if (o < o0) o0 = o;
            }
            for (j = 0; j < m; ++j) y0[j] -= o0;
            return y0;
        },
        expand: function(data) {
            var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
                if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
            }
            for (j = 0; j < m; ++j) y0[j] = 0;
            return y0;
        },
        zero: d3_layout_stackOffsetZero
    });
    function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
    }
    function d3_layout_stackOffsetZero(data) {
        var j = -1, m = data[0].length, y0 = [];
        while (++j < m) y0[j] = 0;
        return y0;
    }
    function d3_layout_stackMaxIndex(array) {
        var i = 1, j = 0, v = array[0][1], k, n = array.length;
        for (;i < n; ++i) {
            if ((k = array[i][1]) > v) {
                j = i;
                v = k;
            }
        }
        return j;
    }
    function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
    }
    function d3_layout_stackSum(p, d) {
        return p + d[1];
    }
    d3.layout.histogram = function() {
        var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
            var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
            while (++i < m) {
                bin = bins[i] = [];
                bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
                bin.y = 0;
            }
            if (m > 0) {
                i = -1;
                while (++i < n) {
                    x = values[i];
                    if (x >= range[0] && x <= range[1]) {
                        bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                        bin.y += k;
                        bin.push(data[i]);
                    }
                }
            }
            return bins;
        }
        histogram.value = function(x) {
            if (!arguments.length) return valuer;
            valuer = x;
            return histogram;
        };
        histogram.range = function(x) {
            if (!arguments.length) return ranger;
            ranger = d3_functor(x);
            return histogram;
        };
        histogram.bins = function(x) {
            if (!arguments.length) return binner;
            binner = typeof x === "number" ? function(range) {
                return d3_layout_histogramBinFixed(range, x);
            } : d3_functor(x);
            return histogram;
        };
        histogram.frequency = function(x) {
            if (!arguments.length) return frequency;
            frequency = !!x;
            return histogram;
        };
        return histogram;
    };
    function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
    }
    function d3_layout_histogramBinFixed(range, n) {
        var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
        while (++x <= n) f[x] = m * x + b;
        return f;
    }
    function d3_layout_histogramRange(values) {
        return [ d3.min(values), d3.max(values) ];
    }
    d3.layout.tree = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ];
        function tree(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0];
            function firstWalk(node, previousSibling) {
                var children = node.children, layout = node._tree;
                if (children && (n = children.length)) {
                    var n, firstChild = children[0], previousChild, ancestor = firstChild, child, i = -1;
                    while (++i < n) {
                        child = children[i];
                        firstWalk(child, previousChild);
                        ancestor = apportion(child, previousChild, ancestor);
                        previousChild = child;
                    }
                    d3_layout_treeShift(node);
                    var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);
                    if (previousSibling) {
                        layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
                        layout.mod = layout.prelim - midpoint;
                    } else {
                        layout.prelim = midpoint;
                    }
                } else {
                    if (previousSibling) {
                        layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
                    }
                }
            }
            function secondWalk(node, x) {
                node.x = node._tree.prelim + x;
                var children = node.children;
                if (children && (n = children.length)) {
                    var i = -1, n;
                    x += node._tree.mod;
                    while (++i < n) {
                        secondWalk(children[i], x);
                    }
                }
            }
            function apportion(node, previousSibling, ancestor) {
                if (previousSibling) {
                    var vip = node, vop = node, vim = previousSibling, vom = node.parent.children[0], sip = vip._tree.mod, sop = vop._tree.mod, sim = vim._tree.mod, som = vom._tree.mod, shift;
                    while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                        vom = d3_layout_treeLeft(vom);
                        vop = d3_layout_treeRight(vop);
                        vop._tree.ancestor = node;
                        shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);
                        if (shift > 0) {
                            d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);
                            sip += shift;
                            sop += shift;
                        }
                        sim += vim._tree.mod;
                        sip += vip._tree.mod;
                        som += vom._tree.mod;
                        sop += vop._tree.mod;
                    }
                    if (vim && !d3_layout_treeRight(vop)) {
                        vop._tree.thread = vim;
                        vop._tree.mod += sim - sop;
                    }
                    if (vip && !d3_layout_treeLeft(vom)) {
                        vom._tree.thread = vip;
                        vom._tree.mod += sip - som;
                        ancestor = node;
                    }
                }
                return ancestor;
            }
            d3_layout_treeVisitAfter(root, function(node, previousSibling) {
                node._tree = {
                    ancestor: node,
                    prelim: 0,
                    mod: 0,
                    change: 0,
                    shift: 0,
                    number: previousSibling ? previousSibling._tree.number + 1 : 0
                };
            });
            firstWalk(root);
            secondWalk(root, -root._tree.prelim);
            var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost), right = d3_layout_treeSearch(root, d3_layout_treeRightmost), deep = d3_layout_treeSearch(root, d3_layout_treeDeepest), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2, y1 = deep.depth || 1;
            d3_layout_treeVisitAfter(root, function(node) {
                node.x = (node.x - x0) / (x1 - x0) * size[0];
                node.y = node.depth / y1 * size[1];
                delete node._tree;
            });
            return nodes;
        }
        tree.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return tree;
        };
        tree.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
    };
    function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
    }
    function d3_layout_treeLeft(node) {
        var children = node.children;
        return children && children.length ? children[0] : node._tree.thread;
    }
    function d3_layout_treeRight(node) {
        var children = node.children, n;
        return children && (n = children.length) ? children[n - 1] : node._tree.thread;
    }
    function d3_layout_treeSearch(node, compare) {
        var children = node.children;
        if (children && (n = children.length)) {
            var child, n, i = -1;
            while (++i < n) {
                if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {
                    node = child;
                }
            }
        }
        return node;
    }
    function d3_layout_treeRightmost(a, b) {
        return a.x - b.x;
    }
    function d3_layout_treeLeftmost(a, b) {
        return b.x - a.x;
    }
    function d3_layout_treeDeepest(a, b) {
        return a.depth - b.depth;
    }
    function d3_layout_treeVisitAfter(node, callback) {
        function visit(node, previousSibling) {
            var children = node.children;
            if (children && (n = children.length)) {
                var child, previousChild = null, i = -1, n;
                while (++i < n) {
                    child = children[i];
                    visit(child, previousChild);
                    previousChild = child;
                }
            }
            callback(node, previousSibling);
        }
        visit(node, null);
    }
    function d3_layout_treeShift(node) {
        var shift = 0, change = 0, children = node.children, i = children.length, child;
        while (--i >= 0) {
            child = children[i]._tree;
            child.prelim += shift;
            child.mod += shift;
            shift += child.shift + (change += child.change);
        }
    }
    function d3_layout_treeMove(ancestor, node, shift) {
        ancestor = ancestor._tree;
        node = node._tree;
        var change = shift / (node.number - ancestor.number);
        ancestor.change += change;
        node.change -= change;
        node.shift += shift;
        node.prelim += shift;
        node.mod += shift;
    }
    function d3_layout_treeAncestor(vim, node, ancestor) {
        return vim._tree.ancestor.parent == node.parent ? vim._tree.ancestor : ancestor;
    }
    d3.layout.pack = function() {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ];
        function pack(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0];
            root.x = 0;
            root.y = 0;
            d3_layout_treeVisitAfter(root, function(d) {
                d.r = Math.sqrt(d.value);
            });
            d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
            var w = size[0], h = size[1], k = Math.max(2 * root.r / w, 2 * root.r / h);
            if (padding > 0) {
                var dr = padding * k / 2;
                d3_layout_treeVisitAfter(root, function(d) {
                    d.r += dr;
                });
                d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
                d3_layout_treeVisitAfter(root, function(d) {
                    d.r -= dr;
                });
                k = Math.max(2 * root.r / w, 2 * root.r / h);
            }
            d3_layout_packTransform(root, w / 2, h / 2, 1 / k);
            return nodes;
        }
        pack.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return pack;
        };
        pack.padding = function(_) {
            if (!arguments.length) return padding;
            padding = +_;
            return pack;
        };
        return d3_layout_hierarchyRebind(pack, hierarchy);
    };
    function d3_layout_packSort(a, b) {
        return a.value - b.value;
    }
    function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
    }
    function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
    }
    function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
        return dr * dr - dx * dx - dy * dy > .001;
    }
    function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length)) return;
        var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
        function bound(node) {
            xMin = Math.min(node.x - node.r, xMin);
            xMax = Math.max(node.x + node.r, xMax);
            yMin = Math.min(node.y - node.r, yMin);
            yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
            b = nodes[1];
            b.x = b.r;
            b.y = 0;
            bound(b);
            if (n > 2) {
                c = nodes[2];
                d3_layout_packPlace(a, b, c);
                bound(c);
                d3_layout_packInsert(a, c);
                a._pack_prev = c;
                d3_layout_packInsert(c, b);
                b = a._pack_next;
                for (i = 3; i < n; i++) {
                    d3_layout_packPlace(a, b, c = nodes[i]);
                    var isect = 0, s1 = 1, s2 = 1;
                    for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                        if (d3_layout_packIntersects(j, c)) {
                            isect = 1;
                            break;
                        }
                    }
                    if (isect == 1) {
                        for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                            if (d3_layout_packIntersects(k, c)) {
                                break;
                            }
                        }
                    }
                    if (isect) {
                        if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
                        i--;
                    } else {
                        d3_layout_packInsert(a, c);
                        b = c;
                        bound(c);
                    }
                }
            }
        }
        var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
        for (i = 0; i < n; i++) {
            c = nodes[i];
            c.x -= cx;
            c.y -= cy;
            cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink);
    }
    function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
    }
    function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
    }
    function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
            var i = -1, n = children.length;
            while (++i < n) d3_layout_packTransform(children[i], x, y, k);
        }
    }
    function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
        if (db && (dx || dy)) {
            var da = b.r + c.r, dc = dx * dx + dy * dy;
            da *= da;
            db *= db;
            var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = a.x + x * dx + y * dy;
            c.y = a.y + x * dy - y * dx;
        } else {
            c.x = a.x + db;
            c.y = a.y;
        }
    }
    d3.layout.cluster = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ];
        function cluster(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
            d3_layout_treeVisitAfter(root, function(node) {
                var children = node.children;
                if (children && children.length) {
                    node.x = d3_layout_clusterX(children);
                    node.y = d3_layout_clusterY(children);
                } else {
                    node.x = previousNode ? x += separation(node, previousNode) : 0;
                    node.y = 0;
                    previousNode = node;
                }
            });
            var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
            d3_layout_treeVisitAfter(root, function(node) {
                node.x = (node.x - x0) / (x1 - x0) * size[0];
                node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
            });
            return nodes;
        }
        cluster.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return cluster;
        };
        cluster.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return cluster;
        };
        return d3_layout_hierarchyRebind(cluster, hierarchy);
    };
    function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function(child) {
            return child.y;
        });
    }
    function d3_layout_clusterX(children) {
        return children.reduce(function(x, child) {
            return x + child.x;
        }, 0) / children.length;
    }
    function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
    }
    function d3_layout_clusterRight(node) {
        var children = node.children, n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
    }
    d3.layout.treemap = function() {
        var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
        function scale(children, k) {
            var i = -1, n = children.length, child, area;
            while (++i < n) {
                area = (child = children[i]).value * (k < 0 ? 0 : k);
                child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
        }
        function squarify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while ((n = remaining.length) > 0) {
                    row.push(child = remaining[n - 1]);
                    row.area += child.area;
                    if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                        remaining.pop();
                        best = score;
                    } else {
                        row.area -= row.pop().area;
                        position(row, u, rect, false);
                        u = Math.min(rect.dx, rect.dy);
                        row.length = row.area = 0;
                        best = Infinity;
                    }
                }
                if (row.length) {
                    position(row, u, rect, true);
                    row.length = row.area = 0;
                }
                children.forEach(squarify);
            }
        }
        function stickify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), remaining = children.slice(), child, row = [];
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while (child = remaining.pop()) {
                    row.push(child);
                    row.area += child.area;
                    if (child.z != null) {
                        position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                        row.length = row.area = 0;
                    }
                }
                children.forEach(stickify);
            }
        }
        function worst(row, u) {
            var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
            while (++i < n) {
                if (!(r = row[i].area)) continue;
                if (r < rmin) rmin = r;
                if (r > rmax) rmax = r;
            }
            s *= s;
            u *= u;
            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
            var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
            if (u == rect.dx) {
                if (flush || v > rect.dy) v = rect.dy;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dy = v;
                    x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                }
                o.z = true;
                o.dx += rect.x + rect.dx - x;
                rect.y += v;
                rect.dy -= v;
            } else {
                if (flush || v > rect.dx) v = rect.dx;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dx = v;
                    y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                }
                o.z = false;
                o.dy += rect.y + rect.dy - y;
                rect.x += v;
                rect.dx -= v;
            }
        }
        function treemap(d) {
            var nodes = stickies || hierarchy(d), root = nodes[0];
            root.x = 0;
            root.y = 0;
            root.dx = size[0];
            root.dy = size[1];
            if (stickies) hierarchy.revalue(root);
            scale([ root ], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky) stickies = nodes;
            return nodes;
        }
        treemap.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return treemap;
        };
        treemap.padding = function(x) {
            if (!arguments.length) return padding;
            function padFunction(node) {
                var p = x.call(treemap, node, node.depth);
                return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
            }
            function padConstant(node) {
                return d3_layout_treemapPad(node, x);
            }
            var type;
            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
            padConstant) : padConstant;
            return treemap;
        };
        treemap.round = function(x) {
            if (!arguments.length) return round != Number;
            round = x ? Math.round : Number;
            return treemap;
        };
        treemap.sticky = function(x) {
            if (!arguments.length) return sticky;
            sticky = x;
            stickies = null;
            return treemap;
        };
        treemap.ratio = function(x) {
            if (!arguments.length) return ratio;
            ratio = x;
            return treemap;
        };
        treemap.mode = function(x) {
            if (!arguments.length) return mode;
            mode = x + "";
            return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
    };
    function d3_layout_treemapPadNull(node) {
        return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
        };
    }
    function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
            x += dx / 2;
            dx = 0;
        }
        if (dy < 0) {
            y += dy / 2;
            dy = 0;
        }
        return {
            x: x,
            y: y,
            dx: dx,
            dy: dy
        };
    }
    d3.random = {
        normal: function(µ, σ) {
            var n = arguments.length;
            if (n < 2) σ = 1;
            if (n < 1) µ = 0;
            return function() {
                var x, y, r;
                do {
                    x = Math.random() * 2 - 1;
                    y = Math.random() * 2 - 1;
                    r = x * x + y * y;
                } while (!r || r > 1);
                return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
            };
        },
        logNormal: function() {
            var random = d3.random.normal.apply(d3, arguments);
            return function() {
                return Math.exp(random());
            };
        },
        irwinHall: function(m) {
            return function() {
                for (var s = 0, j = 0; j < m; j++) s += Math.random();
                return s / m;
            };
        }
    };
    d3.scale = {};
    function d3_scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return start < stop ? [ start, stop ] : [ stop, start ];
    }
    function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
    }
    function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
        return function(x) {
            return i(u(x));
        };
    }
    function d3_scale_nice(domain, nice) {
        var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
        if (x1 < x0) {
            dx = i0, i0 = i1, i1 = dx;
            dx = x0, x0 = x1, x1 = dx;
        }
        if (nice = nice(x1 - x0)) {
            domain[i0] = nice.floor(x0);
            domain[i1] = nice.ceil(x1);
        }
        return domain;
    }
    function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
        }
        while (++j <= k) {
            u.push(uninterpolate(domain[j - 1], domain[j]));
            i.push(interpolate(range[j - 1], range[j]));
        }
        return function(x) {
            var j = d3.bisect(domain, x, 1, k) - 1;
            return i[j](u[j](x));
        };
    }
    d3.scale.linear = function() {
        return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
    };
    function d3_scale_linear(domain, range, interpolate, clamp) {
        var output, input;
        function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
            output = linear(domain, range, uninterpolate, interpolate);
            input = linear(range, domain, uninterpolate, d3_interpolate);
            return scale;
        }
        function scale(x) {
            return output(x);
        }
        scale.invert = function(y) {
            return input(y);
        };
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(Number);
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
        };
        scale.rangeRound = function(x) {
            return scale.range(x).interpolate(d3_interpolateRound);
        };
        scale.clamp = function(x) {
            if (!arguments.length) return clamp;
            clamp = x;
            return rescale();
        };
        scale.interpolate = function(x) {
            if (!arguments.length) return interpolate;
            interpolate = x;
            return rescale();
        };
        scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function() {
            d3_scale_nice(domain, d3_scale_linearNice);
            return rescale();
        };
        scale.copy = function() {
            return d3_scale_linear(domain, range, interpolate, clamp);
        };
        return rescale();
    }
    function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
    }
    function d3_scale_linearNice(dx) {
        dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);
        return dx && {
            floor: function(x) {
                return Math.floor(x / dx) * dx;
            },
            ceil: function(x) {
                return Math.ceil(x / dx) * dx;
            }
        };
    }
    function d3_scale_linearTickRange(domain, m) {
        var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
        if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * .5;
        extent[2] = step;
        return extent;
    }
    function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
    }
    function d3_scale_linearTickFormat(domain, m, format) {
        var precision = -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01);
        return d3.format(format ? format.replace(d3_format_re, function(a, b, c, d, e, f, g, h, i, j) {
            return [ b, c, d, e, f, g, h, i || "." + (precision - (j === "%") * 2), j ].join("");
        }) : ",." + precision + "f");
    }
    d3.scale.log = function() {
        return d3_scale_log(d3.scale.linear().domain([ 0, Math.LN10 ]), 10, d3_scale_logp, d3_scale_powp, [ 1, 10 ]);
    };
    function d3_scale_log(linear, base, log, pow, domain) {
        function scale(x) {
            return linear(log(x));
        }
        scale.invert = function(x) {
            return pow(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            if (x[0] < 0) log = d3_scale_logn, pow = d3_scale_pown; else log = d3_scale_logp, 
            pow = d3_scale_powp;
            linear.domain((domain = x.map(Number)).map(log));
            return scale;
        };
        scale.base = function(_) {
            if (!arguments.length) return base;
            base = +_;
            return scale;
        };
        scale.nice = function() {
            linear.domain(d3_scale_nice(domain, nice).map(log));
            return scale;
        };
        scale.ticks = function() {
            var extent = d3_scaleExtent(linear.domain()), ticks = [];
            if (extent.every(isFinite)) {
                var b = Math.log(base), i = Math.floor(extent[0] / b), j = Math.ceil(extent[1] / b), u = pow(extent[0]), v = pow(extent[1]), n = base % 1 ? 2 : base;
                if (log === d3_scale_logn) {
                    ticks.push(-Math.pow(base, -i));
                    for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(-Math.pow(base, -i) * k);
                } else {
                    for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(Math.pow(base, i) * k);
                    ticks.push(Math.pow(base, i));
                }
                for (i = 0; ticks[i] < u; i++) {}
                for (j = ticks.length; ticks[j - 1] > v; j--) {}
                ticks = ticks.slice(i, j);
            }
            return ticks;
        };
        scale.tickFormat = function(n, format) {
            if (arguments.length < 2) format = d3_scale_logFormat;
            if (!arguments.length) return format;
            var b = Math.log(base), k = Math.max(.1, n / scale.ticks().length), f = log === d3_scale_logn ? (e = -1e-12, 
            Math.floor) : (e = 1e-12, Math.ceil), e;
            return function(d) {
                return d / pow(b * f(log(d) / b + e)) <= k ? format(d) : "";
            };
        };
        scale.copy = function() {
            return d3_scale_log(linear.copy(), base, log, pow, domain);
        };
        function nice() {
            return log === d3_scale_logp ? {
                floor: floor,
                ceil: ceil
            } : {
                floor: function(x) {
                    return -ceil(-x);
                },
                ceil: function(x) {
                    return -floor(-x);
                }
            };
        }
        function floor(x) {
            return Math.pow(base, Math.floor(Math.log(x) / Math.log(base)));
        }
        function ceil(x) {
            return Math.pow(base, Math.ceil(Math.log(x) / Math.log(base)));
        }
        return d3_scale_linearRebind(scale, linear);
    }
    var d3_scale_logFormat = d3.format(".0e");
    function d3_scale_logp(x) {
        return Math.log(x < 0 ? 0 : x);
    }
    function d3_scale_powp(x) {
        return Math.exp(x);
    }
    function d3_scale_logn(x) {
        return -Math.log(x > 0 ? 0 : -x);
    }
    function d3_scale_pown(x) {
        return -Math.exp(-x);
    }
    d3.scale.pow = function() {
        return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
    };
    function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
            return linear(powp(x));
        }
        scale.invert = function(x) {
            return powb(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            linear.domain((domain = x.map(Number)).map(powp));
            return scale;
        };
        scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function() {
            return scale.domain(d3_scale_nice(domain, d3_scale_linearNice));
        };
        scale.exponent = function(x) {
            if (!arguments.length) return exponent;
            powp = d3_scale_powPow(exponent = x);
            powb = d3_scale_powPow(1 / exponent);
            linear.domain(domain.map(powp));
            return scale;
        };
        scale.copy = function() {
            return d3_scale_pow(linear.copy(), exponent, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_scale_powPow(e) {
        return function(x) {
            return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        };
    }
    d3.scale.sqrt = function() {
        return d3.scale.pow().exponent(.5);
    };
    d3.scale.ordinal = function() {
        return d3_scale_ordinal([], {
            t: "range",
            a: [ [] ]
        });
    };
    function d3_scale_ordinal(domain, ranger) {
        var index, range, rangeBand;
        function scale(x) {
            return range[((index.get(x) || index.set(x, domain.push(x))) - 1) % range.length];
        }
        function steps(start, step) {
            return d3.range(domain.length).map(function(i) {
                return start + step * i;
            });
        }
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = [];
            index = new d3_Map();
            var i = -1, n = x.length, xi;
            while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
            return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            rangeBand = 0;
            ranger = {
                t: "range",
                a: arguments
            };
            return scale;
        };
        scale.rangePoints = function(x, padding) {
            if (arguments.length < 2) padding = 0;
            var start = x[0], stop = x[1], step = (stop - start) / (Math.max(1, domain.length - 1) + padding);
            range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
                t: "rangePoints",
                a: arguments
            };
            return scale;
        };
        scale.rangeBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            range = steps(start + step * outerPadding, step);
            if (reverse) range.reverse();
            rangeBand = step * (1 - padding);
            ranger = {
                t: "rangeBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding)), error = stop - start - (domain.length - padding) * step;
            range = steps(start + Math.round(error / 2), step);
            if (reverse) range.reverse();
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
                t: "rangeRoundBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeBand = function() {
            return rangeBand;
        };
        scale.rangeExtent = function() {
            return d3_scaleExtent(ranger.a[0]);
        };
        scale.copy = function() {
            return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
    }
    d3.scale.category10 = function() {
        return d3.scale.ordinal().range(d3_category10);
    };
    d3.scale.category20 = function() {
        return d3.scale.ordinal().range(d3_category20);
    };
    d3.scale.category20b = function() {
        return d3.scale.ordinal().range(d3_category20b);
    };
    d3.scale.category20c = function() {
        return d3.scale.ordinal().range(d3_category20c);
    };
    var d3_category10 = [ "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf" ];
    var d3_category20 = [ "#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5" ];
    var d3_category20b = [ "#393b79", "#5254a3", "#6b6ecf", "#9c9ede", "#637939", "#8ca252", "#b5cf6b", "#cedb9c", "#8c6d31", "#bd9e39", "#e7ba52", "#e7cb94", "#843c39", "#ad494a", "#d6616b", "#e7969c", "#7b4173", "#a55194", "#ce6dbd", "#de9ed6" ];
    var d3_category20c = [ "#3182bd", "#6baed6", "#9ecae1", "#c6dbef", "#e6550d", "#fd8d3c", "#fdae6b", "#fdd0a2", "#31a354", "#74c476", "#a1d99b", "#c7e9c0", "#756bb1", "#9e9ac8", "#bcbddc", "#dadaeb", "#636363", "#969696", "#bdbdbd", "#d9d9d9" ];
    d3.scale.quantile = function() {
        return d3_scale_quantile([], []);
    };
    function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
            var k = 0, q = range.length;
            thresholds = [];
            while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
            return scale;
        }
        function scale(x) {
            if (isNaN(x = +x)) return NaN;
            return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.filter(function(d) {
                return !isNaN(d);
            }).sort(d3.ascending);
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
        };
        scale.quantiles = function() {
            return thresholds;
        };
        scale.copy = function() {
            return d3_scale_quantile(domain, range);
        };
        return rescale();
    }
    d3.scale.quantize = function() {
        return d3_scale_quantize(0, 1, [ 0, 1 ]);
    };
    function d3_scale_quantize(x0, x1, range) {
        var kx, i;
        function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
            kx = range.length / (x1 - x0);
            i = range.length - 1;
            return scale;
        }
        scale.domain = function(x) {
            if (!arguments.length) return [ x0, x1 ];
            x0 = +x[0];
            x1 = +x[x.length - 1];
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
        };
        scale.copy = function() {
            return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
    }
    d3.scale.threshold = function() {
        return d3_scale_threshold([ .5 ], [ 0, 1 ]);
    };
    function d3_scale_threshold(domain, range) {
        function scale(x) {
            return range[d3.bisect(domain, x)];
        }
        scale.domain = function(_) {
            if (!arguments.length) return domain;
            domain = _;
            return scale;
        };
        scale.range = function(_) {
            if (!arguments.length) return range;
            range = _;
            return scale;
        };
        scale.copy = function() {
            return d3_scale_threshold(domain, range);
        };
        return scale;
    }
    d3.scale.identity = function() {
        return d3_scale_identity([ 0, 1 ]);
    };
    function d3_scale_identity(domain) {
        function identity(x) {
            return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(identity);
            return identity;
        };
        identity.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        };
        identity.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        identity.copy = function() {
            return d3_scale_identity(domain);
        };
        return identity;
    }
    d3.svg.arc = function() {
        var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
        function arc() {
            var r0 = innerRadius.apply(this, arguments), r1 = outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset, a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset, da = (a1 < a0 && (da = a0, 
            a0 = a1, a1 = da), a1 - a0), df = da < π ? "0" : "1", c0 = Math.cos(a0), s0 = Math.sin(a0), c1 = Math.cos(a1), s1 = Math.sin(a1);
            return da >= d3_svg_arcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" + "Z";
        }
        arc.innerRadius = function(v) {
            if (!arguments.length) return innerRadius;
            innerRadius = d3_functor(v);
            return arc;
        };
        arc.outerRadius = function(v) {
            if (!arguments.length) return outerRadius;
            outerRadius = d3_functor(v);
            return arc;
        };
        arc.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return arc;
        };
        arc.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return arc;
        };
        arc.centroid = function() {
            var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2, a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
            return [ Math.cos(a) * r, Math.sin(a) * r ];
        };
        return arc;
    };
    var d3_svg_arcOffset = -π / 2, d3_svg_arcMax = 2 * π - 1e-6;
    function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
    }
    function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
    }
    function d3_svg_arcStartAngle(d) {
        return d.startAngle;
    }
    function d3_svg_arcEndAngle(d) {
        return d.endAngle;
    }
    d3.svg.line.radial = function() {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
    };
    function d3_svg_lineRadial(points) {
        var point, i = -1, n = points.length, r, a;
        while (++i < n) {
            point = points[i];
            r = point[0];
            a = point[1] + d3_svg_arcOffset;
            point[0] = r * Math.cos(a);
            point[1] = r * Math.sin(a);
        }
        return points;
    }
    function d3_svg_area(projection) {
        var x0 = d3_svg_lineX, x1 = d3_svg_lineX, y0 = 0, y1 = d3_svg_lineY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
        function area(data) {
            var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
                return x;
            } : d3_functor(x1), fy1 = y0 === y1 ? function() {
                return y;
            } : d3_functor(y1), x, y;
            function segment() {
                segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
                    points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
                } else if (points0.length) {
                    segment();
                    points0 = [];
                    points1 = [];
                }
            }
            if (points0.length) segment();
            return segments.length ? segments.join("") : null;
        }
        area.x = function(_) {
            if (!arguments.length) return x1;
            x0 = x1 = _;
            return area;
        };
        area.x0 = function(_) {
            if (!arguments.length) return x0;
            x0 = _;
            return area;
        };
        area.x1 = function(_) {
            if (!arguments.length) return x1;
            x1 = _;
            return area;
        };
        area.y = function(_) {
            if (!arguments.length) return y1;
            y0 = y1 = _;
            return area;
        };
        area.y0 = function(_) {
            if (!arguments.length) return y0;
            y0 = _;
            return area;
        };
        area.y1 = function(_) {
            if (!arguments.length) return y1;
            y1 = _;
            return area;
        };
        area.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return area;
        };
        area.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            interpolateReverse = interpolate.reverse || interpolate;
            L = interpolate.closed ? "M" : "L";
            return area;
        };
        area.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return area;
        };
        return area;
    }
    d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
    d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
    d3.svg.area = function() {
        return d3_svg_area(d3_identity);
    };
    d3.svg.area.radial = function() {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
    };
    d3.svg.chord = function() {
        var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
            var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
            return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
        }
        function subgroup(self, f, d, i) {
            var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset, a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
            return {
                r: r,
                a0: a0,
                a1: a1,
                p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
                p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
            };
        }
        function equals(a, b) {
            return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
            return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
        }
        function curve(r0, p0, r1, p1) {
            return "Q 0,0 " + p1;
        }
        chord.radius = function(v) {
            if (!arguments.length) return radius;
            radius = d3_functor(v);
            return chord;
        };
        chord.source = function(v) {
            if (!arguments.length) return source;
            source = d3_functor(v);
            return chord;
        };
        chord.target = function(v) {
            if (!arguments.length) return target;
            target = d3_functor(v);
            return chord;
        };
        chord.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return chord;
        };
        chord.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return chord;
        };
        return chord;
    };
    function d3_svg_chordRadius(d) {
        return d.radius;
    }
    d3.svg.diagonal = function() {
        var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
            var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
                x: p0.x,
                y: m
            }, {
                x: p3.x,
                y: m
            }, p3 ];
            p = p.map(projection);
            return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
        }
        diagonal.source = function(x) {
            if (!arguments.length) return source;
            source = d3_functor(x);
            return diagonal;
        };
        diagonal.target = function(x) {
            if (!arguments.length) return target;
            target = d3_functor(x);
            return diagonal;
        };
        diagonal.projection = function(x) {
            if (!arguments.length) return projection;
            projection = x;
            return diagonal;
        };
        return diagonal;
    };
    function d3_svg_diagonalProjection(d) {
        return [ d.x, d.y ];
    }
    d3.svg.diagonal.radial = function() {
        var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
        diagonal.projection = function(x) {
            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        };
        return diagonal;
    };
    function d3_svg_diagonalRadialProjection(projection) {
        return function() {
            var d = projection.apply(this, arguments), r = d[0], a = d[1] + d3_svg_arcOffset;
            return [ r * Math.cos(a), r * Math.sin(a) ];
        };
    }
    d3.svg.symbol = function() {
        var type = d3_svg_symbolType, size = d3_svg_symbolSize;
        function symbol(d, i) {
            return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function(x) {
            if (!arguments.length) return type;
            type = d3_functor(x);
            return symbol;
        };
        symbol.size = function(x) {
            if (!arguments.length) return size;
            size = d3_functor(x);
            return symbol;
        };
        return symbol;
    };
    function d3_svg_symbolSize() {
        return 64;
    }
    function d3_svg_symbolType() {
        return "circle";
    }
    function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / π);
        return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
    }
    var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function(size) {
            var r = Math.sqrt(size / 5) / 2;
            return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
        },
        diamond: function(size) {
            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
            return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
        },
        square: function(size) {
            var r = Math.sqrt(size) / 2;
            return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
        },
        "triangle-down": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
        },
        "triangle-up": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
        }
    });
    d3.svg.symbolTypes = d3_svg_symbols.keys();
    var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
    function d3_transition(groups, id) {
        d3_arraySubclass(groups, d3_transitionPrototype);
        groups.id = id;
        return groups;
    }
    var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit = {
        ease: d3_ease_cubicInOut,
        delay: 0,
        duration: 250
    };
    d3_transitionPrototype.call = d3_selectionPrototype.call;
    d3_transitionPrototype.empty = d3_selectionPrototype.empty;
    d3_transitionPrototype.node = d3_selectionPrototype.node;
    d3.transition = function(selection) {
        return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition();
    };
    d3.transition.prototype = d3_transitionPrototype;
    d3_transitionPrototype.select = function(selector) {
        var id = this.id, subgroups = [], subgroup, subnode, node;
        if (typeof selector !== "function") selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i))) {
                    if ("__data__" in node) subnode.__data__ = node.__data__;
                    d3_transitionNode(subnode, i, id, node.__transition__[id]);
                    subgroup.push(subnode);
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_transition(subgroups, id);
    };
    d3_transitionPrototype.selectAll = function(selector) {
        var id = this.id, subgroups = [], subgroup, subnodes, node, subnode, transition;
        if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    transition = node.__transition__[id];
                    subnodes = selector.call(node, node.__data__, i);
                    subgroups.push(subgroup = []);
                    for (var k = -1, o = subnodes.length; ++k < o; ) {
                        d3_transitionNode(subnode = subnodes[k], k, id, transition);
                        subgroup.push(subnode);
                    }
                }
            }
        }
        return d3_transition(subgroups, id);
    };
    d3_transitionPrototype.filter = function(filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== "function") filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_transition(subgroups, this.id, this.time).ease(this.ease());
    };
    d3_transitionPrototype.tween = function(name, tween) {
        var id = this.id;
        if (arguments.length < 2) return this.node().__transition__[id].tween.get(name);
        return d3_selection_each(this, tween == null ? function(node) {
            node.__transition__[id].tween.remove(name);
        } : function(node) {
            node.__transition__[id].tween.set(name, tween);
        });
    };
    function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id;
        return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
            node.__transition__[id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        } : (value = tween(value), function(node) {
            node.__transition__[id].tween.set(name, value);
        }));
    }
    d3_transitionPrototype.attr = function(nameNS, value) {
        if (arguments.length < 2) {
            for (value in nameNS) this.attr(value, nameNS[value]);
            return this;
        }
        var interpolate = d3_interpolateByName(nameNS), name = d3.ns.qualify(nameNS);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
            return b == null ? attrNull : (b += "", function() {
                var a = this.getAttribute(name), i;
                return a !== b && (i = interpolate(a, b), function(t) {
                    this.setAttribute(name, i(t));
                });
            });
        }
        function attrTweenNS(b) {
            return b == null ? attrNullNS : (b += "", function() {
                var a = this.getAttributeNS(name.space, name.local), i;
                return a !== b && (i = interpolate(a, b), function(t) {
                    this.setAttributeNS(name.space, name.local, i(t));
                });
            });
        }
        return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.attrTween = function(nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
            var f = tween.call(this, d, i, this.getAttribute(name));
            return f && function(t) {
                this.setAttribute(name, f(t));
            };
        }
        function attrTweenNS(d, i) {
            var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
            return f && function(t) {
                this.setAttributeNS(name.space, name.local, f(t));
            };
        }
        return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== "string") {
                if (n < 2) value = "";
                for (priority in name) this.style(priority, name[priority], value);
                return this;
            }
            priority = "";
        }
        var interpolate = d3_interpolateByName(name);
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleString(b) {
            return b == null ? styleNull : (b += "", function() {
                var a = d3_window.getComputedStyle(this, null).getPropertyValue(name), i;
                return a !== b && (i = interpolate(a, b), function(t) {
                    this.style.setProperty(name, i(t), priority);
                });
            });
        }
        return d3_transition_tween(this, "style." + name, value, styleString);
    };
    d3_transitionPrototype.styleTween = function(name, tween, priority) {
        if (arguments.length < 3) priority = "";
        function styleTween(d, i) {
            var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));
            return f && function(t) {
                this.style.setProperty(name, f(t), priority);
            };
        }
        return this.tween("style." + name, styleTween);
    };
    d3_transitionPrototype.text = function(value) {
        return d3_transition_tween(this, "text", value, d3_transition_text);
    };
    function d3_transition_text(b) {
        if (b == null) b = "";
        return function() {
            this.textContent = b;
        };
    }
    d3_transitionPrototype.remove = function() {
        return this.each("end.transition", function() {
            var p;
            if (!this.__transition__ && (p = this.parentNode)) p.removeChild(this);
        });
    };
    d3_transitionPrototype.ease = function(value) {
        var id = this.id;
        if (arguments.length < 1) return this.node().__transition__[id].ease;
        if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function(node) {
            node.__transition__[id].ease = value;
        });
    };
    d3_transitionPrototype.delay = function(value) {
        var id = this.id;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node.__transition__[id].delay = value.call(node, node.__data__, i, j) | 0;
        } : (value |= 0, function(node) {
            node.__transition__[id].delay = value;
        }));
    };
    d3_transitionPrototype.duration = function(value) {
        var id = this.id;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node.__transition__[id].duration = Math.max(1, value.call(node, node.__data__, i, j) | 0);
        } : (value = Math.max(1, value | 0), function(node) {
            node.__transition__[id].duration = value;
        }));
    };
    d3_transitionPrototype.each = function(type, listener) {
        var id = this.id;
        if (arguments.length < 2) {
            var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
            d3_transitionInheritId = id;
            d3_selection_each(this, function(node, i, j) {
                d3_transitionInherit = node.__transition__[id];
                type.call(node, node.__data__, i, j);
            });
            d3_transitionInherit = inherit;
            d3_transitionInheritId = inheritId;
        } else {
            d3_selection_each(this, function(node) {
                node.__transition__[id].event.on(type, listener);
            });
        }
        return this;
    };
    d3_transitionPrototype.transition = function() {
        var id0 = this.id, id1 = ++d3_transitionId, subgroups = [], subgroup, group, node, transition;
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if (node = group[i]) {
                    transition = Object.create(node.__transition__[id0]);
                    transition.delay += transition.duration;
                    d3_transitionNode(node, i, id1, transition);
                }
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, id1);
    };
    function d3_transitionNode(node, i, id, inherit) {
        var lock = node.__transition__ || (node.__transition__ = {
            active: 0,
            count: 0
        }), transition = lock[id];
        if (!transition) {
            var time = inherit.time;
            transition = lock[id] = {
                tween: new d3_Map(),
                event: d3.dispatch("start", "end"),
                time: time,
                ease: inherit.ease,
                delay: inherit.delay,
                duration: inherit.duration
            };
            ++lock.count;
            d3.timer(function(elapsed) {
                var d = node.__data__, ease = transition.ease, event = transition.event, delay = transition.delay, duration = transition.duration, tweened = [];
                return delay <= elapsed ? start(elapsed) : d3.timer(start, delay, time), 1;
                function start(elapsed) {
                    if (lock.active > id) return stop();
                    lock.active = id;
                    event.start.call(node, d, i);
                    transition.tween.forEach(function(key, value) {
                        if (value = value.call(node, d, i)) {
                            tweened.push(value);
                        }
                    });
                    if (!tick(elapsed)) d3.timer(tick, 0, time);
                    return 1;
                }
                function tick(elapsed) {
                    if (lock.active !== id) return stop();
                    var t = (elapsed - delay) / duration, e = ease(t), n = tweened.length;
                    while (n > 0) {
                        tweened[--n].call(node, e);
                    }
                    if (t >= 1) {
                        stop();
                        event.end.call(node, d, i);
                        return 1;
                    }
                }
                function stop() {
                    if (--lock.count) delete lock[id]; else delete node.__transition__;
                    return 1;
                }
            }, 0, time);
            return transition;
        }
    }
    d3.svg.axis = function() {
        var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, tickMajorSize = 6, tickMinorSize = 6, tickEndSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_, tickSubdivide = 0;
        function axis(g) {
            g.each(function() {
                var g = d3.select(this);
                var ticks = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain() : tickValues, tickFormat = tickFormat_ == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String : tickFormat_;
                var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide), subtick = g.selectAll(".tick.minor").data(subticks, String), subtickEnter = subtick.enter().insert("line", ".tick").attr("class", "tick minor").style("opacity", 1e-6), subtickExit = d3.transition(subtick.exit()).style("opacity", 1e-6).remove(), subtickUpdate = d3.transition(subtick).style("opacity", 1);
                var tick = g.selectAll(".tick.major").data(ticks, String), tickEnter = tick.enter().insert("g", "path").attr("class", "tick major").style("opacity", 1e-6), tickExit = d3.transition(tick.exit()).style("opacity", 1e-6).remove(), tickUpdate = d3.transition(tick).style("opacity", 1), tickTransform;
                var range = d3_scaleRange(scale), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
                d3.transition(path));
                var scale1 = scale.copy(), scale0 = this.__chart__ || scale1;
                this.__chart__ = scale1;
                tickEnter.append("line");
                tickEnter.append("text");
                var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text");
                switch (orient) {
                  case "bottom":
                    {
                        tickTransform = d3_svg_axisX;
                        subtickEnter.attr("y2", tickMinorSize);
                        subtickUpdate.attr("x2", 0).attr("y2", tickMinorSize);
                        lineEnter.attr("y2", tickMajorSize);
                        textEnter.attr("y", Math.max(tickMajorSize, 0) + tickPadding);
                        lineUpdate.attr("x2", 0).attr("y2", tickMajorSize);
                        textUpdate.attr("x", 0).attr("y", Math.max(tickMajorSize, 0) + tickPadding);
                        text.attr("dy", ".71em").style("text-anchor", "middle");
                        pathUpdate.attr("d", "M" + range[0] + "," + tickEndSize + "V0H" + range[1] + "V" + tickEndSize);
                        break;
                    }

                  case "top":
                    {
                        tickTransform = d3_svg_axisX;
                        subtickEnter.attr("y2", -tickMinorSize);
                        subtickUpdate.attr("x2", 0).attr("y2", -tickMinorSize);
                        lineEnter.attr("y2", -tickMajorSize);
                        textEnter.attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
                        lineUpdate.attr("x2", 0).attr("y2", -tickMajorSize);
                        textUpdate.attr("x", 0).attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
                        text.attr("dy", "0em").style("text-anchor", "middle");
                        pathUpdate.attr("d", "M" + range[0] + "," + -tickEndSize + "V0H" + range[1] + "V" + -tickEndSize);
                        break;
                    }

                  case "left":
                    {
                        tickTransform = d3_svg_axisY;
                        subtickEnter.attr("x2", -tickMinorSize);
                        subtickUpdate.attr("x2", -tickMinorSize).attr("y2", 0);
                        lineEnter.attr("x2", -tickMajorSize);
                        textEnter.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding));
                        lineUpdate.attr("x2", -tickMajorSize).attr("y2", 0);
                        textUpdate.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding)).attr("y", 0);
                        text.attr("dy", ".32em").style("text-anchor", "end");
                        pathUpdate.attr("d", "M" + -tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + -tickEndSize);
                        break;
                    }

                  case "right":
                    {
                        tickTransform = d3_svg_axisY;
                        subtickEnter.attr("x2", tickMinorSize);
                        subtickUpdate.attr("x2", tickMinorSize).attr("y2", 0);
                        lineEnter.attr("x2", tickMajorSize);
                        textEnter.attr("x", Math.max(tickMajorSize, 0) + tickPadding);
                        lineUpdate.attr("x2", tickMajorSize).attr("y2", 0);
                        textUpdate.attr("x", Math.max(tickMajorSize, 0) + tickPadding).attr("y", 0);
                        text.attr("dy", ".32em").style("text-anchor", "start");
                        pathUpdate.attr("d", "M" + tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + tickEndSize);
                        break;
                    }
                }
                if (scale.ticks) {
                    tickEnter.call(tickTransform, scale0);
                    tickUpdate.call(tickTransform, scale1);
                    tickExit.call(tickTransform, scale1);
                    subtickEnter.call(tickTransform, scale0);
                    subtickUpdate.call(tickTransform, scale1);
                    subtickExit.call(tickTransform, scale1);
                } else {
                    var dx = scale1.rangeBand() / 2, x = function(d) {
                        return scale1(d) + dx;
                    };
                    tickEnter.call(tickTransform, x);
                    tickUpdate.call(tickTransform, x);
                }
            });
        }
        axis.scale = function(x) {
            if (!arguments.length) return scale;
            scale = x;
            return axis;
        };
        axis.orient = function(x) {
            if (!arguments.length) return orient;
            orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
            return axis;
        };
        axis.ticks = function() {
            if (!arguments.length) return tickArguments_;
            tickArguments_ = arguments;
            return axis;
        };
        axis.tickValues = function(x) {
            if (!arguments.length) return tickValues;
            tickValues = x;
            return axis;
        };
        axis.tickFormat = function(x) {
            if (!arguments.length) return tickFormat_;
            tickFormat_ = x;
            return axis;
        };
        axis.tickSize = function(x, y) {
            if (!arguments.length) return tickMajorSize;
            var n = arguments.length - 1;
            tickMajorSize = +x;
            tickMinorSize = n > 1 ? +y : tickMajorSize;
            tickEndSize = n > 0 ? +arguments[n] : tickMajorSize;
            return axis;
        };
        axis.tickPadding = function(x) {
            if (!arguments.length) return tickPadding;
            tickPadding = +x;
            return axis;
        };
        axis.tickSubdivide = function(x) {
            if (!arguments.length) return tickSubdivide;
            tickSubdivide = +x;
            return axis;
        };
        return axis;
    };
    var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1
    };
    function d3_svg_axisX(selection, x) {
        selection.attr("transform", function(d) {
            return "translate(" + x(d) + ",0)";
        });
    }
    function d3_svg_axisY(selection, y) {
        selection.attr("transform", function(d) {
            return "translate(0," + y(d) + ")";
        });
    }
    function d3_svg_axisSubdivide(scale, ticks, m) {
        subticks = [];
        if (m && ticks.length > 1) {
            var extent = d3_scaleExtent(scale.domain()), subticks, i = -1, n = ticks.length, d = (ticks[1] - ticks[0]) / ++m, j, v;
            while (++i < n) {
                for (j = m; --j > 0; ) {
                    if ((v = +ticks[i] - j * d) >= extent[0]) {
                        subticks.push(v);
                    }
                }
            }
            for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1]; ) {
                subticks.push(v);
            }
        }
        return subticks;
    }
    d3.svg.brush = function() {
        var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, resizes = d3_svg_brushResizes[0], extent = [ [ 0, 0 ], [ 0, 0 ] ], extentDomain;
        function brush(g) {
            g.each(function() {
                var g = d3.select(this), bg = g.selectAll(".background").data([ 0 ]), fg = g.selectAll(".extent").data([ 0 ]), tz = g.selectAll(".resize").data(resizes, String), e;
                g.style("pointer-events", "all").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
                bg.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
                fg.enter().append("rect").attr("class", "extent").style("cursor", "move");
                tz.enter().append("g").attr("class", function(d) {
                    return "resize " + d;
                }).style("cursor", function(d) {
                    return d3_svg_brushCursor[d];
                }).append("rect").attr("x", function(d) {
                    return /[ew]$/.test(d) ? -3 : null;
                }).attr("y", function(d) {
                    return /^[ns]/.test(d) ? -3 : null;
                }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
                tz.style("display", brush.empty() ? "none" : null);
                tz.exit().remove();
                if (x) {
                    e = d3_scaleRange(x);
                    bg.attr("x", e[0]).attr("width", e[1] - e[0]);
                    redrawX(g);
                }
                if (y) {
                    e = d3_scaleRange(y);
                    bg.attr("y", e[0]).attr("height", e[1] - e[0]);
                    redrawY(g);
                }
                redraw(g);
            });
        }
        function redraw(g) {
            g.selectAll(".resize").attr("transform", function(d) {
                return "translate(" + extent[+/e$/.test(d)][0] + "," + extent[+/^s/.test(d)][1] + ")";
            });
        }
        function redrawX(g) {
            g.select(".extent").attr("x", extent[0][0]);
            g.selectAll(".extent,.n>rect,.s>rect").attr("width", extent[1][0] - extent[0][0]);
        }
        function redrawY(g) {
            g.select(".extent").attr("y", extent[0][1]);
            g.selectAll(".extent,.e>rect,.w>rect").attr("height", extent[1][1] - extent[0][1]);
        }
        function brushstart() {
            var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), center, origin = mouse(), offset;
            var w = d3.select(d3_window).on("mousemove.brush", brushmove).on("mouseup.brush", brushend).on("touchmove.brush", brushmove).on("touchend.brush", brushend).on("keydown.brush", keydown).on("keyup.brush", keyup);
            if (dragging) {
                origin[0] = extent[0][0] - origin[0];
                origin[1] = extent[0][1] - origin[1];
            } else if (resizing) {
                var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
                offset = [ extent[1 - ex][0] - origin[0], extent[1 - ey][1] - origin[1] ];
                origin[0] = extent[ex][0];
                origin[1] = extent[ey][1];
            } else if (d3.event.altKey) center = origin.slice();
            g.style("pointer-events", "none").selectAll(".resize").style("display", null);
            d3.select("body").style("cursor", eventTarget.style("cursor"));
            event_({
                type: "brushstart"
            });
            brushmove();
            d3_eventCancel();
            function mouse() {
                var touches = d3.event.changedTouches;
                return touches ? d3.touches(target, touches)[0] : d3.mouse(target);
            }
            function keydown() {
                if (d3.event.keyCode == 32) {
                    if (!dragging) {
                        center = null;
                        origin[0] -= extent[1][0];
                        origin[1] -= extent[1][1];
                        dragging = 2;
                    }
                    d3_eventCancel();
                }
            }
            function keyup() {
                if (d3.event.keyCode == 32 && dragging == 2) {
                    origin[0] += extent[1][0];
                    origin[1] += extent[1][1];
                    dragging = 0;
                    d3_eventCancel();
                }
            }
            function brushmove() {
                var point = mouse(), moved = false;
                if (offset) {
                    point[0] += offset[0];
                    point[1] += offset[1];
                }
                if (!dragging) {
                    if (d3.event.altKey) {
                        if (!center) center = [ (extent[0][0] + extent[1][0]) / 2, (extent[0][1] + extent[1][1]) / 2 ];
                        origin[0] = extent[+(point[0] < center[0])][0];
                        origin[1] = extent[+(point[1] < center[1])][1];
                    } else center = null;
                }
                if (resizingX && move1(point, x, 0)) {
                    redrawX(g);
                    moved = true;
                }
                if (resizingY && move1(point, y, 1)) {
                    redrawY(g);
                    moved = true;
                }
                if (moved) {
                    redraw(g);
                    event_({
                        type: "brush",
                        mode: dragging ? "move" : "resize"
                    });
                }
            }
            function move1(point, scale, i) {
                var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], size = extent[1][i] - extent[0][i], min, max;
                if (dragging) {
                    r0 -= position;
                    r1 -= size + position;
                }
                min = Math.max(r0, Math.min(r1, point[i]));
                if (dragging) {
                    max = (min += position) + size;
                } else {
                    if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
                    if (position < min) {
                        max = min;
                        min = position;
                    } else {
                        max = position;
                    }
                }
                if (extent[0][i] !== min || extent[1][i] !== max) {
                    extentDomain = null;
                    extent[0][i] = min;
                    extent[1][i] = max;
                    return true;
                }
            }
            function brushend() {
                brushmove();
                g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
                d3.select("body").style("cursor", null);
                w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
                event_({
                    type: "brushend"
                });
                d3_eventCancel();
            }
        }
        brush.x = function(z) {
            if (!arguments.length) return x;
            x = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.extent = function(z) {
            var x0, x1, y0, y1, t;
            if (!arguments.length) {
                z = extentDomain || extent;
                if (x) {
                    x0 = z[0][0], x1 = z[1][0];
                    if (!extentDomain) {
                        x0 = extent[0][0], x1 = extent[1][0];
                        if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
                        if (x1 < x0) t = x0, x0 = x1, x1 = t;
                    }
                }
                if (y) {
                    y0 = z[0][1], y1 = z[1][1];
                    if (!extentDomain) {
                        y0 = extent[0][1], y1 = extent[1][1];
                        if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
                        if (y1 < y0) t = y0, y0 = y1, y1 = t;
                    }
                }
                return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
            }
            extentDomain = [ [ 0, 0 ], [ 0, 0 ] ];
            if (x) {
                x0 = z[0], x1 = z[1];
                if (y) x0 = x0[0], x1 = x1[0];
                extentDomain[0][0] = x0, extentDomain[1][0] = x1;
                if (x.invert) x0 = x(x0), x1 = x(x1);
                if (x1 < x0) t = x0, x0 = x1, x1 = t;
                extent[0][0] = x0 | 0, extent[1][0] = x1 | 0;
            }
            if (y) {
                y0 = z[0], y1 = z[1];
                if (x) y0 = y0[1], y1 = y1[1];
                extentDomain[0][1] = y0, extentDomain[1][1] = y1;
                if (y.invert) y0 = y(y0), y1 = y(y1);
                if (y1 < y0) t = y0, y0 = y1, y1 = t;
                extent[0][1] = y0 | 0, extent[1][1] = y1 | 0;
            }
            return brush;
        };
        brush.clear = function() {
            extentDomain = null;
            extent[0][0] = extent[0][1] = extent[1][0] = extent[1][1] = 0;
            return brush;
        };
        brush.empty = function() {
            return x && extent[0][0] === extent[1][0] || y && extent[0][1] === extent[1][1];
        };
        return d3.rebind(brush, event, "on");
    };
    var d3_svg_brushCursor = {
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
    };
    var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
    d3.time = {};
    var d3_time = Date, d3_time_daySymbols = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ];
    function d3_time_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
    }
    d3_time_utc.prototype = {
        getDate: function() {
            return this._.getUTCDate();
        },
        getDay: function() {
            return this._.getUTCDay();
        },
        getFullYear: function() {
            return this._.getUTCFullYear();
        },
        getHours: function() {
            return this._.getUTCHours();
        },
        getMilliseconds: function() {
            return this._.getUTCMilliseconds();
        },
        getMinutes: function() {
            return this._.getUTCMinutes();
        },
        getMonth: function() {
            return this._.getUTCMonth();
        },
        getSeconds: function() {
            return this._.getUTCSeconds();
        },
        getTime: function() {
            return this._.getTime();
        },
        getTimezoneOffset: function() {
            return 0;
        },
        valueOf: function() {
            return this._.valueOf();
        },
        setDate: function() {
            d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function() {
            d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function() {
            d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function() {
            d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function() {
            d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function() {
            d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function() {
            d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function() {
            d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function() {
            d3_time_prototype.setTime.apply(this._, arguments);
        }
    };
    var d3_time_prototype = Date.prototype;
    var d3_time_formatDateTime = "%a %b %e %X %Y", d3_time_formatDate = "%m/%d/%Y", d3_time_formatTime = "%H:%M:%S";
    var d3_time_days = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], d3_time_dayAbbreviations = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], d3_time_months = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ], d3_time_monthAbbreviations = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
    function d3_time_interval(local, step, number) {
        function round(date) {
            var d0 = local(date), d1 = offset(d0, 1);
            return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
            step(date = local(new d3_time(date - 1)), 1);
            return date;
        }
        function offset(date, k) {
            step(date = new d3_time(+date), k);
            return date;
        }
        function range(t0, t1, dt) {
            var time = ceil(t0), times = [];
            if (dt > 1) {
                while (time < t1) {
                    if (!(number(time) % dt)) times.push(new Date(+time));
                    step(time, 1);
                }
            } else {
                while (time < t1) times.push(new Date(+time)), step(time, 1);
            }
            return times;
        }
        function range_utc(t0, t1, dt) {
            try {
                d3_time = d3_time_utc;
                var utc = new d3_time_utc();
                utc._ = t0;
                return range(utc, t1, dt);
            } finally {
                d3_time = Date;
            }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        utc.floor = utc;
        utc.round = d3_time_interval_utc(round);
        utc.ceil = d3_time_interval_utc(ceil);
        utc.offset = d3_time_interval_utc(offset);
        utc.range = range_utc;
        return local;
    }
    function d3_time_interval_utc(method) {
        return function(date, k) {
            try {
                d3_time = d3_time_utc;
                var utc = new d3_time_utc();
                utc._ = date;
                return method(utc, k)._;
            } finally {
                d3_time = Date;
            }
        };
    }
    d3.time.year = d3_time_interval(function(date) {
        date = d3.time.day(date);
        date.setMonth(0, 1);
        return date;
    }, function(date, offset) {
        date.setFullYear(date.getFullYear() + offset);
    }, function(date) {
        return date.getFullYear();
    });
    d3.time.years = d3.time.year.range;
    d3.time.years.utc = d3.time.year.utc.range;
    d3.time.day = d3_time_interval(function(date) {
        var day = new d3_time(1970, 0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
    }, function(date, offset) {
        date.setDate(date.getDate() + offset);
    }, function(date) {
        return date.getDate() - 1;
    });
    d3.time.days = d3.time.day.range;
    d3.time.days.utc = d3.time.day.utc.range;
    d3.time.dayOfYear = function(date) {
        var year = d3.time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
    };
    d3_time_daySymbols.forEach(function(day, i) {
        day = day.toLowerCase();
        i = 7 - i;
        var interval = d3.time[day] = d3_time_interval(function(date) {
            (date = d3.time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
            return date;
        }, function(date, offset) {
            date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function(date) {
            var day = d3.time.year(date).getDay();
            return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3.time[day + "s"] = interval.range;
        d3.time[day + "s"].utc = interval.utc.range;
        d3.time[day + "OfYear"] = function(date) {
            var day = d3.time.year(date).getDay();
            return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7);
        };
    });
    d3.time.week = d3.time.sunday;
    d3.time.weeks = d3.time.sunday.range;
    d3.time.weeks.utc = d3.time.sunday.utc.range;
    d3.time.weekOfYear = d3.time.sundayOfYear;
    d3.time.format = function(template) {
        var n = template.length;
        function format(date) {
            var string = [], i = -1, j = 0, c, p, f;
            while (++i < n) {
                if (template.charCodeAt(i) === 37) {
                    string.push(template.substring(j, i));
                    if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
                    if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
                    string.push(c);
                    j = i + 1;
                }
            }
            string.push(template.substring(j, i));
            return string.join("");
        }
        format.parse = function(string) {
            var d = {
                y: 1900,
                m: 0,
                d: 1,
                H: 0,
                M: 0,
                S: 0,
                L: 0
            }, i = d3_time_parse(d, template, string, 0);
            if (i != string.length) return null;
            if ("p" in d) d.H = d.H % 12 + d.p * 12;
            var date = new d3_time();
            date.setFullYear(d.y, d.m, d.d);
            date.setHours(d.H, d.M, d.S, d.L);
            return date;
        };
        format.toString = function() {
            return template;
        };
        return format;
    };
    function d3_time_parse(date, template, string, j) {
        var c, p, i = 0, n = template.length, m = string.length;
        while (i < n) {
            if (j >= m) return -1;
            c = template.charCodeAt(i++);
            if (c === 37) {
                p = d3_time_parsers[template.charAt(i++)];
                if (!p || (j = p(date, string, j)) < 0) return -1;
            } else if (c != string.charCodeAt(j++)) {
                return -1;
            }
        }
        return j;
    }
    function d3_time_formatRe(names) {
        return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
    }
    function d3_time_formatLookup(names) {
        var map = new d3_Map(), i = -1, n = names.length;
        while (++i < n) map.set(names[i].toLowerCase(), i);
        return map;
    }
    function d3_time_formatPad(value, fill, width) {
        value += "";
        var length = value.length;
        return length < width ? new Array(width - length + 1).join(fill) + value : value;
    }
    var d3_time_dayRe = d3_time_formatRe(d3_time_days), d3_time_dayAbbrevRe = d3_time_formatRe(d3_time_dayAbbreviations), d3_time_monthRe = d3_time_formatRe(d3_time_months), d3_time_monthLookup = d3_time_formatLookup(d3_time_months), d3_time_monthAbbrevRe = d3_time_formatRe(d3_time_monthAbbreviations), d3_time_monthAbbrevLookup = d3_time_formatLookup(d3_time_monthAbbreviations);
    var d3_time_formatPads = {
        "-": "",
        _: " ",
        "0": "0"
    };
    var d3_time_formats = {
        a: function(d) {
            return d3_time_dayAbbreviations[d.getDay()];
        },
        A: function(d) {
            return d3_time_days[d.getDay()];
        },
        b: function(d) {
            return d3_time_monthAbbreviations[d.getMonth()];
        },
        B: function(d) {
            return d3_time_months[d.getMonth()];
        },
        c: d3.time.format(d3_time_formatDateTime),
        d: function(d, p) {
            return d3_time_formatPad(d.getDate(), p, 2);
        },
        e: function(d, p) {
            return d3_time_formatPad(d.getDate(), p, 2);
        },
        H: function(d, p) {
            return d3_time_formatPad(d.getHours(), p, 2);
        },
        I: function(d, p) {
            return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
        },
        j: function(d, p) {
            return d3_time_formatPad(1 + d3.time.dayOfYear(d), p, 3);
        },
        L: function(d, p) {
            return d3_time_formatPad(d.getMilliseconds(), p, 3);
        },
        m: function(d, p) {
            return d3_time_formatPad(d.getMonth() + 1, p, 2);
        },
        M: function(d, p) {
            return d3_time_formatPad(d.getMinutes(), p, 2);
        },
        p: function(d) {
            return d.getHours() >= 12 ? "PM" : "AM";
        },
        S: function(d, p) {
            return d3_time_formatPad(d.getSeconds(), p, 2);
        },
        U: function(d, p) {
            return d3_time_formatPad(d3.time.sundayOfYear(d), p, 2);
        },
        w: function(d) {
            return d.getDay();
        },
        W: function(d, p) {
            return d3_time_formatPad(d3.time.mondayOfYear(d), p, 2);
        },
        x: d3.time.format(d3_time_formatDate),
        X: d3.time.format(d3_time_formatTime),
        y: function(d, p) {
            return d3_time_formatPad(d.getFullYear() % 100, p, 2);
        },
        Y: function(d, p) {
            return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
        },
        Z: d3_time_zone,
        "%": function() {
            return "%";
        }
    };
    var d3_time_parsers = {
        a: d3_time_parseWeekdayAbbrev,
        A: d3_time_parseWeekday,
        b: d3_time_parseMonthAbbrev,
        B: d3_time_parseMonth,
        c: d3_time_parseLocaleFull,
        d: d3_time_parseDay,
        e: d3_time_parseDay,
        H: d3_time_parseHour24,
        I: d3_time_parseHour24,
        L: d3_time_parseMilliseconds,
        m: d3_time_parseMonthNumber,
        M: d3_time_parseMinutes,
        p: d3_time_parseAmPm,
        S: d3_time_parseSeconds,
        x: d3_time_parseLocaleDate,
        X: d3_time_parseLocaleTime,
        y: d3_time_parseYear,
        Y: d3_time_parseFullYear
    };
    function d3_time_parseWeekdayAbbrev(date, string, i) {
        d3_time_dayAbbrevRe.lastIndex = 0;
        var n = d3_time_dayAbbrevRe.exec(string.substring(i));
        return n ? i += n[0].length : -1;
    }
    function d3_time_parseWeekday(date, string, i) {
        d3_time_dayRe.lastIndex = 0;
        var n = d3_time_dayRe.exec(string.substring(i));
        return n ? i += n[0].length : -1;
    }
    function d3_time_parseMonthAbbrev(date, string, i) {
        d3_time_monthAbbrevRe.lastIndex = 0;
        var n = d3_time_monthAbbrevRe.exec(string.substring(i));
        return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;
    }
    function d3_time_parseMonth(date, string, i) {
        d3_time_monthRe.lastIndex = 0;
        var n = d3_time_monthRe.exec(string.substring(i));
        return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;
    }
    function d3_time_parseLocaleFull(date, string, i) {
        return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
    }
    function d3_time_parseLocaleDate(date, string, i) {
        return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
    }
    function d3_time_parseLocaleTime(date, string, i) {
        return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
    }
    function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 4));
        return n ? (date.y = +n[0], i += n[0].length) : -1;
    }
    function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i += n[0].length) : -1;
    }
    function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2e3);
    }
    function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 2));
        return n ? (date.m = n[0] - 1, i += n[0].length) : -1;
    }
    function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 2));
        return n ? (date.d = +n[0], i += n[0].length) : -1;
    }
    function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 2));
        return n ? (date.H = +n[0], i += n[0].length) : -1;
    }
    function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 2));
        return n ? (date.M = +n[0], i += n[0].length) : -1;
    }
    function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 2));
        return n ? (date.S = +n[0], i += n[0].length) : -1;
    }
    function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.substring(i, i + 3));
        return n ? (date.L = +n[0], i += n[0].length) : -1;
    }
    var d3_time_numberRe = /^\s*\d+/;
    function d3_time_parseAmPm(date, string, i) {
        var n = d3_time_amPmLookup.get(string.substring(i, i += 2).toLowerCase());
        return n == null ? -1 : (date.p = n, i);
    }
    var d3_time_amPmLookup = d3.map({
        am: 0,
        pm: 1
    });
    function d3_time_zone(d) {
        var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = ~~(Math.abs(z) / 60), zm = Math.abs(z) % 60;
        return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
    }
    d3.time.format.utc = function(template) {
        var local = d3.time.format(template);
        function format(date) {
            try {
                d3_time = d3_time_utc;
                var utc = new d3_time();
                utc._ = date;
                return local(utc);
            } finally {
                d3_time = Date;
            }
        }
        format.parse = function(string) {
            try {
                d3_time = d3_time_utc;
                var date = local.parse(string);
                return date && date._;
            } finally {
                d3_time = Date;
            }
        };
        format.toString = local.toString;
        return format;
    };
    var d3_time_formatIso = d3.time.format.utc("%Y-%m-%dT%H:%M:%S.%LZ");
    d3.time.format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
    function d3_time_formatIsoNative(date) {
        return date.toISOString();
    }
    d3_time_formatIsoNative.parse = function(string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
    };
    d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
    d3.time.second = d3_time_interval(function(date) {
        return new d3_time(Math.floor(date / 1e3) * 1e3);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1e3);
    }, function(date) {
        return date.getSeconds();
    });
    d3.time.seconds = d3.time.second.range;
    d3.time.seconds.utc = d3.time.second.utc.range;
    d3.time.minute = d3_time_interval(function(date) {
        return new d3_time(Math.floor(date / 6e4) * 6e4);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 6e4);
    }, function(date) {
        return date.getMinutes();
    });
    d3.time.minutes = d3.time.minute.range;
    d3.time.minutes.utc = d3.time.minute.utc.range;
    d3.time.hour = d3_time_interval(function(date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_time((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 36e5);
    }, function(date) {
        return date.getHours();
    });
    d3.time.hours = d3.time.hour.range;
    d3.time.hours.utc = d3.time.hour.utc.range;
    d3.time.month = d3_time_interval(function(date) {
        date = d3.time.day(date);
        date.setDate(1);
        return date;
    }, function(date, offset) {
        date.setMonth(date.getMonth() + offset);
    }, function(date) {
        return date.getMonth();
    });
    d3.time.months = d3.time.month.range;
    d3.time.months.utc = d3.time.month.utc.range;
    function d3_time_scale(linear, methods, format) {
        function scale(x) {
            return linear(x);
        }
        scale.invert = function(x) {
            return d3_time_scaleDate(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
            linear.domain(x);
            return scale;
        };
        scale.nice = function(m) {
            return scale.domain(d3_scale_nice(scale.domain(), function() {
                return m;
            }));
        };
        scale.ticks = function(m, k) {
            var extent = d3_scaleExtent(scale.domain());
            if (typeof m !== "function") {
                var span = extent[1] - extent[0], target = span / m, i = d3.bisect(d3_time_scaleSteps, target);
                if (i == d3_time_scaleSteps.length) return methods.year(extent, m);
                if (!i) return linear.ticks(m).map(d3_time_scaleDate);
                if (Math.log(target / d3_time_scaleSteps[i - 1]) < Math.log(d3_time_scaleSteps[i] / target)) --i;
                m = methods[i];
                k = m[1];
                m = m[0].range;
            }
            return m(extent[0], new Date(+extent[1] + 1), k);
        };
        scale.tickFormat = function() {
            return format;
        };
        scale.copy = function() {
            return d3_time_scale(linear.copy(), methods, format);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_time_scaleDate(t) {
        return new Date(t);
    }
    function d3_time_scaleFormat(formats) {
        return function(date) {
            var i = formats.length - 1, f = formats[i];
            while (!f[1](date)) f = formats[--i];
            return f[0](date);
        };
    }
    function d3_time_scaleSetYear(y) {
        var d = new Date(y, 0, 1);
        d.setFullYear(y);
        return d;
    }
    function d3_time_scaleGetYear(d) {
        var y = d.getFullYear(), d0 = d3_time_scaleSetYear(y), d1 = d3_time_scaleSetYear(y + 1);
        return y + (d - d0) / (d1 - d0);
    }
    var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
    var d3_time_scaleLocalMethods = [ [ d3.time.second, 1 ], [ d3.time.second, 5 ], [ d3.time.second, 15 ], [ d3.time.second, 30 ], [ d3.time.minute, 1 ], [ d3.time.minute, 5 ], [ d3.time.minute, 15 ], [ d3.time.minute, 30 ], [ d3.time.hour, 1 ], [ d3.time.hour, 3 ], [ d3.time.hour, 6 ], [ d3.time.hour, 12 ], [ d3.time.day, 1 ], [ d3.time.day, 2 ], [ d3.time.week, 1 ], [ d3.time.month, 1 ], [ d3.time.month, 3 ], [ d3.time.year, 1 ] ];
    var d3_time_scaleLocalFormats = [ [ d3.time.format("%Y"), d3_true ], [ d3.time.format("%B"), function(d) {
        return d.getMonth();
    } ], [ d3.time.format("%b %d"), function(d) {
        return d.getDate() != 1;
    } ], [ d3.time.format("%a %d"), function(d) {
        return d.getDay() && d.getDate() != 1;
    } ], [ d3.time.format("%I %p"), function(d) {
        return d.getHours();
    } ], [ d3.time.format("%I:%M"), function(d) {
        return d.getMinutes();
    } ], [ d3.time.format(":%S"), function(d) {
        return d.getSeconds();
    } ], [ d3.time.format(".%L"), function(d) {
        return d.getMilliseconds();
    } ] ];
    var d3_time_scaleLinear = d3.scale.linear(), d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);
    d3_time_scaleLocalMethods.year = function(extent, m) {
        return d3_time_scaleLinear.domain(extent.map(d3_time_scaleGetYear)).ticks(m).map(d3_time_scaleSetYear);
    };
    d3.time.scale = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
    };
    var d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function(m) {
        return [ m[0].utc, m[1] ];
    });
    var d3_time_scaleUTCFormats = [ [ d3.time.format.utc("%Y"), d3_true ], [ d3.time.format.utc("%B"), function(d) {
        return d.getUTCMonth();
    } ], [ d3.time.format.utc("%b %d"), function(d) {
        return d.getUTCDate() != 1;
    } ], [ d3.time.format.utc("%a %d"), function(d) {
        return d.getUTCDay() && d.getUTCDate() != 1;
    } ], [ d3.time.format.utc("%I %p"), function(d) {
        return d.getUTCHours();
    } ], [ d3.time.format.utc("%I:%M"), function(d) {
        return d.getUTCMinutes();
    } ], [ d3.time.format.utc(":%S"), function(d) {
        return d.getUTCSeconds();
    } ], [ d3.time.format.utc(".%L"), function(d) {
        return d.getUTCMilliseconds();
    } ] ];
    var d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);
    function d3_time_scaleUTCSetYear(y) {
        var d = new Date(Date.UTC(y, 0, 1));
        d.setUTCFullYear(y);
        return d;
    }
    function d3_time_scaleUTCGetYear(d) {
        var y = d.getUTCFullYear(), d0 = d3_time_scaleUTCSetYear(y), d1 = d3_time_scaleUTCSetYear(y + 1);
        return y + (d - d0) / (d1 - d0);
    }
    d3_time_scaleUTCMethods.year = function(extent, m) {
        return d3_time_scaleLinear.domain(extent.map(d3_time_scaleUTCGetYear)).ticks(m).map(d3_time_scaleUTCSetYear);
    };
    d3.time.scale.utc = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUTCMethods, d3_time_scaleUTCFormat);
    };
    d3.text = function() {
        return d3.xhr.apply(d3, arguments).response(d3_text);
    };
    function d3_text(request) {
        return request.responseText;
    }
    d3.json = function(url, callback) {
        return d3.xhr(url, "application/json", callback).response(d3_json);
    };
    function d3_json(request) {
        return JSON.parse(request.responseText);
    }
    d3.html = function(url, callback) {
        return d3.xhr(url, "text/html", callback).response(d3_html);
    };
    function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
    }
    d3.xml = function() {
        return d3.xhr.apply(d3, arguments).response(d3_xml);
    };
    function d3_xml(request) {
        return request.responseXML;
    }
    return d3;
}();

(function() {
    var nv = window.nv || {};
    nv.version = "0.0.1a";
    nv.dev = true;
    window.nv = nv;
    nv.tooltip = {};
    nv.utils = {};
    nv.models = {};
    nv.charts = {};
    nv.graphs = [];
    nv.logs = {};
    nv.dispatch = d3.dispatch("render_start", "render_end");
    if (nv.dev) {
        nv.dispatch.on("render_start", function(e) {
            nv.logs.startTime = +new Date();
        });
        nv.dispatch.on("render_end", function(e) {
            nv.logs.endTime = +new Date();
            nv.logs.totalTime = nv.logs.endTime - nv.logs.startTime;
            nv.log("total", nv.logs.totalTime);
        });
    }
    nv.log = function() {
        if (nv.dev && console.log && console.log.apply) console.log.apply(console, arguments); else if (nv.dev && console.log && Function.prototype.bind) {
            var log = Function.prototype.bind.call(console.log, console);
            log.apply(console, arguments);
        }
        return arguments[arguments.length - 1];
    };
    nv.render = function render(step) {
        step = step || 1;
        nv.render.active = true;
        nv.dispatch.render_start();
        setTimeout(function() {
            var chart, graph;
            for (var i = 0; i < step && (graph = nv.render.queue[i]); i++) {
                chart = graph.generate();
                if (typeof graph.callback == typeof Function) graph.callback(chart);
                nv.graphs.push(chart);
            }
            nv.render.queue.splice(0, i);
            if (nv.render.queue.length) setTimeout(arguments.callee, 0); else {
                nv.render.active = false;
                nv.dispatch.render_end();
            }
        }, 0);
    };
    nv.render.active = false;
    nv.render.queue = [];
    nv.addGraph = function(obj) {
        if (typeof arguments[0] === typeof Function) obj = {
            generate: arguments[0],
            callback: arguments[1]
        };
        nv.render.queue.push(obj);
        if (!nv.render.active) nv.render();
    };
    nv.identity = function(d) {
        return d;
    };
    nv.strip = function(s) {
        return s.replace(/(\s|&)/g, "");
    };
    function daysInMonth(month, year) {
        return new Date(year, month + 1, 0).getDate();
    }
    function d3_time_range(floor, step, number) {
        return function(t0, t1, dt) {
            var time = floor(t0), times = [];
            if (time < t0) step(time);
            if (dt > 1) {
                while (time < t1) {
                    var date = new Date(+time);
                    if (number(date) % dt === 0) times.push(date);
                    step(time);
                }
            } else {
                while (time < t1) {
                    times.push(new Date(+time));
                    step(time);
                }
            }
            return times;
        };
    }
    d3.time.monthEnd = function(date) {
        return new Date(date.getFullYear(), date.getMonth(), 0);
    };
    d3.time.monthEnds = d3_time_range(d3.time.monthEnd, function(date) {
        date.setUTCDate(date.getUTCDate() + 1);
        date.setDate(daysInMonth(date.getMonth() + 1, date.getFullYear()));
    }, function(date) {
        return date.getMonth();
    });
    (function() {
        var nvtooltip = window.nv.tooltip = {};
        nvtooltip.show = function(pos, content, gravity, dist, parentContainer, classes) {
            var container = document.createElement("div");
            container.className = "nvtooltip " + (classes ? classes : "xy-tooltip");
            gravity = gravity || "s";
            dist = dist || 20;
            var body = parentContainer;
            if (!parentContainer || parentContainer.tagName.match(/g|svg/i)) {
                body = document.getElementsByTagName("body")[0];
            }
            container.innerHTML = content;
            container.style.left = 0;
            container.style.top = 0;
            container.style.opacity = 0;
            body.appendChild(container);
            var height = parseInt(container.offsetHeight), width = parseInt(container.offsetWidth), windowWidth = nv.utils.windowSize().width, windowHeight = nv.utils.windowSize().height, scrollTop = window.scrollY, scrollLeft = window.scrollX, left, top;
            windowHeight = window.innerWidth >= document.body.scrollWidth ? windowHeight : windowHeight - 16;
            windowWidth = window.innerHeight >= document.body.scrollHeight ? windowWidth : windowWidth - 16;
            var tooltipTop = function(Elem) {
                var offsetTop = top;
                do {
                    if (!isNaN(Elem.offsetTop)) {
                        offsetTop += Elem.offsetTop;
                    }
                } while (Elem = Elem.offsetParent);
                return offsetTop;
            };
            var tooltipLeft = function(Elem) {
                var offsetLeft = left;
                do {
                    if (!isNaN(Elem.offsetLeft)) {
                        offsetLeft += Elem.offsetLeft;
                    }
                } while (Elem = Elem.offsetParent);
                return offsetLeft;
            };
            switch (gravity) {
              case "e":
                left = pos[0] - width - dist;
                top = pos[1] - height / 2;
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                if (tLeft < scrollLeft) left = pos[0] + dist > scrollLeft ? pos[0] + dist : scrollLeft - tLeft + left;
                if (tTop < scrollTop) top = scrollTop - tTop + top;
                if (tTop + height > scrollTop + windowHeight) top = scrollTop + windowHeight - tTop + top - height;
                break;

              case "w":
                left = pos[0] + dist;
                top = pos[1] - height / 2;
                if (tLeft + width > windowWidth) left = pos[0] - width - dist;
                if (tTop < scrollTop) top = scrollTop + 5;
                if (tTop + height > scrollTop + windowHeight) top = scrollTop - height - 5;
                break;

              case "n":
                left = pos[0] - width / 2 - 5;
                top = pos[1] + dist;
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                if (tLeft < scrollLeft) left = scrollLeft + 5;
                if (tLeft + width > windowWidth) left = left - width / 2 + 5;
                if (tTop + height > scrollTop + windowHeight) top = scrollTop + windowHeight - tTop + top - height;
                break;

              case "s":
                left = pos[0] - width / 2;
                top = pos[1] - height - dist;
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                if (tLeft < scrollLeft) left = scrollLeft + 5;
                if (tLeft + width > windowWidth) left = left - width / 2 + 5;
                if (scrollTop > tTop) top = scrollTop;
                break;
            }
            container.style.left = left + "px";
            container.style.top = top + "px";
            container.style.opacity = 1;
            container.style.position = "absolute";
            container.style.pointerEvents = "none";
            return container;
        };
        nvtooltip.cleanup = function() {
            var tooltips = document.getElementsByClassName("nvtooltip");
            var purging = [];
            while (tooltips.length) {
                purging.push(tooltips[0]);
                tooltips[0].style.transitionDelay = "0 !important";
                tooltips[0].style.opacity = 0;
                tooltips[0].className = "nvtooltip-pending-removal";
            }
            setTimeout(function() {
                while (purging.length) {
                    var removeMe = purging.pop();
                    removeMe.parentNode.removeChild(removeMe);
                }
            }, 500);
        };
    })();
    nv.utils.windowSize = function() {
        var size = {
            width: 640,
            height: 480
        };
        if (document.body && document.body.offsetWidth) {
            size.width = document.body.offsetWidth;
            size.height = document.body.offsetHeight;
        }
        if (document.compatMode == "CSS1Compat" && document.documentElement && document.documentElement.offsetWidth) {
            size.width = document.documentElement.offsetWidth;
            size.height = document.documentElement.offsetHeight;
        }
        if (window.innerWidth && window.innerHeight) {
            size.width = window.innerWidth;
            size.height = window.innerHeight;
        }
        return size;
    };
    nv.utils.windowResize = function(fun) {
        var oldresize = window.onresize;
        window.onresize = function(e) {
            if (typeof oldresize == "function") oldresize(e);
            fun(e);
        };
    };
    nv.utils.getColor = function(color) {
        if (!arguments.length) return nv.utils.defaultColor();
        if (Object.prototype.toString.call(color) === "[object Array]") return function(d, i) {
            return d.color || color[i % color.length];
        }; else return color;
    };
    nv.utils.defaultColor = function() {
        var colors = d3.scale.category20().range();
        return function(d, i) {
            return d.color || colors[i % colors.length];
        };
    };
    nv.utils.customTheme = function(dictionary, getKey, defaultColors) {
        getKey = getKey || function(series) {
            return series.key;
        };
        defaultColors = defaultColors || d3.scale.category20().range();
        var defIndex = defaultColors.length;
        return function(series, index) {
            var key = getKey(series);
            if (!defIndex) defIndex = defaultColors.length;
            if (typeof dictionary[key] !== "undefined") return typeof dictionary[key] === "function" ? dictionary[key]() : dictionary[key]; else return defaultColors[--defIndex];
        };
    };
    nv.utils.pjax = function(links, content) {
        d3.selectAll(links).on("click", function() {
            history.pushState(this.href, this.textContent, this.href);
            load(this.href);
            d3.event.preventDefault();
        });
        function load(href) {
            d3.html(href, function(fragment) {
                var target = d3.select(content).node();
                target.parentNode.replaceChild(d3.select(fragment).select(content).node(), target);
                nv.utils.pjax(links, content);
            });
        }
        d3.select(window).on("popstate", function() {
            if (d3.event.state) load(d3.event.state);
        });
    };
    nv.utils.calcApproxTextWidth = function(svgTextElem) {
        if (svgTextElem instanceof d3.selection) {
            var fontSize = parseInt(svgTextElem.style("font-size").replace("px", ""));
            var textLength = svgTextElem.text().length;
            return textLength * fontSize * .5;
        }
        return 0;
    };
    nv.models.axis = function() {
        var axis = d3.svg.axis();
        var margin = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, width = 75, height = 60, scale = d3.scale.linear(), axisLabelText = null, showMaxMin = true, highlightZero = true, rotateLabels = 0, rotateYLabel = true, staggerLabels = false, isOrdinal = false, ticks = null;
        axis.scale(scale).orient("bottom").tickFormat(function(d) {
            return d;
        });
        var scale0;
        function chart(selection) {
            selection.each(function(data) {
                var container = d3.select(this);
                var wrap = container.selectAll("g.nv-wrap.nv-axis").data([ data ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-axis");
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                if (ticks !== null) axis.ticks(ticks); else if (axis.orient() == "top" || axis.orient() == "bottom") axis.ticks(Math.abs(scale.range()[1] - scale.range()[0]) / 100);
                d3.transition(g).call(axis);
                scale0 = scale0 || axis.scale();
                var fmt = axis.tickFormat();
                if (fmt == null) {
                    fmt = scale0.tickFormat();
                }
                var axisLabel = g.selectAll("text.nv-axislabel").data([ axisLabelText || null ]);
                axisLabel.exit().remove();
                switch (axis.orient()) {
                  case "top":
                    axisLabel.enter().append("text").attr("class", "nv-axislabel");
                    var w = scale.range().length == 2 ? scale.range()[1] : scale.range()[scale.range().length - 1] + (scale.range()[1] - scale.range()[0]);
                    axisLabel.attr("text-anchor", "middle").attr("y", 0).attr("x", w / 2);
                    if (showMaxMin) {
                        var axisMaxMin = wrap.selectAll("g.nv-axisMaxMin").data(scale.domain());
                        axisMaxMin.enter().append("g").attr("class", "nv-axisMaxMin").append("text");
                        axisMaxMin.exit().remove();
                        axisMaxMin.attr("transform", function(d, i) {
                            return "translate(" + scale(d) + ",0)";
                        }).select("text").attr("dy", "0em").attr("y", -axis.tickPadding()).attr("text-anchor", "middle").text(function(d, i) {
                            var v = fmt(d);
                            return ("" + v).match("NaN") ? "" : v;
                        });
                        d3.transition(axisMaxMin).attr("transform", function(d, i) {
                            return "translate(" + scale.range()[i] + ",0)";
                        });
                    }
                    break;

                  case "bottom":
                    var xLabelMargin = 36;
                    var maxTextWidth = 30;
                    var xTicks = g.selectAll("g").select("text");
                    if (rotateLabels % 360) {
                        xTicks.each(function(d, i) {
                            var width = this.getBBox().width;
                            if (width > maxTextWidth) maxTextWidth = width;
                        });
                        var sin = Math.abs(Math.sin(rotateLabels * Math.PI / 180));
                        var xLabelMargin = (sin ? sin * maxTextWidth : maxTextWidth) + 30;
                        xTicks.attr("transform", function(d, i, j) {
                            return "rotate(" + rotateLabels + " 0,0)";
                        }).attr("text-anchor", rotateLabels % 360 > 0 ? "start" : "end");
                    }
                    axisLabel.enter().append("text").attr("class", "nv-axislabel");
                    var w = scale.range().length == 2 ? scale.range()[1] : scale.range()[scale.range().length - 1] + (scale.range()[1] - scale.range()[0]);
                    axisLabel.attr("text-anchor", "middle").attr("y", xLabelMargin).attr("x", w / 2);
                    if (showMaxMin) {
                        var axisMaxMin = wrap.selectAll("g.nv-axisMaxMin").data([ scale.domain()[0], scale.domain()[scale.domain().length - 1] ]);
                        axisMaxMin.enter().append("g").attr("class", "nv-axisMaxMin").append("text");
                        axisMaxMin.exit().remove();
                        axisMaxMin.attr("transform", function(d, i) {
                            return "translate(" + (scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0)) + ",0)";
                        }).select("text").attr("dy", ".71em").attr("y", axis.tickPadding()).attr("transform", function(d, i, j) {
                            return "rotate(" + rotateLabels + " 0,0)";
                        }).attr("text-anchor", rotateLabels ? rotateLabels % 360 > 0 ? "start" : "end" : "middle").text(function(d, i) {
                            var v = fmt(d);
                            return ("" + v).match("NaN") ? "" : v;
                        });
                        d3.transition(axisMaxMin).attr("transform", function(d, i) {
                            return "translate(" + (scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0)) + ",0)";
                        });
                    }
                    if (staggerLabels) xTicks.attr("transform", function(d, i) {
                        return "translate(0," + (i % 2 == 0 ? "0" : "12") + ")";
                    });
                    break;

                  case "right":
                    axisLabel.enter().append("text").attr("class", "nv-axislabel");
                    axisLabel.attr("text-anchor", rotateYLabel ? "middle" : "begin").attr("transform", rotateYLabel ? "rotate(90)" : "").attr("y", rotateYLabel ? -Math.max(margin.right, width) + 12 : -10).attr("x", rotateYLabel ? scale.range()[0] / 2 : axis.tickPadding());
                    if (showMaxMin) {
                        var axisMaxMin = wrap.selectAll("g.nv-axisMaxMin").data(scale.domain());
                        axisMaxMin.enter().append("g").attr("class", "nv-axisMaxMin").append("text").style("opacity", 0);
                        axisMaxMin.exit().remove();
                        axisMaxMin.attr("transform", function(d, i) {
                            return "translate(0," + scale(d) + ")";
                        }).select("text").attr("dy", ".32em").attr("y", 0).attr("x", axis.tickPadding()).attr("text-anchor", "start").text(function(d, i) {
                            var v = fmt(d);
                            return ("" + v).match("NaN") ? "" : v;
                        });
                        d3.transition(axisMaxMin).attr("transform", function(d, i) {
                            return "translate(0," + scale.range()[i] + ")";
                        }).select("text").style("opacity", 1);
                    }
                    break;

                  case "left":
                    axisLabel.enter().append("text").attr("class", "nv-axislabel");
                    axisLabel.attr("text-anchor", rotateYLabel ? "middle" : "end").attr("transform", rotateYLabel ? "rotate(-90)" : "").attr("y", rotateYLabel ? -Math.max(margin.left, width) + 12 : -10).attr("x", rotateYLabel ? -scale.range()[0] / 2 : -axis.tickPadding());
                    if (showMaxMin) {
                        var axisMaxMin = wrap.selectAll("g.nv-axisMaxMin").data(scale.domain());
                        axisMaxMin.enter().append("g").attr("class", "nv-axisMaxMin").append("text").style("opacity", 0);
                        axisMaxMin.exit().remove();
                        axisMaxMin.attr("transform", function(d, i) {
                            return "translate(0," + scale0(d) + ")";
                        }).select("text").attr("dy", ".32em").attr("y", 0).attr("x", -axis.tickPadding()).attr("text-anchor", "end").text(function(d, i) {
                            var v = fmt(d);
                            return ("" + v).match("NaN") ? "" : v;
                        });
                        d3.transition(axisMaxMin).attr("transform", function(d, i) {
                            return "translate(0," + scale.range()[i] + ")";
                        }).select("text").style("opacity", 1);
                    }
                    break;
                }
                axisLabel.text(function(d) {
                    return d;
                });
                if (showMaxMin && (axis.orient() === "left" || axis.orient() === "right")) {
                    g.selectAll("g").each(function(d, i) {
                        d3.select(this).select("text").attr("opacity", 1);
                        if (scale(d) < scale.range()[1] + 10 || scale(d) > scale.range()[0] - 10) {
                            if (d > 1e-10 || d < -1e-10) d3.select(this).attr("opacity", 0);
                            d3.select(this).select("text").attr("opacity", 0);
                        }
                    });
                    if (scale.domain()[0] == scale.domain()[1] && scale.domain()[0] == 0) wrap.selectAll("g.nv-axisMaxMin").style("opacity", function(d, i) {
                        return !i ? 1 : 0;
                    });
                }
                if (showMaxMin && (axis.orient() === "top" || axis.orient() === "bottom")) {
                    var maxMinRange = [];
                    wrap.selectAll("g.nv-axisMaxMin").each(function(d, i) {
                        try {
                            if (i) maxMinRange.push(scale(d) - this.getBBox().width - 4); else maxMinRange.push(scale(d) + this.getBBox().width + 4);
                        } catch (err) {
                            if (i) maxMinRange.push(scale(d) - 4); else maxMinRange.push(scale(d) + 4);
                        }
                    });
                    g.selectAll("g").each(function(d, i) {
                        if (scale(d) < maxMinRange[0] || scale(d) > maxMinRange[1]) {
                            if (d > 1e-10 || d < -1e-10) d3.select(this).remove(); else d3.select(this).select("text").remove();
                        }
                    });
                }
                if (highlightZero) g.selectAll("line.tick").filter(function(d) {
                    return !parseFloat(Math.round(d * 1e5) / 1e6);
                }).classed("zero", true);
                scale0 = scale.copy();
            });
            return chart;
        }
        chart.axis = axis;
        d3.rebind(chart, axis, "orient", "tickValues", "tickSubdivide", "tickSize", "tickPadding", "tickFormat");
        d3.rebind(chart, scale, "domain", "range", "rangeBand", "rangeBands");
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.ticks = function(_) {
            if (!arguments.length) return ticks;
            ticks = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.axisLabel = function(_) {
            if (!arguments.length) return axisLabelText;
            axisLabelText = _;
            return chart;
        };
        chart.showMaxMin = function(_) {
            if (!arguments.length) return showMaxMin;
            showMaxMin = _;
            return chart;
        };
        chart.highlightZero = function(_) {
            if (!arguments.length) return highlightZero;
            highlightZero = _;
            return chart;
        };
        chart.scale = function(_) {
            if (!arguments.length) return scale;
            scale = _;
            axis.scale(scale);
            isOrdinal = typeof scale.rangeBands === "function";
            d3.rebind(chart, scale, "domain", "range", "rangeBand", "rangeBands");
            return chart;
        };
        chart.rotateYLabel = function(_) {
            if (!arguments.length) return rotateYLabel;
            rotateYLabel = _;
            return chart;
        };
        chart.rotateLabels = function(_) {
            if (!arguments.length) return rotateLabels;
            rotateLabels = _;
            return chart;
        };
        chart.staggerLabels = function(_) {
            if (!arguments.length) return staggerLabels;
            staggerLabels = _;
            return chart;
        };
        return chart;
    };
    nv.models.historicalBar = function() {
        var margin = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, width = 960, height = 500, id = Math.floor(Math.random() * 1e4), x = d3.scale.linear(), y = d3.scale.linear(), getX = function(d) {
            return d.x;
        }, getY = function(d) {
            return d.y;
        }, forceX = [], forceY = [ 0 ], padData = false, clipEdge = true, color = nv.utils.defaultColor(), xDomain, yDomain, dispatch = d3.dispatch("chartClick", "elementClick", "elementDblClick", "elementMouseover", "elementMouseout");
        function chart(selection) {
            selection.each(function(data) {
                var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom, container = d3.select(this);
                x.domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX)));
                if (padData) x.range([ availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5) / data[0].values.length ]); else x.range([ 0, availableWidth ]);
                y.domain(yDomain || d3.extent(data[0].values.map(getY).concat(forceY))).range([ availableHeight, 0 ]);
                if (x.domain()[0] === x.domain()[1] || y.domain()[0] === y.domain()[1]) singlePoint = true;
                if (x.domain()[0] === x.domain()[1]) x.domain()[0] ? x.domain([ x.domain()[0] - x.domain()[0] * .01, x.domain()[1] + x.domain()[1] * .01 ]) : x.domain([ -1, 1 ]);
                if (y.domain()[0] === y.domain()[1]) y.domain()[0] ? y.domain([ y.domain()[0] + y.domain()[0] * .01, y.domain()[1] - y.domain()[1] * .01 ]) : y.domain([ -1, 1 ]);
                var wrap = container.selectAll("g.nv-wrap.nv-bar").data([ data[0].values ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-bar");
                var defsEnter = wrapEnter.append("defs");
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-bars");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                container.on("click", function(d, i) {
                    dispatch.chartClick({
                        data: d,
                        index: i,
                        pos: d3.event,
                        id: id
                    });
                });
                defsEnter.append("clipPath").attr("id", "nv-chart-clip-path-" + id).append("rect");
                wrap.select("#nv-chart-clip-path-" + id + " rect").attr("width", availableWidth).attr("height", availableHeight);
                g.attr("clip-path", clipEdge ? "url(#nv-chart-clip-path-" + id + ")" : "");
                var bars = wrap.select(".nv-bars").selectAll(".nv-bar").data(function(d) {
                    return d;
                });
                bars.exit().remove();
                var barsEnter = bars.enter().append("rect").attr("x", 0).attr("y", function(d, i) {
                    return y(Math.max(0, getY(d, i)));
                }).attr("height", function(d, i) {
                    return Math.abs(y(getY(d, i)) - y(0));
                }).on("mouseover", function(d, i) {
                    d3.select(this).classed("hover", true);
                    dispatch.elementMouseover({
                        point: d,
                        series: data[0],
                        pos: [ x(getX(d, i)), y(getY(d, i)) ],
                        pointIndex: i,
                        seriesIndex: 0,
                        e: d3.event
                    });
                }).on("mouseout", function(d, i) {
                    d3.select(this).classed("hover", false);
                    dispatch.elementMouseout({
                        point: d,
                        series: data[0],
                        pointIndex: i,
                        seriesIndex: 0,
                        e: d3.event
                    });
                }).on("click", function(d, i) {
                    dispatch.elementClick({
                        value: getY(d, i),
                        data: d,
                        index: i,
                        pos: [ x(getX(d, i)), y(getY(d, i)) ],
                        e: d3.event,
                        id: id
                    });
                    d3.event.stopPropagation();
                }).on("dblclick", function(d, i) {
                    dispatch.elementDblClick({
                        value: getY(d, i),
                        data: d,
                        index: i,
                        pos: [ x(getX(d, i)), y(getY(d, i)) ],
                        e: d3.event,
                        id: id
                    });
                    d3.event.stopPropagation();
                });
                bars.attr("fill", function(d, i) {
                    return color(d, i);
                }).attr("class", function(d, i, j) {
                    return (getY(d, i) < 0 ? "nv-bar negative" : "nv-bar positive") + " nv-bar-" + j + "-" + i;
                }).attr("transform", function(d, i) {
                    return "translate(" + (x(getX(d, i)) - availableWidth / data[0].values.length * .45) + ",0)";
                }).attr("width", availableWidth / data[0].values.length * .9);
                d3.transition(bars).attr("y", function(d, i) {
                    return getY(d, i) < 0 ? y(0) : y(0) - y(getY(d, i)) < 1 ? y(0) - 1 : y(getY(d, i));
                }).attr("height", function(d, i) {
                    return Math.max(Math.abs(y(getY(d, i)) - y(0)), 1);
                });
            });
            return chart;
        }
        chart.dispatch = dispatch;
        chart.x = function(_) {
            if (!arguments.length) return getX;
            getX = _;
            return chart;
        };
        chart.y = function(_) {
            if (!arguments.length) return getY;
            getY = _;
            return chart;
        };
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.xScale = function(_) {
            if (!arguments.length) return x;
            x = _;
            return chart;
        };
        chart.yScale = function(_) {
            if (!arguments.length) return y;
            y = _;
            return chart;
        };
        chart.xDomain = function(_) {
            if (!arguments.length) return xDomain;
            xDomain = _;
            return chart;
        };
        chart.yDomain = function(_) {
            if (!arguments.length) return yDomain;
            yDomain = _;
            return chart;
        };
        chart.forceX = function(_) {
            if (!arguments.length) return forceX;
            forceX = _;
            return chart;
        };
        chart.forceY = function(_) {
            if (!arguments.length) return forceY;
            forceY = _;
            return chart;
        };
        chart.padData = function(_) {
            if (!arguments.length) return padData;
            padData = _;
            return chart;
        };
        chart.clipEdge = function(_) {
            if (!arguments.length) return clipEdge;
            clipEdge = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            return chart;
        };
        chart.id = function(_) {
            if (!arguments.length) return id;
            id = _;
            return chart;
        };
        return chart;
    };
    nv.models.bullet = function() {
        var margin = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, orient = "left", reverse = false, ranges = function(d) {
            return d.ranges;
        }, markers = function(d) {
            return d.markers;
        }, measures = function(d) {
            return d.measures;
        }, forceX = [ 0 ], width = 380, height = 30, tickFormat = null, color = nv.utils.getColor([ "#1f77b4" ]), dispatch = d3.dispatch("elementMouseover", "elementMouseout");
        function chart(selection) {
            selection.each(function(d, i) {
                var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom, container = d3.select(this);
                var rangez = ranges.call(this, d, i).slice().sort(d3.descending), markerz = markers.call(this, d, i).slice().sort(d3.descending), measurez = measures.call(this, d, i).slice().sort(d3.descending);
                var x1 = d3.scale.linear().domain(d3.extent(d3.merge([ forceX, rangez ]))).range(reverse ? [ availableWidth, 0 ] : [ 0, availableWidth ]);
                var x0 = this.__chart__ || d3.scale.linear().domain([ 0, Infinity ]).range(x1.range());
                this.__chart__ = x1;
                var rangeMin = d3.min(rangez), rangeMax = d3.max(rangez), rangeAvg = rangez[1];
                var wrap = container.selectAll("g.nv-wrap.nv-bullet").data([ d ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-bullet");
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                gEnter.append("rect").attr("class", "nv-range nv-rangeMax");
                gEnter.append("rect").attr("class", "nv-range nv-rangeAvg");
                gEnter.append("rect").attr("class", "nv-range nv-rangeMin");
                gEnter.append("rect").attr("class", "nv-measure");
                gEnter.append("path").attr("class", "nv-markerTriangle");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var w0 = function(d) {
                    return Math.abs(x0(d) - x0(0));
                }, w1 = function(d) {
                    return Math.abs(x1(d) - x1(0));
                };
                var xp0 = function(d) {
                    return d < 0 ? x0(d) : x0(0);
                }, xp1 = function(d) {
                    return d < 0 ? x1(d) : x1(0);
                };
                g.select("rect.nv-rangeMax").attr("height", availableHeight).attr("width", w1(rangeMax > 0 ? rangeMax : rangeMin)).attr("x", xp1(rangeMax > 0 ? rangeMax : rangeMin)).datum(rangeMax > 0 ? rangeMax : rangeMin);
                g.select("rect.nv-rangeAvg").attr("height", availableHeight).attr("width", w1(rangeAvg)).attr("x", xp1(rangeAvg)).datum(rangeAvg);
                g.select("rect.nv-rangeMin").attr("height", availableHeight).attr("width", w1(rangeMax)).attr("x", xp1(rangeMax)).attr("width", w1(rangeMax > 0 ? rangeMin : rangeMax)).attr("x", xp1(rangeMax > 0 ? rangeMin : rangeMax)).datum(rangeMax > 0 ? rangeMin : rangeMax);
                g.select("rect.nv-measure").style("fill", color).attr("height", availableHeight / 3).attr("y", availableHeight / 3).attr("width", measurez < 0 ? x1(0) - x1(measurez[0]) : x1(measurez[0]) - x1(0)).attr("x", xp1(measurez)).on("mouseover", function() {
                    dispatch.elementMouseover({
                        value: measurez[0],
                        label: "Current",
                        pos: [ x1(measurez[0]), availableHeight / 2 ]
                    });
                }).on("mouseout", function() {
                    dispatch.elementMouseout({
                        value: measurez[0],
                        label: "Current"
                    });
                });
                var h3 = availableHeight / 6;
                if (markerz[0]) {
                    g.selectAll("path.nv-markerTriangle").attr("transform", function(d) {
                        return "translate(" + x1(markerz[0]) + "," + availableHeight / 2 + ")";
                    }).attr("d", "M0," + h3 + "L" + h3 + "," + -h3 + " " + -h3 + "," + -h3 + "Z").on("mouseover", function() {
                        dispatch.elementMouseover({
                            value: markerz[0],
                            label: "Previous",
                            pos: [ x1(markerz[0]), availableHeight / 2 ]
                        });
                    }).on("mouseout", function() {
                        dispatch.elementMouseout({
                            value: markerz[0],
                            label: "Previous"
                        });
                    });
                } else {
                    g.selectAll("path.nv-markerTriangle").remove();
                }
                wrap.selectAll(".nv-range").on("mouseover", function(d, i) {
                    var label = !i ? "Maximum" : i == 1 ? "Mean" : "Minimum";
                    dispatch.elementMouseover({
                        value: d,
                        label: label,
                        pos: [ x1(d), availableHeight / 2 ]
                    });
                }).on("mouseout", function(d, i) {
                    var label = !i ? "Maximum" : i == 1 ? "Mean" : "Minimum";
                    dispatch.elementMouseout({
                        value: d,
                        label: label
                    });
                });
            });
            return chart;
        }
        chart.dispatch = dispatch;
        chart.orient = function(_) {
            if (!arguments.length) return orient;
            orient = _;
            reverse = orient == "right" || orient == "bottom";
            return chart;
        };
        chart.ranges = function(_) {
            if (!arguments.length) return ranges;
            ranges = _;
            return chart;
        };
        chart.markers = function(_) {
            if (!arguments.length) return markers;
            markers = _;
            return chart;
        };
        chart.measures = function(_) {
            if (!arguments.length) return measures;
            measures = _;
            return chart;
        };
        chart.forceX = function(_) {
            if (!arguments.length) return forceX;
            forceX = _;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.tickFormat = function(_) {
            if (!arguments.length) return tickFormat;
            tickFormat = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            return chart;
        };
        return chart;
    };
    nv.models.bulletChart = function() {
        var bullet = nv.models.bullet();
        var orient = "left", reverse = false, margin = {
            top: 5,
            right: 40,
            bottom: 20,
            left: 120
        }, ranges = function(d) {
            return d.ranges;
        }, markers = function(d) {
            return d.markers;
        }, measures = function(d) {
            return d.measures;
        }, width = null, height = 55, tickFormat = null, tooltips = true, tooltip = function(key, x, y, e, graph) {
            return "<h3>" + x + "</h3>" + "<p>" + y + "</p>";
        }, noData = "No Data Available.", dispatch = d3.dispatch("tooltipShow", "tooltipHide");
        var showTooltip = function(e, offsetElement) {
            var left = e.pos[0] + (offsetElement.offsetLeft || 0) + margin.left, top = e.pos[1] + (offsetElement.offsetTop || 0) + margin.top, content = tooltip(e.key, e.label, e.value, e, chart);
            nv.tooltip.show([ left, top ], content, e.value < 0 ? "e" : "w", null, offsetElement);
        };
        function chart(selection) {
            selection.each(function(d, i) {
                var container = d3.select(this);
                var availableWidth = (width || parseInt(container.style("width")) || 960) - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom, that = this;
                chart.update = function() {
                    chart(selection);
                };
                chart.container = this;
                if (!d || !ranges.call(this, d, i)) {
                    var noDataText = container.selectAll(".nv-noData").data([ noData ]);
                    noDataText.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle");
                    noDataText.attr("x", margin.left + availableWidth / 2).attr("y", 18 + margin.top + availableHeight / 2).text(function(d) {
                        return d;
                    });
                    return chart;
                } else {
                    container.selectAll(".nv-noData").remove();
                }
                var rangez = ranges.call(this, d, i).slice().sort(d3.descending), markerz = markers.call(this, d, i).slice().sort(d3.descending), measurez = measures.call(this, d, i).slice().sort(d3.descending);
                var wrap = container.selectAll("g.nv-wrap.nv-bulletChart").data([ d ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-bulletChart");
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-bulletWrap");
                gEnter.append("g").attr("class", "nv-titles");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var x1 = d3.scale.linear().domain([ 0, Math.max(rangez[0], markerz[0], measurez[0]) ]).range(reverse ? [ availableWidth, 0 ] : [ 0, availableWidth ]);
                var x0 = this.__chart__ || d3.scale.linear().domain([ 0, Infinity ]).range(x1.range());
                this.__chart__ = x1;
                var w0 = function(d) {
                    return Math.abs(x0(d) - x0(0));
                }, w1 = function(d) {
                    return Math.abs(x1(d) - x1(0));
                };
                var title = gEnter.select(".nv-titles").append("g").attr("text-anchor", "end").attr("transform", "translate(-6," + (height - margin.top - margin.bottom) / 2 + ")");
                title.append("text").attr("class", "nv-title").text(function(d) {
                    return d.title;
                });
                title.append("text").attr("class", "nv-subtitle").attr("dy", "1em").text(function(d) {
                    return d.subtitle;
                });
                bullet.width(availableWidth).height(availableHeight);
                var bulletWrap = g.select(".nv-bulletWrap");
                d3.transition(bulletWrap).call(bullet);
                var format = tickFormat || x1.tickFormat(availableWidth / 100);
                var tick = g.selectAll("g.nv-tick").data(x1.ticks(availableWidth / 50), function(d) {
                    return this.textContent || format(d);
                });
                var tickEnter = tick.enter().append("g").attr("class", "nv-tick").attr("transform", function(d) {
                    return "translate(" + x0(d) + ",0)";
                }).style("opacity", 1e-6);
                tickEnter.append("line").attr("y1", availableHeight).attr("y2", availableHeight * 7 / 6);
                tickEnter.append("text").attr("text-anchor", "middle").attr("dy", "1em").attr("y", availableHeight * 7 / 6).text(format);
                var tickUpdate = d3.transition(tick).attr("transform", function(d) {
                    return "translate(" + x1(d) + ",0)";
                }).style("opacity", 1);
                tickUpdate.select("line").attr("y1", availableHeight).attr("y2", availableHeight * 7 / 6);
                tickUpdate.select("text").attr("y", availableHeight * 7 / 6);
                d3.transition(tick.exit()).attr("transform", function(d) {
                    return "translate(" + x1(d) + ",0)";
                }).style("opacity", 1e-6).remove();
                dispatch.on("tooltipShow", function(e) {
                    e.key = d.title;
                    if (tooltips) showTooltip(e, that.parentNode);
                });
            });
            d3.timer.flush();
            return chart;
        }
        bullet.dispatch.on("elementMouseover.tooltip", function(e) {
            dispatch.tooltipShow(e);
        });
        bullet.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        dispatch.on("tooltipHide", function() {
            if (tooltips) nv.tooltip.cleanup();
        });
        chart.dispatch = dispatch;
        chart.bullet = bullet;
        d3.rebind(chart, bullet, "color");
        chart.orient = function(x) {
            if (!arguments.length) return orient;
            orient = x;
            reverse = orient == "right" || orient == "bottom";
            return chart;
        };
        chart.ranges = function(x) {
            if (!arguments.length) return ranges;
            ranges = x;
            return chart;
        };
        chart.markers = function(x) {
            if (!arguments.length) return markers;
            markers = x;
            return chart;
        };
        chart.measures = function(x) {
            if (!arguments.length) return measures;
            measures = x;
            return chart;
        };
        chart.width = function(x) {
            if (!arguments.length) return width;
            width = x;
            return chart;
        };
        chart.height = function(x) {
            if (!arguments.length) return height;
            height = x;
            return chart;
        };
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.tickFormat = function(x) {
            if (!arguments.length) return tickFormat;
            tickFormat = x;
            return chart;
        };
        chart.tooltips = function(_) {
            if (!arguments.length) return tooltips;
            tooltips = _;
            return chart;
        };
        chart.tooltipContent = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.noData = function(_) {
            if (!arguments.length) return noData;
            noData = _;
            return chart;
        };
        return chart;
    };
    nv.models.cumulativeLineChart = function() {
        var lines = nv.models.line(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), legend = nv.models.legend(), controls = nv.models.legend();
        var margin = {
            top: 30,
            right: 30,
            bottom: 50,
            left: 60
        }, color = nv.utils.defaultColor(), width = null, height = null, showLegend = true, tooltips = true, showControls = true, rescaleY = true, tooltip = function(key, x, y, e, graph) {
            return "<h3>" + key + "</h3>" + "<p>" + y + " at " + x + "</p>";
        }, x, y, id = lines.id(), state = {
            index: 0,
            rescaleY: rescaleY
        }, defaultState = null, noData = "No Data Available.", average = function(d) {
            return d.average;
        }, dispatch = d3.dispatch("tooltipShow", "tooltipHide", "stateChange", "changeState");
        xAxis.orient("bottom").tickPadding(7);
        yAxis.orient("left");
        var dx = d3.scale.linear(), index = {
            i: 0,
            x: 0
        };
        var showTooltip = function(e, offsetElement) {
            var left = e.pos[0] + (offsetElement.offsetLeft || 0), top = e.pos[1] + (offsetElement.offsetTop || 0), x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)), y = yAxis.tickFormat()(lines.y()(e.point, e.pointIndex)), content = tooltip(e.series.key, x, y, e, chart);
            nv.tooltip.show([ left, top ], content, null, null, offsetElement);
        };
        function chart(selection) {
            selection.each(function(data) {
                var container = d3.select(this).classed("nv-chart-" + id, true), that = this;
                var availableWidth = (width || parseInt(container.style("width")) || 960) - margin.left - margin.right, availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                chart.update = function() {
                    chart(selection);
                };
                chart.container = this;
                state.disabled = data.map(function(d) {
                    return !!d.disabled;
                });
                if (!defaultState) {
                    var key;
                    defaultState = {};
                    for (key in state) {
                        if (state[key] instanceof Array) defaultState[key] = state[key].slice(0); else defaultState[key] = state[key];
                    }
                }
                var indexDrag = d3.behavior.drag().on("dragstart", dragStart).on("drag", dragMove).on("dragend", dragEnd);
                function dragStart(d, i) {
                    d3.select(chart.container).style("cursor", "ew-resize");
                }
                function dragMove(d, i) {
                    index.x = d3.event.x;
                    index.i = Math.round(dx.invert(index.x));
                    updateZero();
                }
                function dragEnd(d, i) {
                    d3.select(chart.container).style("cursor", "auto");
                    state.index = index.i;
                    dispatch.stateChange(state);
                }
                if (!data || !data.length || !data.filter(function(d) {
                    return d.values.length;
                }).length) {
                    var noDataText = container.selectAll(".nv-noData").data([ noData ]);
                    noDataText.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle");
                    noDataText.attr("x", margin.left + availableWidth / 2).attr("y", margin.top + availableHeight / 2).text(function(d) {
                        return d;
                    });
                    return chart;
                } else {
                    container.selectAll(".nv-noData").remove();
                }
                x = lines.xScale();
                y = lines.yScale();
                if (!rescaleY) {
                    var seriesDomains = data.filter(function(series) {
                        return !series.disabled;
                    }).map(function(series, i) {
                        var initialDomain = d3.extent(series.values, lines.y());
                        if (initialDomain[0] < -.95) initialDomain[0] = -.95;
                        return [ (initialDomain[0] - initialDomain[1]) / (1 + initialDomain[1]), (initialDomain[1] - initialDomain[0]) / (1 + initialDomain[0]) ];
                    });
                    var completeDomain = [ d3.min(seriesDomains, function(d) {
                        return d[0];
                    }), d3.max(seriesDomains, function(d) {
                        return d[1];
                    }) ];
                    lines.yDomain(completeDomain);
                } else {
                    lines.yDomain(null);
                }
                dx.domain([ 0, data[0].values.length - 1 ]).range([ 0, availableWidth ]).clamp(true);
                var data = indexify(index.i, data);
                var wrap = container.selectAll("g.nv-wrap.nv-cumulativeLine").data([ data ]);
                var gEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-cumulativeLine").append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-x nv-axis");
                gEnter.append("g").attr("class", "nv-y nv-axis");
                gEnter.append("g").attr("class", "nv-background");
                gEnter.append("g").attr("class", "nv-linesWrap");
                gEnter.append("g").attr("class", "nv-avgLinesWrap");
                gEnter.append("g").attr("class", "nv-legendWrap");
                gEnter.append("g").attr("class", "nv-controlsWrap");
                if (showLegend) {
                    legend.width(availableWidth);
                    g.select(".nv-legendWrap").datum(data).call(legend);
                    if (margin.top != legend.height()) {
                        margin.top = legend.height();
                        availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                    }
                    g.select(".nv-legendWrap").attr("transform", "translate(0," + -margin.top + ")");
                }
                if (showControls) {
                    var controlsData = [ {
                        key: "Re-scale y-axis",
                        disabled: !rescaleY
                    } ];
                    controls.width(140).color([ "#444", "#444", "#444" ]);
                    g.select(".nv-controlsWrap").datum(controlsData).attr("transform", "translate(0," + -margin.top + ")").call(controls);
                }
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var tempDisabled = data.filter(function(d) {
                    return d.tempDisabled;
                });
                wrap.select(".tempDisabled").remove();
                if (tempDisabled.length) {
                    wrap.append("text").attr("class", "tempDisabled").attr("x", availableWidth / 2).attr("y", "-.71em").style("text-anchor", "end").text(tempDisabled.map(function(d) {
                        return d.key;
                    }).join(", ") + " values cannot be calculated for this time period.");
                }
                gEnter.select(".nv-background").append("rect");
                g.select(".nv-background rect").attr("width", availableWidth).attr("height", availableHeight);
                lines.y(function(d) {
                    return d.display.y;
                }).width(availableWidth).height(availableHeight).color(data.map(function(d, i) {
                    return d.color || color(d, i);
                }).filter(function(d, i) {
                    return !data[i].disabled && !data[i].tempDisabled;
                }));
                var linesWrap = g.select(".nv-linesWrap").datum(data.filter(function(d) {
                    return !d.disabled && !d.tempDisabled;
                }));
                linesWrap.call(lines);
                data.forEach(function(d, i) {
                    d.seriesIndex = i;
                });
                var avgLineData = data.filter(function(d) {
                    return !d.disabled && !!average(d);
                });
                var avgLines = g.select(".nv-avgLinesWrap").selectAll("line").data(avgLineData, function(d) {
                    return d.key;
                });
                avgLines.enter().append("line").style("stroke-width", 2).style("stroke-dasharray", "10,10").style("stroke", function(d, i) {
                    return lines.color()(d, d.seriesIndex);
                }).attr("x1", 0).attr("x2", availableWidth).attr("y1", function(d) {
                    return y(average(d));
                }).attr("y2", function(d) {
                    return y(average(d));
                });
                avgLines.attr("x1", 0).attr("x2", availableWidth).attr("y1", function(d) {
                    return y(average(d));
                }).attr("y2", function(d) {
                    return y(average(d));
                });
                avgLines.exit().remove();
                var indexLine = linesWrap.selectAll(".nv-indexLine").data([ index ]);
                indexLine.enter().append("rect").attr("class", "nv-indexLine").attr("width", 3).attr("x", -2).attr("fill", "red").attr("fill-opacity", .5).call(indexDrag);
                indexLine.attr("transform", function(d) {
                    return "translate(" + dx(d.i) + ",0)";
                }).attr("height", availableHeight);
                xAxis.scale(x).ticks(Math.min(data[0].values.length, availableWidth / 70)).tickSize(-availableHeight, 0);
                g.select(".nv-x.nv-axis").attr("transform", "translate(0," + y.range()[0] + ")");
                d3.transition(g.select(".nv-x.nv-axis")).call(xAxis);
                yAxis.scale(y).ticks(availableHeight / 36).tickSize(-availableWidth, 0);
                d3.transition(g.select(".nv-y.nv-axis")).call(yAxis);
                function updateZero() {
                    indexLine.data([ index ]);
                    chart.update();
                }
                g.select(".nv-background rect").on("click", function() {
                    index.x = d3.mouse(this)[0];
                    index.i = Math.round(dx.invert(index.x));
                    state.index = index.i;
                    dispatch.stateChange(state);
                    updateZero();
                });
                lines.dispatch.on("elementClick", function(e) {
                    index.i = e.pointIndex;
                    index.x = dx(index.i);
                    state.index = index.i;
                    dispatch.stateChange(state);
                    updateZero();
                });
                controls.dispatch.on("legendClick", function(d, i) {
                    d.disabled = !d.disabled;
                    rescaleY = !d.disabled;
                    state.rescaleY = rescaleY;
                    dispatch.stateChange(state);
                    selection.call(chart);
                });
                legend.dispatch.on("legendClick", function(d, i) {
                    d.disabled = !d.disabled;
                    if (!data.filter(function(d) {
                        return !d.disabled;
                    }).length) {
                        data.map(function(d) {
                            d.disabled = false;
                            wrap.selectAll(".nv-series").classed("disabled", false);
                            return d;
                        });
                    }
                    state.disabled = data.map(function(d) {
                        return !!d.disabled;
                    });
                    dispatch.stateChange(state);
                    selection.call(chart);
                });
                dispatch.on("tooltipShow", function(e) {
                    if (tooltips) showTooltip(e, that.parentNode);
                });
                dispatch.on("changeState", function(e) {
                    if (typeof e.disabled !== "undefined") {
                        data.forEach(function(series, i) {
                            series.disabled = e.disabled[i];
                        });
                        state.disabled = e.disabled;
                    }
                    if (typeof e.index !== "undefined") {
                        index.i = e.index;
                        index.x = dx(index.i);
                        state.index = e.index;
                        indexLine.data([ index ]);
                    }
                    if (typeof e.rescaleY !== "undefined") {
                        rescaleY = e.rescaleY;
                    }
                    selection.call(chart);
                });
            });
            return chart;
        }
        lines.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        lines.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        dispatch.on("tooltipHide", function() {
            if (tooltips) nv.tooltip.cleanup();
        });
        chart.dispatch = dispatch;
        chart.lines = lines;
        chart.legend = legend;
        chart.xAxis = xAxis;
        chart.yAxis = yAxis;
        d3.rebind(chart, lines, "defined", "isArea", "x", "y", "size", "xDomain", "yDomain", "forceX", "forceY", "interactive", "clipEdge", "clipVoronoi", "id");
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            legend.color(color);
            return chart;
        };
        chart.rescaleY = function(_) {
            if (!arguments.length) return rescaleY;
            rescaleY = _;
            return rescaleY;
        };
        chart.showControls = function(_) {
            if (!arguments.length) return showControls;
            showControls = _;
            return chart;
        };
        chart.showLegend = function(_) {
            if (!arguments.length) return showLegend;
            showLegend = _;
            return chart;
        };
        chart.tooltips = function(_) {
            if (!arguments.length) return tooltips;
            tooltips = _;
            return chart;
        };
        chart.tooltipContent = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.state = function(_) {
            if (!arguments.length) return state;
            state = _;
            return chart;
        };
        chart.defaultState = function(_) {
            if (!arguments.length) return defaultState;
            defaultState = _;
            return chart;
        };
        chart.noData = function(_) {
            if (!arguments.length) return noData;
            noData = _;
            return chart;
        };
        chart.average = function(_) {
            if (!arguments.length) return average;
            average = _;
            return chart;
        };
        function indexify(idx, data) {
            return data.map(function(line, i) {
                if (!line.values) {
                    return line;
                }
                var v = lines.y()(line.values[idx], idx);
                if (v < -.95) {
                    line.tempDisabled = true;
                    return line;
                }
                line.tempDisabled = false;
                line.values = line.values.map(function(point, pointIndex) {
                    point.display = {
                        y: (lines.y()(point, pointIndex) - v) / (1 + v)
                    };
                    return point;
                });
                return line;
            });
        }
        return chart;
    };
    nv.models.discreteBar = function() {
        var margin = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, width = 960, height = 500, id = Math.floor(Math.random() * 1e4), x = d3.scale.ordinal(), y = d3.scale.linear(), getX = function(d) {
            return d.x;
        }, getY = function(d) {
            return d.y;
        }, forceY = [ 0 ], color = nv.utils.defaultColor(), showValues = false, valueFormat = d3.format(",.2f"), xDomain, yDomain, dispatch = d3.dispatch("chartClick", "elementClick", "elementDblClick", "elementMouseover", "elementMouseout"), rectClass = "discreteBar";
        var x0, y0;
        function chart(selection) {
            selection.each(function(data) {
                var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom, container = d3.select(this);
                data = data.map(function(series, i) {
                    series.values = series.values.map(function(point) {
                        point.series = i;
                        return point;
                    });
                    return series;
                });
                var seriesData = xDomain && yDomain ? [] : data.map(function(d) {
                    return d.values.map(function(d, i) {
                        return {
                            x: getX(d, i),
                            y: getY(d, i),
                            y0: d.y0
                        };
                    });
                });
                x.domain(xDomain || d3.merge(seriesData).map(function(d) {
                    return d.x;
                })).rangeBands([ 0, availableWidth ], .1);
                y.domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) {
                    return d.y;
                }).concat(forceY)));
                if (showValues) y.range([ availableHeight - (y.domain()[0] < 0 ? 12 : 0), y.domain()[1] > 0 ? 12 : 0 ]); else y.range([ availableHeight, 0 ]);
                x0 = x0 || x;
                y0 = y0 || y.copy().range([ y(0), y(0) ]);
                var wrap = container.selectAll("g.nv-wrap.nv-discretebar").data([ data ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-discretebar");
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-groups");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var groups = wrap.select(".nv-groups").selectAll(".nv-group").data(function(d) {
                    return d;
                }, function(d) {
                    return d.key;
                });
                groups.enter().append("g").style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6);
                d3.transition(groups.exit()).style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6).remove();
                groups.attr("class", function(d, i) {
                    return "nv-group nv-series-" + i;
                }).classed("hover", function(d) {
                    return d.hover;
                });
                d3.transition(groups).style("stroke-opacity", 1).style("fill-opacity", .75);
                var bars = groups.selectAll("g.nv-bar").data(function(d) {
                    return d.values;
                });
                bars.exit().remove();
                var barsEnter = bars.enter().append("g").attr("transform", function(d, i, j) {
                    return "translate(" + (x(getX(d, i)) + x.rangeBand() * .05) + ", " + y(0) + ")";
                }).on("mouseover", function(d, i) {
                    d3.select(this).classed("hover", true);
                    dispatch.elementMouseover({
                        value: getY(d, i),
                        point: d,
                        series: data[d.series],
                        pos: [ x(getX(d, i)) + x.rangeBand() * (d.series + .5) / data.length, y(getY(d, i)) ],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                }).on("mouseout", function(d, i) {
                    d3.select(this).classed("hover", false);
                    dispatch.elementMouseout({
                        value: getY(d, i),
                        point: d,
                        series: data[d.series],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                }).on("click", function(d, i) {
                    dispatch.elementClick({
                        value: getY(d, i),
                        point: d,
                        series: data[d.series],
                        pos: [ x(getX(d, i)) + x.rangeBand() * (d.series + .5) / data.length, y(getY(d, i)) ],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                }).on("dblclick", function(d, i) {
                    dispatch.elementDblClick({
                        value: getY(d, i),
                        point: d,
                        series: data[d.series],
                        pos: [ x(getX(d, i)) + x.rangeBand() * (d.series + .5) / data.length, y(getY(d, i)) ],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                });
                barsEnter.append("rect").attr("height", 0).attr("width", x.rangeBand() * .9 / data.length);
                if (showValues) {
                    barsEnter.append("text").attr("text-anchor", "middle");
                    bars.select("text").attr("x", x.rangeBand() * .9 / 2).attr("y", function(d, i) {
                        return getY(d, i) < 0 ? y(getY(d, i)) - y(0) + 12 : -4;
                    }).text(function(d, i) {
                        return valueFormat(getY(d, i));
                    });
                } else {
                    bars.selectAll("text").remove();
                }
                bars.attr("class", function(d, i) {
                    return getY(d, i) < 0 ? "nv-bar negative" : "nv-bar positive";
                }).style("fill", function(d, i) {
                    return d.color || color(d, i);
                }).style("stroke", function(d, i) {
                    return d.color || color(d, i);
                }).select("rect").attr("class", rectClass).attr("width", x.rangeBand() * .9 / data.length);
                d3.transition(bars).attr("transform", function(d, i) {
                    var left = x(getX(d, i)) + x.rangeBand() * .05, top = getY(d, i) < 0 ? y(0) : y(0) - y(getY(d, i)) < 1 ? y(0) - 1 : y(getY(d, i));
                    return "translate(" + left + ", " + top + ")";
                }).select("rect").attr("height", function(d, i) {
                    return Math.max(Math.abs(y(getY(d, i)) - y(0)) || 1);
                });
                x0 = x.copy();
                y0 = y.copy();
            });
            return chart;
        }
        chart.dispatch = dispatch;
        chart.x = function(_) {
            if (!arguments.length) return getX;
            getX = _;
            return chart;
        };
        chart.y = function(_) {
            if (!arguments.length) return getY;
            getY = _;
            return chart;
        };
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.xScale = function(_) {
            if (!arguments.length) return x;
            x = _;
            return chart;
        };
        chart.yScale = function(_) {
            if (!arguments.length) return y;
            y = _;
            return chart;
        };
        chart.xDomain = function(_) {
            if (!arguments.length) return xDomain;
            xDomain = _;
            return chart;
        };
        chart.yDomain = function(_) {
            if (!arguments.length) return yDomain;
            yDomain = _;
            return chart;
        };
        chart.forceY = function(_) {
            if (!arguments.length) return forceY;
            forceY = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            return chart;
        };
        chart.id = function(_) {
            if (!arguments.length) return id;
            id = _;
            return chart;
        };
        chart.showValues = function(_) {
            if (!arguments.length) return showValues;
            showValues = _;
            return chart;
        };
        chart.valueFormat = function(_) {
            if (!arguments.length) return valueFormat;
            valueFormat = _;
            return chart;
        };
        chart.rectClass = function(_) {
            if (!arguments.length) return rectClass;
            rectClass = _;
            return chart;
        };
        return chart;
    };
    nv.models.discreteBarChart = function() {
        var discretebar = nv.models.discreteBar(), xAxis = nv.models.axis(), yAxis = nv.models.axis();
        var margin = {
            top: 15,
            right: 10,
            bottom: 50,
            left: 60
        }, width = null, height = null, color = nv.utils.getColor(), staggerLabels = false, tooltips = true, tooltip = function(key, x, y, e, graph) {
            return "<h3>" + x + "</h3>" + "<p>" + y + "</p>";
        }, x, y, noData = "No Data Available.", dispatch = d3.dispatch("tooltipShow", "tooltipHide", "beforeUpdate");
        xAxis.orient("bottom").highlightZero(false).showMaxMin(false).tickFormat(function(d) {
            return d;
        });
        yAxis.orient("left").tickFormat(d3.format(",.1f"));
        var showTooltip = function(e, offsetElement) {
            var left = e.pos[0] + (offsetElement.offsetLeft || 0), top = e.pos[1] + (offsetElement.offsetTop || 0), x = xAxis.tickFormat()(discretebar.x()(e.point, e.pointIndex)), y = yAxis.tickFormat()(discretebar.y()(e.point, e.pointIndex)), content = tooltip(e.series.key, x, y, e, chart);
            nv.tooltip.show([ left, top ], content, e.value < 0 ? "n" : "s", null, offsetElement);
        };
        function chart(selection) {
            selection.each(function(data) {
                var container = d3.select(this), that = this;
                var availableWidth = (width || parseInt(container.style("width")) || 960) - margin.left - margin.right, availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                chart.update = function() {
                    dispatch.beforeUpdate();
                    selection.transition().call(chart);
                };
                chart.container = this;
                if (!data || !data.length || !data.filter(function(d) {
                    return d.values.length;
                }).length) {
                    var noDataText = container.selectAll(".nv-noData").data([ noData ]);
                    noDataText.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle");
                    noDataText.attr("x", margin.left + availableWidth / 2).attr("y", margin.top + availableHeight / 2).text(function(d) {
                        return d;
                    });
                    return chart;
                } else {
                    container.selectAll(".nv-noData").remove();
                }
                x = discretebar.xScale();
                y = discretebar.yScale();
                var wrap = container.selectAll("g.nv-wrap.nv-discreteBarWithAxes").data([ data ]);
                var gEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-discreteBarWithAxes").append("g");
                var defsEnter = gEnter.append("defs");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-x nv-axis");
                gEnter.append("g").attr("class", "nv-y nv-axis");
                gEnter.append("g").attr("class", "nv-barsWrap");
                g.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                discretebar.width(availableWidth).height(availableHeight);
                var barsWrap = g.select(".nv-barsWrap").datum(data.filter(function(d) {
                    return !d.disabled;
                }));
                d3.transition(barsWrap).call(discretebar);
                defsEnter.append("clipPath").attr("id", "nv-x-label-clip-" + discretebar.id()).append("rect");
                g.select("#nv-x-label-clip-" + discretebar.id() + " rect").attr("width", x.rangeBand() * (staggerLabels ? 2 : 1)).attr("height", 16).attr("x", -x.rangeBand() / (staggerLabels ? 1 : 2));
                xAxis.scale(x).ticks(availableWidth / 100).tickSize(-availableHeight, 0);
                g.select(".nv-x.nv-axis").attr("transform", "translate(0," + (y.range()[0] + (discretebar.showValues() && y.domain()[0] < 0 ? 16 : 0)) + ")");
                g.select(".nv-x.nv-axis").transition().duration(0).call(xAxis);
                var xTicks = g.select(".nv-x.nv-axis").selectAll("g");
                if (staggerLabels) {
                    xTicks.selectAll("text").attr("transform", function(d, i, j) {
                        return "translate(0," + (j % 2 == 0 ? "5" : "17") + ")";
                    });
                }
                yAxis.scale(y).ticks(availableHeight / 36).tickSize(-availableWidth, 0);
                d3.transition(g.select(".nv-y.nv-axis")).call(yAxis);
                dispatch.on("tooltipShow", function(e) {
                    if (tooltips) showTooltip(e, that.parentNode);
                });
            });
            return chart;
        }
        discretebar.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        discretebar.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        dispatch.on("tooltipHide", function() {
            if (tooltips) nv.tooltip.cleanup();
        });
        chart.dispatch = dispatch;
        chart.discretebar = discretebar;
        chart.xAxis = xAxis;
        chart.yAxis = yAxis;
        d3.rebind(chart, discretebar, "x", "y", "xDomain", "yDomain", "forceX", "forceY", "id", "showValues", "valueFormat");
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            discretebar.color(color);
            return chart;
        };
        chart.staggerLabels = function(_) {
            if (!arguments.length) return staggerLabels;
            staggerLabels = _;
            return chart;
        };
        chart.tooltips = function(_) {
            if (!arguments.length) return tooltips;
            tooltips = _;
            return chart;
        };
        chart.tooltipContent = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.noData = function(_) {
            if (!arguments.length) return noData;
            noData = _;
            return chart;
        };
        return chart;
    };
    nv.models.distribution = function() {
        var margin = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, width = 400, size = 8, axis = "x", getData = function(d) {
            return d[axis];
        }, color = nv.utils.defaultColor(), scale = d3.scale.linear(), domain;
        var scale0;
        function chart(selection) {
            selection.each(function(data) {
                var availableLength = width - (axis === "x" ? margin.left + margin.right : margin.top + margin.bottom), naxis = axis == "x" ? "y" : "x", container = d3.select(this);
                scale0 = scale0 || scale;
                var wrap = container.selectAll("g.nv-distribution").data([ data ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-distribution");
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var distWrap = g.selectAll("g.nv-dist").data(function(d) {
                    return d;
                }, function(d) {
                    return d.key;
                });
                distWrap.enter().append("g");
                distWrap.attr("class", function(d, i) {
                    return "nv-dist nv-series-" + i;
                }).style("stroke", function(d, i) {
                    return color(d, i);
                });
                var dist = distWrap.selectAll("line.nv-dist" + axis).data(function(d) {
                    return d.values;
                });
                dist.enter().append("line").attr(axis + "1", function(d, i) {
                    return scale0(getData(d, i));
                }).attr(axis + "2", function(d, i) {
                    return scale0(getData(d, i));
                });
                d3.transition(distWrap.exit().selectAll("line.nv-dist" + axis)).attr(axis + "1", function(d, i) {
                    return scale(getData(d, i));
                }).attr(axis + "2", function(d, i) {
                    return scale(getData(d, i));
                }).style("stroke-opacity", 0).remove();
                dist.attr("class", function(d, i) {
                    return "nv-dist" + axis + " nv-dist" + axis + "-" + i;
                }).attr(naxis + "1", 0).attr(naxis + "2", size);
                d3.transition(dist).attr(axis + "1", function(d, i) {
                    return scale(getData(d, i));
                }).attr(axis + "2", function(d, i) {
                    return scale(getData(d, i));
                });
                scale0 = scale.copy();
            });
            return chart;
        }
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.axis = function(_) {
            if (!arguments.length) return axis;
            axis = _;
            return chart;
        };
        chart.size = function(_) {
            if (!arguments.length) return size;
            size = _;
            return chart;
        };
        chart.getData = function(_) {
            if (!arguments.length) return getData;
            getData = d3.functor(_);
            return chart;
        };
        chart.scale = function(_) {
            if (!arguments.length) return scale;
            scale = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            return chart;
        };
        return chart;
    };
    nv.models.indentedTree = function() {
        var margin = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, width = 960, height = 500, color = nv.utils.defaultColor(), id = Math.floor(Math.random() * 1e4), header = true, filterZero = false, noData = "No Data Available.", childIndent = 20, columns = [ {
            key: "key",
            label: "Name",
            type: "text"
        } ], tableClass = null, iconOpen = "images/grey-plus.png", iconClose = "images/grey-minus.png", dispatch = d3.dispatch("elementClick", "elementDblclick", "elementMouseover", "elementMouseout");
        var idx = 0;
        function chart(selection) {
            selection.each(function(data) {
                var depth = 1, container = d3.select(this);
                var tree = d3.layout.tree().children(function(d) {
                    return d.values;
                }).size([ height, childIndent ]);
                chart.update = function() {
                    container.transition().duration(600).call(chart);
                };
                if (!data[0]) data[0] = {
                    key: noData
                };
                var nodes = tree.nodes(data[0]);
                var wrap = d3.select(this).selectAll("div").data([ [ nodes ] ]);
                var wrapEnter = wrap.enter().append("div").attr("class", "nvd3 nv-wrap nv-indentedtree");
                var tableEnter = wrapEnter.append("table");
                var table = wrap.select("table").attr("width", "100%").attr("class", tableClass);
                if (header) {
                    var thead = tableEnter.append("thead");
                    var theadRow1 = thead.append("tr");
                    columns.forEach(function(column) {
                        theadRow1.append("th").attr("width", column.width ? column.width : "10%").style("text-align", column.type == "numeric" ? "right" : "left").append("span").text(column.label);
                    });
                }
                var tbody = table.selectAll("tbody").data(function(d) {
                    return d;
                });
                tbody.enter().append("tbody");
                depth = d3.max(nodes, function(node) {
                    return node.depth;
                });
                tree.size([ height, depth * childIndent ]);
                var node = tbody.selectAll("tr").data(function(d) {
                    return d.filter(function(d) {
                        return filterZero && !d.children ? filterZero(d) : true;
                    });
                }, function(d, i) {
                    return d.id || d.id || ++idx;
                });
                node.exit().remove();
                node.select("img.nv-treeicon").attr("src", icon).classed("folded", folded);
                var nodeEnter = node.enter().append("tr");
                columns.forEach(function(column, index) {
                    var nodeName = nodeEnter.append("td").style("padding-left", function(d) {
                        return (index ? 0 : d.depth * childIndent + 12 + (icon(d) ? 0 : 16)) + "px";
                    }, "important").style("text-align", column.type == "numeric" ? "right" : "left");
                    if (index == 0) {
                        nodeName.append("img").classed("nv-treeicon", true).classed("nv-folded", folded).attr("src", icon).style("width", "14px").style("height", "14px").style("padding", "0 1px").style("display", function(d) {
                            return icon(d) ? "inline-block" : "none";
                        }).on("click", click);
                    }
                    nodeName.append("span").attr("class", d3.functor(column.classes)).text(function(d) {
                        return column.format ? column.format(d) : d[column.key] || "-";
                    });
                    if (column.showCount) {
                        nodeName.append("span").attr("class", "nv-childrenCount");
                        node.selectAll("span.nv-childrenCount").text(function(d) {
                            return d.values && d.values.length || d._values && d._values.length ? "(" + (d.values && d.values.filter(function(d) {
                                return filterZero ? filterZero(d) : true;
                            }).length || d._values && d._values.filter(function(d) {
                                return filterZero ? filterZero(d) : true;
                            }).length || 0) + ")" : "";
                        });
                    }
                    if (column.click) nodeName.select("span").on("click", column.click);
                });
                node.order().on("click", function(d) {
                    dispatch.elementClick({
                        row: this,
                        data: d,
                        pos: [ d.x, d.y ]
                    });
                }).on("dblclick", function(d) {
                    dispatch.elementDblclick({
                        row: this,
                        data: d,
                        pos: [ d.x, d.y ]
                    });
                }).on("mouseover", function(d) {
                    dispatch.elementMouseover({
                        row: this,
                        data: d,
                        pos: [ d.x, d.y ]
                    });
                }).on("mouseout", function(d) {
                    dispatch.elementMouseout({
                        row: this,
                        data: d,
                        pos: [ d.x, d.y ]
                    });
                });
                function click(d, _, unshift) {
                    d3.event.stopPropagation();
                    if (d3.event.shiftKey && !unshift) {
                        d3.event.shiftKey = false;
                        d.values && d.values.forEach(function(node) {
                            if (node.values || node._values) {
                                click(node, 0, true);
                            }
                        });
                        return true;
                    }
                    if (!hasChildren(d)) {
                        return true;
                    }
                    if (d.values) {
                        d._values = d.values;
                        d.values = null;
                    } else {
                        d.values = d._values;
                        d._values = null;
                    }
                    chart.update();
                }
                function icon(d) {
                    return d._values && d._values.length ? iconOpen : d.values && d.values.length ? iconClose : "";
                }
                function folded(d) {
                    return d._values && d._values.length;
                }
                function hasChildren(d) {
                    var values = d.values || d._values;
                    return values && values.length;
                }
            });
            return chart;
        }
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            scatter.color(color);
            return chart;
        };
        chart.id = function(_) {
            if (!arguments.length) return id;
            id = _;
            return chart;
        };
        chart.header = function(_) {
            if (!arguments.length) return header;
            header = _;
            return chart;
        };
        chart.noData = function(_) {
            if (!arguments.length) return noData;
            noData = _;
            return chart;
        };
        chart.filterZero = function(_) {
            if (!arguments.length) return filterZero;
            filterZero = _;
            return chart;
        };
        chart.columns = function(_) {
            if (!arguments.length) return columns;
            columns = _;
            return chart;
        };
        chart.tableClass = function(_) {
            if (!arguments.length) return tableClass;
            tableClass = _;
            return chart;
        };
        chart.iconOpen = function(_) {
            if (!arguments.length) return iconOpen;
            iconOpen = _;
            return chart;
        };
        chart.iconClose = function(_) {
            if (!arguments.length) return iconClose;
            iconClose = _;
            return chart;
        };
        return chart;
    };
    nv.models.legend = function() {
        var margin = {
            top: 5,
            right: 0,
            bottom: 5,
            left: 0
        }, width = 400, height = 20, getKey = function(d) {
            return d.key;
        }, color = nv.utils.defaultColor(), align = true, dispatch = d3.dispatch("legendClick", "legendDblclick", "legendMouseover", "legendMouseout");
        function chart(selection) {
            selection.each(function(data) {
                var availableWidth = width - margin.left - margin.right, container = d3.select(this);
                var wrap = container.selectAll("g.nv-legend").data([ data ]);
                var gEnter = wrap.enter().append("g").attr("class", "nvd3 nv-legend").append("g");
                var g = wrap.select("g");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var series = g.selectAll(".nv-series").data(function(d) {
                    return d;
                });
                var seriesEnter = series.enter().append("g").attr("class", "nv-series").on("mouseover", function(d, i) {
                    dispatch.legendMouseover(d, i);
                }).on("mouseout", function(d, i) {
                    dispatch.legendMouseout(d, i);
                }).on("click", function(d, i) {
                    dispatch.legendClick(d, i);
                }).on("dblclick", function(d, i) {
                    dispatch.legendDblclick(d, i);
                });
                seriesEnter.append("circle").style("stroke-width", 2).attr("r", 5);
                seriesEnter.append("text").attr("text-anchor", "start").attr("dy", ".32em").attr("dx", "8");
                series.classed("disabled", function(d) {
                    return d.disabled;
                });
                series.exit().remove();
                series.select("circle").style("fill", function(d, i) {
                    return d.color || color(d, i);
                }).style("stroke", function(d, i) {
                    return d.color || color(d, i);
                });
                series.select("text").text(getKey);
                if (align) {
                    var seriesWidths = [];
                    series.each(function(d, i) {
                        var legendText = d3.select(this).select("text");
                        var svgComputedTextLength = legendText.node().getComputedTextLength() || nv.utils.calcApproxTextWidth(legendText);
                        seriesWidths.push(svgComputedTextLength + 28);
                    });
                    var seriesPerRow = 0;
                    var legendWidth = 0;
                    var columnWidths = [];
                    while (legendWidth < availableWidth && seriesPerRow < seriesWidths.length) {
                        columnWidths[seriesPerRow] = seriesWidths[seriesPerRow];
                        legendWidth += seriesWidths[seriesPerRow++];
                    }
                    while (legendWidth > availableWidth && seriesPerRow > 1) {
                        columnWidths = [];
                        seriesPerRow--;
                        for (k = 0; k < seriesWidths.length; k++) {
                            if (seriesWidths[k] > (columnWidths[k % seriesPerRow] || 0)) columnWidths[k % seriesPerRow] = seriesWidths[k];
                        }
                        legendWidth = columnWidths.reduce(function(prev, cur, index, array) {
                            return prev + cur;
                        });
                    }
                    var xPositions = [];
                    for (var i = 0, curX = 0; i < seriesPerRow; i++) {
                        xPositions[i] = curX;
                        curX += columnWidths[i];
                    }
                    series.attr("transform", function(d, i) {
                        return "translate(" + xPositions[i % seriesPerRow] + "," + (5 + Math.floor(i / seriesPerRow) * 20) + ")";
                    });
                    g.attr("transform", "translate(" + (width - margin.right - legendWidth) + "," + margin.top + ")");
                    height = margin.top + margin.bottom + Math.ceil(seriesWidths.length / seriesPerRow) * 20;
                } else {
                    var ypos = 5, newxpos = 5, maxwidth = 0, xpos;
                    series.attr("transform", function(d, i) {
                        var length = d3.select(this).select("text").node().getComputedTextLength() + 28;
                        xpos = newxpos;
                        if (width < margin.left + margin.right + xpos + length) {
                            newxpos = xpos = 5;
                            ypos += 20;
                        }
                        newxpos += length;
                        if (newxpos > maxwidth) maxwidth = newxpos;
                        return "translate(" + xpos + "," + ypos + ")";
                    });
                    g.attr("transform", "translate(" + (width - margin.right - maxwidth) + "," + margin.top + ")");
                    height = margin.top + margin.bottom + ypos + 15;
                }
            });
            return chart;
        }
        chart.dispatch = dispatch;
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.key = function(_) {
            if (!arguments.length) return getKey;
            getKey = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            return chart;
        };
        chart.align = function(_) {
            if (!arguments.length) return align;
            align = _;
            return chart;
        };
        return chart;
    };
    nv.models.line = function() {
        var scatter = nv.models.scatter();
        var margin = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, width = 960, height = 500, color = nv.utils.defaultColor(), getX = function(d) {
            return d.x;
        }, getY = function(d) {
            return d.y;
        }, defined = function(d, i) {
            return !isNaN(getY(d, i)) && getY(d, i) !== null;
        }, isArea = function(d) {
            return d.area;
        }, clipEdge = false, x, y, interpolate = "linear";
        scatter.size(16).sizeDomain([ 16, 256 ]);
        var x0, y0;
        function chart(selection) {
            selection.each(function(data) {
                var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom, container = d3.select(this);
                x = scatter.xScale();
                y = scatter.yScale();
                x0 = x0 || x;
                y0 = y0 || y;
                var wrap = container.selectAll("g.nv-wrap.nv-line").data([ data ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-line");
                var defsEnter = wrapEnter.append("defs");
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-groups");
                gEnter.append("g").attr("class", "nv-scatterWrap");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                scatter.width(availableWidth).height(availableHeight);
                var scatterWrap = wrap.select(".nv-scatterWrap");
                d3.transition(scatterWrap).call(scatter);
                defsEnter.append("clipPath").attr("id", "nv-edge-clip-" + scatter.id()).append("rect");
                wrap.select("#nv-edge-clip-" + scatter.id() + " rect").attr("width", availableWidth).attr("height", availableHeight);
                g.attr("clip-path", clipEdge ? "url(#nv-edge-clip-" + scatter.id() + ")" : "");
                scatterWrap.attr("clip-path", clipEdge ? "url(#nv-edge-clip-" + scatter.id() + ")" : "");
                var groups = wrap.select(".nv-groups").selectAll(".nv-group").data(function(d) {
                    return d;
                }, function(d) {
                    return d.key;
                });
                groups.enter().append("g").style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6);
                d3.transition(groups.exit()).style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6).remove();
                groups.attr("class", function(d, i) {
                    return "nv-group nv-series-" + i;
                }).classed("hover", function(d) {
                    return d.hover;
                }).style("fill", function(d, i) {
                    return color(d, i);
                }).style("stroke", function(d, i) {
                    return color(d, i);
                });
                d3.transition(groups).style("stroke-opacity", 1).style("fill-opacity", .5);
                var areaPaths = groups.selectAll("path.nv-area").data(function(d) {
                    return isArea(d) ? [ d ] : [];
                });
                areaPaths.enter().append("path").attr("class", "nv-area").attr("d", function(d) {
                    return d3.svg.area().interpolate(interpolate).defined(defined).x(function(d, i) {
                        return x0(getX(d, i));
                    }).y0(function(d, i) {
                        return y0(getY(d, i));
                    }).y1(function(d, i) {
                        return y0(y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0]);
                    }).apply(this, [ d.values ]);
                });
                d3.transition(groups.exit().selectAll("path.nv-area")).attr("d", function(d) {
                    return d3.svg.area().interpolate(interpolate).defined(defined).x(function(d, i) {
                        return x0(getX(d, i));
                    }).y0(function(d, i) {
                        return y0(getY(d, i));
                    }).y1(function(d, i) {
                        return y0(y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0]);
                    }).apply(this, [ d.values ]);
                });
                d3.transition(areaPaths).attr("d", function(d) {
                    return d3.svg.area().interpolate(interpolate).defined(defined).x(function(d, i) {
                        return x0(getX(d, i));
                    }).y0(function(d, i) {
                        return y0(getY(d, i));
                    }).y1(function(d, i) {
                        return y0(y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0]);
                    }).apply(this, [ d.values ]);
                });
                var linePaths = groups.selectAll("path.nv-line").data(function(d) {
                    return [ d.values ];
                });
                linePaths.enter().append("path").attr("class", "nv-line").attr("d", d3.svg.line().interpolate(interpolate).defined(defined).x(function(d, i) {
                    return x0(getX(d, i));
                }).y(function(d, i) {
                    return y0(getY(d, i));
                }));
                d3.transition(groups.exit().selectAll("path.nv-line")).attr("d", d3.svg.line().interpolate(interpolate).defined(defined).x(function(d, i) {
                    return x(getX(d, i));
                }).y(function(d, i) {
                    return y(getY(d, i));
                }));
                d3.transition(linePaths).attr("d", d3.svg.line().interpolate(interpolate).defined(defined).x(function(d, i) {
                    return x(getX(d, i));
                }).y(function(d, i) {
                    return y(getY(d, i));
                }));
                x0 = x.copy();
                y0 = y.copy();
            });
            return chart;
        }
        chart.dispatch = scatter.dispatch;
        chart.scatter = scatter;
        d3.rebind(chart, scatter, "id", "interactive", "size", "xScale", "yScale", "zScale", "xDomain", "yDomain", "sizeDomain", "forceX", "forceY", "forceSize", "clipVoronoi", "clipRadius", "padData");
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.x = function(_) {
            if (!arguments.length) return getX;
            getX = _;
            scatter.x(_);
            return chart;
        };
        chart.y = function(_) {
            if (!arguments.length) return getY;
            getY = _;
            scatter.y(_);
            return chart;
        };
        chart.clipEdge = function(_) {
            if (!arguments.length) return clipEdge;
            clipEdge = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            scatter.color(color);
            return chart;
        };
        chart.interpolate = function(_) {
            if (!arguments.length) return interpolate;
            interpolate = _;
            return chart;
        };
        chart.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return chart;
        };
        chart.isArea = function(_) {
            if (!arguments.length) return isArea;
            isArea = d3.functor(_);
            return chart;
        };
        return chart;
    };
    nv.models.lineChart = function() {
        var lines = nv.models.line(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), legend = nv.models.legend();
        var margin = {
            top: 30,
            right: 20,
            bottom: 50,
            left: 60
        }, color = nv.utils.defaultColor(), width = null, height = null, showLegend = true, tooltips = true, tooltip = function(key, x, y, e, graph) {
            return "<h3>" + key + "</h3>" + "<p>" + y + " at " + x + "</p>";
        }, x, y, state = {}, defaultState = null, noData = "No Data Available.", dispatch = d3.dispatch("tooltipShow", "tooltipHide", "stateChange", "changeState");
        xAxis.orient("bottom").tickPadding(7);
        yAxis.orient("left");
        var showTooltip = function(e, offsetElement) {
            if (offsetElement) {
                var svg = d3.select(offsetElement).select("svg");
                var viewBox = svg.node() ? svg.attr("viewBox") : null;
                if (viewBox) {
                    viewBox = viewBox.split(" ");
                    var ratio = parseInt(svg.style("width")) / viewBox[2];
                    e.pos[0] = e.pos[0] * ratio;
                    e.pos[1] = e.pos[1] * ratio;
                }
            }
            var left = e.pos[0] + (offsetElement.offsetLeft || 0), top = e.pos[1] + (offsetElement.offsetTop || 0), x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)), y = yAxis.tickFormat()(lines.y()(e.point, e.pointIndex)), content = tooltip(e.series.key, x, y, e, chart);
            nv.tooltip.show([ left, top ], content, null, null, offsetElement);
        };
        function chart(selection) {
            selection.each(function(data) {
                var container = d3.select(this), that = this;
                var availableWidth = (width || parseInt(container.style("width")) || 960) - margin.left - margin.right, availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                chart.update = function() {
                    chart(selection);
                };
                chart.container = this;
                state.disabled = data.map(function(d) {
                    return !!d.disabled;
                });
                if (!defaultState) {
                    var key;
                    defaultState = {};
                    for (key in state) {
                        if (state[key] instanceof Array) defaultState[key] = state[key].slice(0); else defaultState[key] = state[key];
                    }
                }
                if (!data || !data.length || !data.filter(function(d) {
                    return d.values.length;
                }).length) {
                    var noDataText = container.selectAll(".nv-noData").data([ noData ]);
                    noDataText.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle");
                    noDataText.attr("x", margin.left + availableWidth / 2).attr("y", margin.top + availableHeight / 2).text(function(d) {
                        return d;
                    });
                    return chart;
                } else {
                    container.selectAll(".nv-noData").remove();
                }
                x = lines.xScale();
                y = lines.yScale();
                var wrap = container.selectAll("g.nv-wrap.nv-lineChart").data([ data ]);
                var gEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-lineChart").append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-x nv-axis");
                gEnter.append("g").attr("class", "nv-y nv-axis");
                gEnter.append("g").attr("class", "nv-linesWrap");
                gEnter.append("g").attr("class", "nv-legendWrap");
                if (showLegend) {
                    legend.width(availableWidth);
                    g.select(".nv-legendWrap").datum(data).call(legend);
                    if (margin.top != legend.height()) {
                        margin.top = legend.height();
                        availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                    }
                    wrap.select(".nv-legendWrap").attr("transform", "translate(0," + -margin.top + ")");
                }
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                lines.width(availableWidth).height(availableHeight).color(data.map(function(d, i) {
                    return d.color || color(d, i);
                }).filter(function(d, i) {
                    return !data[i].disabled;
                }));
                var linesWrap = g.select(".nv-linesWrap").datum(data.filter(function(d) {
                    return !d.disabled;
                }));
                d3.transition(linesWrap).call(lines);
                xAxis.scale(x).ticks(availableWidth / 100).tickSize(-availableHeight, 0);
                g.select(".nv-x.nv-axis").attr("transform", "translate(0," + y.range()[0] + ")");
                d3.transition(g.select(".nv-x.nv-axis")).call(xAxis);
                yAxis.scale(y).ticks(availableHeight / 36).tickSize(-availableWidth, 0);
                d3.transition(g.select(".nv-y.nv-axis")).call(yAxis);
                legend.dispatch.on("legendClick", function(d, i) {
                    d.disabled = !d.disabled;
                    if (!data.filter(function(d) {
                        return !d.disabled;
                    }).length) {
                        data.map(function(d) {
                            d.disabled = false;
                            wrap.selectAll(".nv-series").classed("disabled", false);
                            return d;
                        });
                    }
                    state.disabled = data.map(function(d) {
                        return !!d.disabled;
                    });
                    dispatch.stateChange(state);
                    selection.transition().call(chart);
                });
                dispatch.on("tooltipShow", function(e) {
                    if (tooltips) showTooltip(e, that.parentNode);
                });
                dispatch.on("changeState", function(e) {
                    if (typeof e.disabled !== "undefined") {
                        data.forEach(function(series, i) {
                            series.disabled = e.disabled[i];
                        });
                        state.disabled = e.disabled;
                    }
                    selection.call(chart);
                });
            });
            return chart;
        }
        lines.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        lines.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        dispatch.on("tooltipHide", function() {
            if (tooltips) nv.tooltip.cleanup();
        });
        chart.dispatch = dispatch;
        chart.lines = lines;
        chart.legend = legend;
        chart.xAxis = xAxis;
        chart.yAxis = yAxis;
        d3.rebind(chart, lines, "defined", "isArea", "x", "y", "size", "xScale", "yScale", "xDomain", "yDomain", "forceX", "forceY", "interactive", "clipEdge", "clipVoronoi", "id", "interpolate");
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            legend.color(color);
            return chart;
        };
        chart.showLegend = function(_) {
            if (!arguments.length) return showLegend;
            showLegend = _;
            return chart;
        };
        chart.tooltips = function(_) {
            if (!arguments.length) return tooltips;
            tooltips = _;
            return chart;
        };
        chart.tooltipContent = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.state = function(_) {
            if (!arguments.length) return state;
            state = _;
            return chart;
        };
        chart.defaultState = function(_) {
            if (!arguments.length) return defaultState;
            defaultState = _;
            return chart;
        };
        chart.noData = function(_) {
            if (!arguments.length) return noData;
            noData = _;
            return chart;
        };
        return chart;
    };
    nv.models.linePlusBarChart = function() {
        var lines = nv.models.line(), bars = nv.models.historicalBar(), xAxis = nv.models.axis(), y1Axis = nv.models.axis(), y2Axis = nv.models.axis(), legend = nv.models.legend();
        var margin = {
            top: 30,
            right: 60,
            bottom: 50,
            left: 60
        }, width = null, height = null, getX = function(d) {
            return d.x;
        }, getY = function(d) {
            return d.y;
        }, color = nv.utils.defaultColor(), showLegend = true, tooltips = true, tooltip = function(key, x, y, e, graph) {
            return "<h3>" + key + "</h3>" + "<p>" + y + " at " + x + "</p>";
        }, x, y1, y2, state = {}, defaultState = null, noData = "No Data Available.", dispatch = d3.dispatch("tooltipShow", "tooltipHide", "stateChange", "changeState");
        bars.padData(true);
        lines.clipEdge(false).padData(true);
        xAxis.orient("bottom").tickPadding(7).highlightZero(false);
        y1Axis.orient("left");
        y2Axis.orient("right");
        var showTooltip = function(e, offsetElement) {
            var left = e.pos[0] + (offsetElement.offsetLeft || 0), top = e.pos[1] + (offsetElement.offsetTop || 0), x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)), y = (e.series.bar ? y1Axis : y2Axis).tickFormat()(lines.y()(e.point, e.pointIndex)), content = tooltip(e.series.key, x, y, e, chart);
            nv.tooltip.show([ left, top ], content, e.value < 0 ? "n" : "s", null, offsetElement);
        };
        function chart(selection) {
            selection.each(function(data) {
                var container = d3.select(this), that = this;
                var availableWidth = (width || parseInt(container.style("width")) || 960) - margin.left - margin.right, availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                chart.update = function() {
                    chart(selection);
                };
                chart.container = this;
                state.disabled = data.map(function(d) {
                    return !!d.disabled;
                });
                if (!defaultState) {
                    var key;
                    defaultState = {};
                    for (key in state) {
                        if (state[key] instanceof Array) defaultState[key] = state[key].slice(0); else defaultState[key] = state[key];
                    }
                }
                if (!data || !data.length || !data.filter(function(d) {
                    return d.values.length;
                }).length) {
                    var noDataText = container.selectAll(".nv-noData").data([ noData ]);
                    noDataText.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle");
                    noDataText.attr("x", margin.left + availableWidth / 2).attr("y", margin.top + availableHeight / 2).text(function(d) {
                        return d;
                    });
                    return chart;
                } else {
                    container.selectAll(".nv-noData").remove();
                }
                var dataBars = data.filter(function(d) {
                    return !d.disabled && d.bar;
                });
                var dataLines = data.filter(function(d) {
                    return !d.bar;
                });
                x = dataLines.filter(function(d) {
                    return !d.disabled;
                }).length && dataLines.filter(function(d) {
                    return !d.disabled;
                })[0].values.length ? lines.xScale() : bars.xScale();
                y1 = bars.yScale();
                y2 = lines.yScale();
                var wrap = d3.select(this).selectAll("g.nv-wrap.nv-linePlusBar").data([ data ]);
                var gEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-linePlusBar").append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-x nv-axis");
                gEnter.append("g").attr("class", "nv-y1 nv-axis");
                gEnter.append("g").attr("class", "nv-y2 nv-axis");
                gEnter.append("g").attr("class", "nv-barsWrap");
                gEnter.append("g").attr("class", "nv-linesWrap");
                gEnter.append("g").attr("class", "nv-legendWrap");
                if (showLegend) {
                    legend.width(availableWidth / 2);
                    g.select(".nv-legendWrap").datum(data.map(function(series) {
                        series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;
                        series.key = series.originalKey + (series.bar ? " (left axis)" : " (right axis)");
                        return series;
                    })).call(legend);
                    if (margin.top != legend.height()) {
                        margin.top = legend.height();
                        availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                    }
                    g.select(".nv-legendWrap").attr("transform", "translate(" + availableWidth / 2 + "," + -margin.top + ")");
                }
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                lines.width(availableWidth).height(availableHeight).color(data.map(function(d, i) {
                    return d.color || color(d, i);
                }).filter(function(d, i) {
                    return !data[i].disabled && !data[i].bar;
                }));
                bars.width(availableWidth).height(availableHeight).color(data.map(function(d, i) {
                    return d.color || color(d, i);
                }).filter(function(d, i) {
                    return !data[i].disabled && data[i].bar;
                }));
                var barsWrap = g.select(".nv-barsWrap").datum(dataBars.length ? dataBars : [ {
                    values: []
                } ]);
                var linesWrap = g.select(".nv-linesWrap").datum(dataLines[0] && !dataLines[0].disabled ? dataLines : [ {
                    values: []
                } ]);
                d3.transition(barsWrap).call(bars);
                d3.transition(linesWrap).call(lines);
                xAxis.scale(x).ticks(availableWidth / 100).tickSize(-availableHeight, 0);
                g.select(".nv-x.nv-axis").attr("transform", "translate(0," + y1.range()[0] + ")");
                d3.transition(g.select(".nv-x.nv-axis")).call(xAxis);
                y1Axis.scale(y1).ticks(availableHeight / 36).tickSize(-availableWidth, 0);
                d3.transition(g.select(".nv-y1.nv-axis")).style("opacity", dataBars.length ? 1 : 0).call(y1Axis);
                y2Axis.scale(y2).ticks(availableHeight / 36).tickSize(dataBars.length ? 0 : -availableWidth, 0);
                g.select(".nv-y2.nv-axis").style("opacity", dataLines.length ? 1 : 0).attr("transform", "translate(" + availableWidth + ",0)");
                d3.transition(g.select(".nv-y2.nv-axis")).call(y2Axis);
                legend.dispatch.on("legendClick", function(d, i) {
                    d.disabled = !d.disabled;
                    if (!data.filter(function(d) {
                        return !d.disabled;
                    }).length) {
                        data.map(function(d) {
                            d.disabled = false;
                            wrap.selectAll(".nv-series").classed("disabled", false);
                            return d;
                        });
                    }
                    state.disabled = data.map(function(d) {
                        return !!d.disabled;
                    });
                    dispatch.stateChange(state);
                    selection.transition().call(chart);
                });
                dispatch.on("tooltipShow", function(e) {
                    if (tooltips) showTooltip(e, that.parentNode);
                });
                dispatch.on("changeState", function(e) {
                    if (typeof e.disabled !== "undefined") {
                        data.forEach(function(series, i) {
                            series.disabled = e.disabled[i];
                        });
                        state.disabled = e.disabled;
                    }
                    selection.call(chart);
                });
            });
            return chart;
        }
        lines.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        lines.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        bars.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        bars.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        dispatch.on("tooltipHide", function() {
            if (tooltips) nv.tooltip.cleanup();
        });
        chart.dispatch = dispatch;
        chart.legend = legend;
        chart.lines = lines;
        chart.bars = bars;
        chart.xAxis = xAxis;
        chart.y1Axis = y1Axis;
        chart.y2Axis = y2Axis;
        d3.rebind(chart, lines, "defined", "size", "clipVoronoi", "interpolate");
        chart.x = function(_) {
            if (!arguments.length) return getX;
            getX = _;
            lines.x(_);
            bars.x(_);
            return chart;
        };
        chart.y = function(_) {
            if (!arguments.length) return getY;
            getY = _;
            lines.y(_);
            bars.y(_);
            return chart;
        };
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            legend.color(color);
            return chart;
        };
        chart.showLegend = function(_) {
            if (!arguments.length) return showLegend;
            showLegend = _;
            return chart;
        };
        chart.tooltips = function(_) {
            if (!arguments.length) return tooltips;
            tooltips = _;
            return chart;
        };
        chart.tooltipContent = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.state = function(_) {
            if (!arguments.length) return state;
            state = _;
            return chart;
        };
        chart.defaultState = function(_) {
            if (!arguments.length) return defaultState;
            defaultState = _;
            return chart;
        };
        chart.noData = function(_) {
            if (!arguments.length) return noData;
            noData = _;
            return chart;
        };
        return chart;
    };
    nv.models.lineWithFocusChart = function() {
        var lines = nv.models.line(), lines2 = nv.models.line(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), x2Axis = nv.models.axis(), y2Axis = nv.models.axis(), legend = nv.models.legend(), brush = d3.svg.brush();
        var margin = {
            top: 30,
            right: 30,
            bottom: 30,
            left: 60
        }, margin2 = {
            top: 0,
            right: 30,
            bottom: 20,
            left: 60
        }, color = nv.utils.defaultColor(), width = null, height = null, height2 = 100, x, y, x2, y2, showLegend = true, brushExtent = null, tooltips = true, tooltip = function(key, x, y, e, graph) {
            return "<h3>" + key + "</h3>" + "<p>" + y + " at " + x + "</p>";
        }, noData = "No Data Available.", dispatch = d3.dispatch("tooltipShow", "tooltipHide", "brush");
        lines.clipEdge(true);
        lines2.interactive(false);
        xAxis.orient("bottom").tickPadding(5);
        yAxis.orient("left");
        x2Axis.orient("bottom").tickPadding(5);
        y2Axis.orient("left");
        var showTooltip = function(e, offsetElement) {
            var left = e.pos[0] + (offsetElement.offsetLeft || 0), top = e.pos[1] + (offsetElement.offsetTop || 0), x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)), y = yAxis.tickFormat()(lines.y()(e.point, e.pointIndex)), content = tooltip(e.series.key, x, y, e, chart);
            nv.tooltip.show([ left, top ], content, null, null, offsetElement);
        };
        function chart(selection) {
            selection.each(function(data) {
                var container = d3.select(this), that = this;
                var availableWidth = (width || parseInt(container.style("width")) || 960) - margin.left - margin.right, availableHeight1 = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom - height2, availableHeight2 = height2 - margin2.top - margin2.bottom;
                chart.update = function() {
                    chart(selection);
                };
                chart.container = this;
                if (!data || !data.length || !data.filter(function(d) {
                    return d.values.length;
                }).length) {
                    var noDataText = container.selectAll(".nv-noData").data([ noData ]);
                    noDataText.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle");
                    noDataText.attr("x", margin.left + availableWidth / 2).attr("y", margin.top + availableHeight1 / 2).text(function(d) {
                        return d;
                    });
                    return chart;
                } else {
                    container.selectAll(".nv-noData").remove();
                }
                x = lines.xScale();
                y = lines.yScale();
                x2 = lines2.xScale();
                y2 = lines2.yScale();
                var wrap = container.selectAll("g.nv-wrap.nv-lineWithFocusChart").data([ data ]);
                var gEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-lineWithFocusChart").append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-legendWrap");
                var focusEnter = gEnter.append("g").attr("class", "nv-focus");
                focusEnter.append("g").attr("class", "nv-x nv-axis");
                focusEnter.append("g").attr("class", "nv-y nv-axis");
                focusEnter.append("g").attr("class", "nv-linesWrap");
                var contextEnter = gEnter.append("g").attr("class", "nv-context");
                contextEnter.append("g").attr("class", "nv-x nv-axis");
                contextEnter.append("g").attr("class", "nv-y nv-axis");
                contextEnter.append("g").attr("class", "nv-linesWrap");
                contextEnter.append("g").attr("class", "nv-brushBackground");
                contextEnter.append("g").attr("class", "nv-x nv-brush");
                if (showLegend) {
                    legend.width(availableWidth);
                    g.select(".nv-legendWrap").datum(data).call(legend);
                    if (margin.top != legend.height()) {
                        margin.top = legend.height();
                        availableHeight1 = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom - height2;
                    }
                    g.select(".nv-legendWrap").attr("transform", "translate(0," + -margin.top + ")");
                }
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                lines.width(availableWidth).height(availableHeight1).color(data.map(function(d, i) {
                    return d.color || color(d, i);
                }).filter(function(d, i) {
                    return !data[i].disabled;
                }));
                lines2.defined(lines.defined()).width(availableWidth).height(availableHeight2).color(data.map(function(d, i) {
                    return d.color || color(d, i);
                }).filter(function(d, i) {
                    return !data[i].disabled;
                }));
                g.select(".nv-context").attr("transform", "translate(0," + (availableHeight1 + margin.bottom + margin2.top) + ")");
                var contextLinesWrap = g.select(".nv-context .nv-linesWrap").datum(data.filter(function(d) {
                    return !d.disabled;
                }));
                d3.transition(contextLinesWrap).call(lines2);
                xAxis.scale(x).ticks(availableWidth / 100).tickSize(-availableHeight1, 0);
                yAxis.scale(y).ticks(availableHeight1 / 36).tickSize(-availableWidth, 0);
                g.select(".nv-focus .nv-x.nv-axis").attr("transform", "translate(0," + availableHeight1 + ")");
                brush.x(x2).on("brush", onBrush);
                if (brushExtent) brush.extent(brushExtent);
                var brushBG = g.select(".nv-brushBackground").selectAll("g").data([ brushExtent || brush.extent() ]);
                var brushBGenter = brushBG.enter().append("g");
                brushBGenter.append("rect").attr("class", "left").attr("x", 0).attr("y", 0).attr("height", availableHeight2);
                brushBGenter.append("rect").attr("class", "right").attr("x", 0).attr("y", 0).attr("height", availableHeight2);
                gBrush = g.select(".nv-x.nv-brush").call(brush);
                gBrush.selectAll("rect").attr("height", availableHeight2);
                gBrush.selectAll(".resize").append("path").attr("d", resizePath);
                onBrush();
                x2Axis.scale(x2).ticks(availableWidth / 100).tickSize(-availableHeight2, 0);
                g.select(".nv-context .nv-x.nv-axis").attr("transform", "translate(0," + y2.range()[0] + ")");
                d3.transition(g.select(".nv-context .nv-x.nv-axis")).call(x2Axis);
                y2Axis.scale(y2).ticks(availableHeight2 / 36).tickSize(-availableWidth, 0);
                d3.transition(g.select(".nv-context .nv-y.nv-axis")).call(y2Axis);
                g.select(".nv-context .nv-x.nv-axis").attr("transform", "translate(0," + y2.range()[0] + ")");
                legend.dispatch.on("legendClick", function(d, i) {
                    d.disabled = !d.disabled;
                    if (!data.filter(function(d) {
                        return !d.disabled;
                    }).length) {
                        data.map(function(d) {
                            d.disabled = false;
                            wrap.selectAll(".nv-series").classed("disabled", false);
                            return d;
                        });
                    }
                    selection.transition().call(chart);
                });
                dispatch.on("tooltipShow", function(e) {
                    if (tooltips) showTooltip(e, that.parentNode);
                });
                function resizePath(d) {
                    var e = +(d == "e"), x = e ? 1 : -1, y = availableHeight2 / 3;
                    return "M" + .5 * x + "," + y + "A6,6 0 0 " + e + " " + 6.5 * x + "," + (y + 6) + "V" + (2 * y - 6) + "A6,6 0 0 " + e + " " + .5 * x + "," + 2 * y + "Z" + "M" + 2.5 * x + "," + (y + 8) + "V" + (2 * y - 8) + "M" + 4.5 * x + "," + (y + 8) + "V" + (2 * y - 8);
                }
                function updateBrushBG() {
                    if (!brush.empty()) brush.extent(brushExtent);
                    brushBG.data([ brush.empty() ? x2.domain() : brushExtent ]).each(function(d, i) {
                        var leftWidth = x2(d[0]) - x.range()[0], rightWidth = x.range()[1] - x2(d[1]);
                        d3.select(this).select(".left").attr("width", leftWidth < 0 ? 0 : leftWidth);
                        d3.select(this).select(".right").attr("x", x2(d[1])).attr("width", rightWidth < 0 ? 0 : rightWidth);
                    });
                }
                function onBrush() {
                    brushExtent = brush.empty() ? null : brush.extent();
                    extent = brush.empty() ? x2.domain() : brush.extent();
                    dispatch.brush({
                        extent: extent,
                        brush: brush
                    });
                    updateBrushBG();
                    var focusLinesWrap = g.select(".nv-focus .nv-linesWrap").datum(data.filter(function(d) {
                        return !d.disabled;
                    }).map(function(d, i) {
                        return {
                            key: d.key,
                            values: d.values.filter(function(d, i) {
                                return lines.x()(d, i) >= extent[0] && lines.x()(d, i) <= extent[1];
                            })
                        };
                    }));
                    d3.transition(focusLinesWrap).call(lines);
                    d3.transition(g.select(".nv-focus .nv-x.nv-axis")).call(xAxis);
                    d3.transition(g.select(".nv-focus .nv-y.nv-axis")).call(yAxis);
                }
            });
            return chart;
        }
        lines.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        lines.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        dispatch.on("tooltipHide", function() {
            if (tooltips) nv.tooltip.cleanup();
        });
        chart.dispatch = dispatch;
        chart.legend = legend;
        chart.lines = lines;
        chart.lines2 = lines2;
        chart.xAxis = xAxis;
        chart.yAxis = yAxis;
        chart.x2Axis = x2Axis;
        chart.y2Axis = y2Axis;
        d3.rebind(chart, lines, "defined", "isArea", "size", "xDomain", "yDomain", "forceX", "forceY", "interactive", "clipEdge", "clipVoronoi", "id");
        chart.x = function(_) {
            if (!arguments.length) return lines.x;
            lines.x(_);
            lines2.x(_);
            return chart;
        };
        chart.y = function(_) {
            if (!arguments.length) return lines.y;
            lines.y(_);
            lines2.y(_);
            return chart;
        };
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.margin2 = function(_) {
            if (!arguments.length) return margin2;
            margin2 = _;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.height2 = function(_) {
            if (!arguments.length) return height2;
            height2 = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            legend.color(color);
            return chart;
        };
        chart.showLegend = function(_) {
            if (!arguments.length) return showLegend;
            showLegend = _;
            return chart;
        };
        chart.tooltips = function(_) {
            if (!arguments.length) return tooltips;
            tooltips = _;
            return chart;
        };
        chart.tooltipContent = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.interpolate = function(_) {
            if (!arguments.length) return lines.interpolate();
            lines.interpolate(_);
            lines2.interpolate(_);
            return chart;
        };
        chart.noData = function(_) {
            if (!arguments.length) return noData;
            noData = _;
            return chart;
        };
        chart.xTickFormat = function(_) {
            if (!arguments.length) return xAxis.tickFormat();
            xAxis.tickFormat(_);
            x2Axis.tickFormat(_);
            return chart;
        };
        chart.yTickFormat = function(_) {
            if (!arguments.length) return yAxis.tickFormat();
            yAxis.tickFormat(_);
            y2Axis.tickFormat(_);
            return chart;
        };
        return chart;
    };
    nv.models.linePlusBarWithFocusChart = function() {
        var lines = nv.models.line(), lines2 = nv.models.line(), bars = nv.models.historicalBar(), bars2 = nv.models.historicalBar(), xAxis = nv.models.axis(), x2Axis = nv.models.axis(), y1Axis = nv.models.axis(), y2Axis = nv.models.axis(), y3Axis = nv.models.axis(), y4Axis = nv.models.axis(), legend = nv.models.legend(), brush = d3.svg.brush();
        var margin = {
            top: 30,
            right: 30,
            bottom: 30,
            left: 60
        }, margin2 = {
            top: 0,
            right: 30,
            bottom: 20,
            left: 60
        }, width = null, height = null, height2 = 100, getX = function(d) {
            return d.x;
        }, getY = function(d) {
            return d.y;
        }, color = nv.utils.defaultColor(), showLegend = true, extent, brushExtent = null, tooltips = true, tooltip = function(key, x, y, e, graph) {
            return "<h3>" + key + "</h3>" + "<p>" + y + " at " + x + "</p>";
        }, x, x2, y1, y2, y3, y4, noData = "No Data Available.", dispatch = d3.dispatch("tooltipShow", "tooltipHide", "brush");
        lines.clipEdge(true);
        lines2.interactive(false);
        xAxis.orient("bottom").tickPadding(5);
        y1Axis.orient("left");
        y2Axis.orient("right");
        x2Axis.orient("bottom").tickPadding(5);
        y3Axis.orient("left");
        y4Axis.orient("right");
        var showTooltip = function(e, offsetElement) {
            if (extent) {
                e.pointIndex += Math.ceil(extent[0]);
            }
            var left = e.pos[0] + (offsetElement.offsetLeft || 0), top = e.pos[1] + (offsetElement.offsetTop || 0), x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)), y = (e.series.bar ? y1Axis : y2Axis).tickFormat()(lines.y()(e.point, e.pointIndex)), content = tooltip(e.series.key, x, y, e, chart);
            nv.tooltip.show([ left, top ], content, e.value < 0 ? "n" : "s", null, offsetElement);
        };
        function chart(selection) {
            selection.each(function(data) {
                var container = d3.select(this), that = this;
                var availableWidth = (width || parseInt(container.style("width")) || 960) - margin.left - margin.right, availableHeight1 = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom - height2, availableHeight2 = height2 - margin2.top - margin2.bottom;
                chart.update = function() {
                    chart(selection);
                };
                chart.container = this;
                if (!data || !data.length || !data.filter(function(d) {
                    return d.values.length;
                }).length) {
                    var noDataText = container.selectAll(".nv-noData").data([ noData ]);
                    noDataText.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle");
                    noDataText.attr("x", margin.left + availableWidth / 2).attr("y", margin.top + availableHeight1 / 2).text(function(d) {
                        return d;
                    });
                    return chart;
                } else {
                    container.selectAll(".nv-noData").remove();
                }
                var dataBars = data.filter(function(d) {
                    return !d.disabled && d.bar;
                });
                var dataLines = data.filter(function(d) {
                    return !d.bar;
                });
                x = bars.xScale();
                x2 = x2Axis.scale();
                y1 = bars.yScale();
                y2 = lines.yScale();
                y3 = bars2.yScale();
                y4 = lines2.yScale();
                var series1 = data.filter(function(d) {
                    return !d.disabled && d.bar;
                }).map(function(d) {
                    return d.values.map(function(d, i) {
                        return {
                            x: getX(d, i),
                            y: getY(d, i)
                        };
                    });
                });
                var series2 = data.filter(function(d) {
                    return !d.disabled && !d.bar;
                }).map(function(d) {
                    return d.values.map(function(d, i) {
                        return {
                            x: getX(d, i),
                            y: getY(d, i)
                        };
                    });
                });
                x.range([ 0, availableWidth ]);
                x2.domain(d3.extent(d3.merge(series1.concat(series2)), function(d) {
                    return d.x;
                })).range([ 0, availableWidth ]);
                var wrap = container.selectAll("g.nv-wrap.nv-linePlusBar").data([ data ]);
                var gEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-linePlusBar").append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-legendWrap");
                var focusEnter = gEnter.append("g").attr("class", "nv-focus");
                focusEnter.append("g").attr("class", "nv-x nv-axis");
                focusEnter.append("g").attr("class", "nv-y1 nv-axis");
                focusEnter.append("g").attr("class", "nv-y2 nv-axis");
                focusEnter.append("g").attr("class", "nv-barsWrap");
                focusEnter.append("g").attr("class", "nv-linesWrap");
                var contextEnter = gEnter.append("g").attr("class", "nv-context");
                contextEnter.append("g").attr("class", "nv-x nv-axis");
                contextEnter.append("g").attr("class", "nv-y1 nv-axis");
                contextEnter.append("g").attr("class", "nv-y2 nv-axis");
                contextEnter.append("g").attr("class", "nv-barsWrap");
                contextEnter.append("g").attr("class", "nv-linesWrap");
                contextEnter.append("g").attr("class", "nv-brushBackground");
                contextEnter.append("g").attr("class", "nv-x nv-brush");
                if (showLegend) {
                    legend.width(availableWidth / 2);
                    g.select(".nv-legendWrap").datum(data.map(function(series) {
                        series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;
                        series.key = series.originalKey + (series.bar ? " (left axis)" : " (right axis)");
                        return series;
                    })).call(legend);
                    if (margin.top != legend.height()) {
                        margin.top = legend.height();
                        availableHeight1 = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom - height2;
                    }
                    g.select(".nv-legendWrap").attr("transform", "translate(" + availableWidth / 2 + "," + -margin.top + ")");
                }
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                bars2.width(availableWidth).height(availableHeight2).color(data.map(function(d, i) {
                    return d.color || color(d, i);
                }).filter(function(d, i) {
                    return !data[i].disabled && data[i].bar;
                }));
                lines2.width(availableWidth).height(availableHeight2).color(data.map(function(d, i) {
                    return d.color || color(d, i);
                }).filter(function(d, i) {
                    return !data[i].disabled && !data[i].bar;
                }));
                var bars2Wrap = g.select(".nv-context .nv-barsWrap").datum(dataBars.length ? dataBars : [ {
                    values: []
                } ]);
                var lines2Wrap = g.select(".nv-context .nv-linesWrap").datum(!dataLines[0].disabled ? dataLines : [ {
                    values: []
                } ]);
                g.select(".nv-context").attr("transform", "translate(0," + (availableHeight1 + margin.bottom + margin2.top) + ")");
                d3.transition(bars2Wrap).call(bars2);
                d3.transition(lines2Wrap).call(lines2);
                brush.x(x2).on("brush", onBrush);
                if (brushExtent) brush.extent(brushExtent);
                var brushBG = g.select(".nv-brushBackground").selectAll("g").data([ brushExtent || brush.extent() ]);
                var brushBGenter = brushBG.enter().append("g");
                brushBGenter.append("rect").attr("class", "left").attr("x", 0).attr("y", 0).attr("height", availableHeight2);
                brushBGenter.append("rect").attr("class", "right").attr("x", 0).attr("y", 0).attr("height", availableHeight2);
                var gBrush = g.select(".nv-x.nv-brush").call(brush);
                gBrush.selectAll("rect").attr("height", availableHeight2);
                gBrush.selectAll(".resize").append("path").attr("d", resizePath);
                x2Axis.ticks(availableWidth / 100).tickSize(-availableHeight2, 0);
                g.select(".nv-context .nv-x.nv-axis").attr("transform", "translate(0," + y3.range()[0] + ")");
                d3.transition(g.select(".nv-context .nv-x.nv-axis")).call(x2Axis);
                y3Axis.scale(y3).ticks(availableHeight2 / 36).tickSize(-availableWidth, 0);
                g.select(".nv-context .nv-y1.nv-axis").style("opacity", dataBars.length ? 1 : 0).attr("transform", "translate(0," + x2.range()[0] + ")");
                d3.transition(g.select(".nv-context .nv-y1.nv-axis")).call(y3Axis);
                y4Axis.scale(y4).ticks(availableHeight2 / 36).tickSize(dataBars.length ? 0 : -availableWidth, 0);
                g.select(".nv-context .nv-y2.nv-axis").style("opacity", dataLines.length ? 1 : 0).attr("transform", "translate(" + x2.range()[1] + ",0)");
                d3.transition(g.select(".nv-context .nv-y2.nv-axis")).call(y4Axis);
                legend.dispatch.on("legendClick", function(d, i) {
                    d.disabled = !d.disabled;
                    if (!data.filter(function(d) {
                        return !d.disabled;
                    }).length) {
                        data.map(function(d) {
                            d.disabled = false;
                            wrap.selectAll(".nv-series").classed("disabled", false);
                            return d;
                        });
                    }
                    selection.call(chart);
                });
                dispatch.on("tooltipShow", function(e) {
                    if (tooltips) showTooltip(e, that.parentNode);
                });
                function resizePath(d) {
                    var e = +(d == "e"), x = e ? 1 : -1, y = availableHeight2 / 3;
                    return "M" + .5 * x + "," + y + "A6,6 0 0 " + e + " " + 6.5 * x + "," + (y + 6) + "V" + (2 * y - 6) + "A6,6 0 0 " + e + " " + .5 * x + "," + 2 * y + "Z" + "M" + 2.5 * x + "," + (y + 8) + "V" + (2 * y - 8) + "M" + 4.5 * x + "," + (y + 8) + "V" + (2 * y - 8);
                }
                function updateBrushBG() {
                    if (!brush.empty()) brush.extent(brushExtent);
                    brushBG.data([ brush.empty() ? x2.domain() : brushExtent ]).each(function(d, i) {
                        var leftWidth = x2(d[0]) - x2.range()[0], rightWidth = x2.range()[1] - x2(d[1]);
                        d3.select(this).select(".left").attr("width", leftWidth < 0 ? 0 : leftWidth);
                        d3.select(this).select(".right").attr("x", x2(d[1])).attr("width", rightWidth < 0 ? 0 : rightWidth);
                    });
                }
                function onBrush() {
                    brushExtent = brush.empty() ? null : brush.extent();
                    extent = brush.empty() ? x2.domain() : brush.extent();
                    dispatch.brush({
                        extent: extent,
                        brush: brush
                    });
                    updateBrushBG();
                    bars.width(availableWidth).height(availableHeight1).color(data.map(function(d, i) {
                        return d.color || color(d, i);
                    }).filter(function(d, i) {
                        return !data[i].disabled && data[i].bar;
                    }));
                    lines.width(availableWidth).height(availableHeight1).color(data.map(function(d, i) {
                        return d.color || color(d, i);
                    }).filter(function(d, i) {
                        return !data[i].disabled && !data[i].bar;
                    }));
                    var focusBarsWrap = g.select(".nv-focus .nv-barsWrap").datum(!dataBars.length ? [ {
                        values: []
                    } ] : dataBars.map(function(d, i) {
                        return {
                            key: d.key,
                            values: d.values.filter(function(d, i) {
                                return bars.x()(d, i) >= extent[0] && bars.x()(d, i) <= extent[1];
                            })
                        };
                    }));
                    var focusLinesWrap = g.select(".nv-focus .nv-linesWrap").datum(dataLines[0].disabled ? [ {
                        values: []
                    } ] : dataLines.map(function(d, i) {
                        return {
                            key: d.key,
                            values: d.values.filter(function(d, i) {
                                return lines.x()(d, i) >= extent[0] && lines.x()(d, i) <= extent[1];
                            })
                        };
                    }));
                    if (dataBars.length) {
                        x = bars.xScale();
                    } else {
                        x = lines.xScale();
                    }
                    xAxis.scale(x).ticks(availableWidth / 100).tickSize(-availableHeight1, 0);
                    xAxis.domain([ Math.ceil(extent[0]), Math.floor(extent[1]) ]);
                    d3.transition(g.select(".nv-x.nv-axis")).call(xAxis);
                    d3.transition(focusBarsWrap).call(bars);
                    d3.transition(focusLinesWrap).call(lines);
                    g.select(".nv-focus .nv-x.nv-axis").attr("transform", "translate(0," + y1.range()[0] + ")");
                    y1Axis.scale(y1).ticks(availableHeight1 / 36).tickSize(-availableWidth, 0);
                    g.select(".nv-focus .nv-y1.nv-axis").style("opacity", dataBars.length ? 1 : 0);
                    y2Axis.scale(y2).ticks(availableHeight1 / 36).tickSize(dataBars.length ? 0 : -availableWidth, 0);
                    g.select(".nv-focus .nv-y2.nv-axis").style("opacity", dataLines.length ? 1 : 0).attr("transform", "translate(" + x.range()[1] + ",0)");
                    d3.transition(g.select(".nv-focus .nv-y1.nv-axis")).call(y1Axis);
                    d3.transition(g.select(".nv-focus .nv-y2.nv-axis")).call(y2Axis);
                }
                onBrush();
            });
            return chart;
        }
        lines.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        lines.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        bars.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        bars.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        dispatch.on("tooltipHide", function() {
            if (tooltips) nv.tooltip.cleanup();
        });
        chart.dispatch = dispatch;
        chart.legend = legend;
        chart.lines = lines;
        chart.lines2 = lines2;
        chart.bars = bars;
        chart.bars2 = bars2;
        chart.xAxis = xAxis;
        chart.x2Axis = x2Axis;
        chart.y1Axis = y1Axis;
        chart.y2Axis = y2Axis;
        chart.y3Axis = y3Axis;
        chart.y4Axis = y4Axis;
        d3.rebind(chart, lines, "defined", "size", "clipVoronoi", "interpolate");
        chart.x = function(_) {
            if (!arguments.length) return getX;
            getX = _;
            lines.x(_);
            bars.x(_);
            return chart;
        };
        chart.y = function(_) {
            if (!arguments.length) return getY;
            getY = _;
            lines.y(_);
            bars.y(_);
            return chart;
        };
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            legend.color(color);
            return chart;
        };
        chart.showLegend = function(_) {
            if (!arguments.length) return showLegend;
            showLegend = _;
            return chart;
        };
        chart.tooltips = function(_) {
            if (!arguments.length) return tooltips;
            tooltips = _;
            return chart;
        };
        chart.tooltipContent = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.noData = function(_) {
            if (!arguments.length) return noData;
            noData = _;
            return chart;
        };
        chart.brushExtent = function(_) {
            if (!arguments.length) return brushExtent;
            brushExtent = _;
            return chart;
        };
        return chart;
    };
    nv.models.multiBar = function() {
        var margin = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, width = 960, height = 500, x = d3.scale.ordinal(), y = d3.scale.linear(), id = Math.floor(Math.random() * 1e4), getX = function(d) {
            return d.x;
        }, getY = function(d) {
            return d.y;
        }, forceY = [ 0 ], clipEdge = true, stacked = false, color = nv.utils.defaultColor(), hideable = false, barColor = null, disabled, delay = 1200, xDomain, yDomain, dispatch = d3.dispatch("chartClick", "elementClick", "elementDblClick", "elementMouseover", "elementMouseout");
        var x0, y0;
        function chart(selection) {
            selection.each(function(data) {
                var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom, container = d3.select(this);
                if (hideable && data.length) hideable = [ {
                    values: data[0].values.map(function(d) {
                        return {
                            x: d.x,
                            y: 0,
                            series: d.series,
                            size: .01
                        };
                    })
                } ];
                if (stacked) data = d3.layout.stack().offset("zero").values(function(d) {
                    return d.values;
                }).y(getY)(!data.length && hideable ? hideable : data);
                data = data.map(function(series, i) {
                    series.values = series.values.map(function(point) {
                        point.series = i;
                        return point;
                    });
                    return series;
                });
                if (stacked) data[0].values.map(function(d, i) {
                    var posBase = 0, negBase = 0;
                    data.map(function(d) {
                        var f = d.values[i];
                        f.size = Math.abs(f.y);
                        if (f.y < 0) {
                            f.y1 = negBase;
                            negBase = negBase - f.size;
                        } else {
                            f.y1 = f.size + posBase;
                            posBase = posBase + f.size;
                        }
                    });
                });
                var seriesData = xDomain && yDomain ? [] : data.map(function(d) {
                    return d.values.map(function(d, i) {
                        return {
                            x: getX(d, i),
                            y: getY(d, i),
                            y0: d.y0,
                            y1: d.y1
                        };
                    });
                });
                x.domain(d3.merge(seriesData).map(function(d) {
                    return d.x;
                })).rangeBands([ 0, availableWidth ], .1);
                y.domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) {
                    return stacked ? d.y > 0 ? d.y1 : d.y1 + d.y : d.y;
                }).concat(forceY))).range([ availableHeight, 0 ]);
                if (x.domain()[0] === x.domain()[1] || y.domain()[0] === y.domain()[1]) singlePoint = true;
                if (x.domain()[0] === x.domain()[1]) x.domain()[0] ? x.domain([ x.domain()[0] - x.domain()[0] * .01, x.domain()[1] + x.domain()[1] * .01 ]) : x.domain([ -1, 1 ]);
                if (y.domain()[0] === y.domain()[1]) y.domain()[0] ? y.domain([ y.domain()[0] + y.domain()[0] * .01, y.domain()[1] - y.domain()[1] * .01 ]) : y.domain([ -1, 1 ]);
                x0 = x0 || x;
                y0 = y0 || y;
                var wrap = container.selectAll("g.nv-wrap.nv-multibar").data([ data ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-multibar");
                var defsEnter = wrapEnter.append("defs");
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-groups");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                defsEnter.append("clipPath").attr("id", "nv-edge-clip-" + id).append("rect");
                wrap.select("#nv-edge-clip-" + id + " rect").attr("width", availableWidth).attr("height", availableHeight);
                g.attr("clip-path", clipEdge ? "url(#nv-edge-clip-" + id + ")" : "");
                var groups = wrap.select(".nv-groups").selectAll(".nv-group").data(function(d) {
                    return d;
                }, function(d) {
                    return d.key;
                });
                groups.enter().append("g").style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6);
                groups.exit().selectAll("rect.nv-bar").transition().delay(function(d, i) {
                    return i * delay / data[0].values.length;
                }).attr("y", function(d) {
                    return stacked ? y0(d.y0) : y0(0);
                }).attr("height", 0).remove();
                groups.attr("class", function(d, i) {
                    return "nv-group nv-series-" + i;
                }).classed("hover", function(d) {
                    return d.hover;
                }).style("fill", function(d, i) {
                    return color(d, i);
                }).style("stroke", function(d, i) {
                    return color(d, i);
                });
                d3.transition(groups).style("stroke-opacity", 1).style("fill-opacity", .75);
                var bars = groups.selectAll("rect.nv-bar").data(function(d) {
                    return hideable && !data.length ? hideable.values : d.values;
                });
                bars.exit().remove();
                var barsEnter = bars.enter().append("rect").attr("class", function(d, i) {
                    return getY(d, i) < 0 ? "nv-bar negative" : "nv-bar positive";
                }).attr("x", function(d, i, j) {
                    return stacked ? 0 : j * x.rangeBand() / data.length;
                }).attr("y", function(d) {
                    return y0(stacked ? d.y0 : 0);
                }).attr("height", 0).attr("width", x.rangeBand() / (stacked ? 1 : data.length));
                bars.style("fill", function(d, i, j) {
                    return color(d, j, i);
                }).style("stroke", function(d, i, j) {
                    return color(d, j, i);
                }).on("mouseover", function(d, i) {
                    d3.select(this).classed("hover", true);
                    dispatch.elementMouseover({
                        value: getY(d, i),
                        point: d,
                        series: data[d.series],
                        pos: [ x(getX(d, i)) + x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length, y(getY(d, i) + (stacked ? d.y0 : 0)) ],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                }).on("mouseout", function(d, i) {
                    d3.select(this).classed("hover", false);
                    dispatch.elementMouseout({
                        value: getY(d, i),
                        point: d,
                        series: data[d.series],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                }).on("click", function(d, i) {
                    dispatch.elementClick({
                        value: getY(d, i),
                        point: d,
                        series: data[d.series],
                        pos: [ x(getX(d, i)) + x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length, y(getY(d, i) + (stacked ? d.y0 : 0)) ],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                }).on("dblclick", function(d, i) {
                    dispatch.elementDblClick({
                        value: getY(d, i),
                        point: d,
                        series: data[d.series],
                        pos: [ x(getX(d, i)) + x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length, y(getY(d, i) + (stacked ? d.y0 : 0)) ],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                });
                bars.attr("class", function(d, i) {
                    return getY(d, i) < 0 ? "nv-bar negative" : "nv-bar positive";
                }).attr("transform", function(d, i) {
                    return "translate(" + x(getX(d, i)) + ",0)";
                });
                if (barColor) {
                    if (!disabled) disabled = data.map(function() {
                        return true;
                    });
                    bars.style("fill", function(d, i, j) {
                        return d3.rgb(barColor(d, i)).darker(disabled.map(function(d, i) {
                            return i;
                        }).filter(function(d, i) {
                            return !disabled[i];
                        })[j]).toString();
                    }).style("stroke", function(d, i, j) {
                        return d3.rgb(barColor(d, i)).darker(disabled.map(function(d, i) {
                            return i;
                        }).filter(function(d, i) {
                            return !disabled[i];
                        })[j]).toString();
                    });
                }
                if (stacked) bars.transition().delay(function(d, i) {
                    return i * delay / data[0].values.length;
                }).attr("y", function(d, i) {
                    return y(stacked ? d.y1 : 0);
                }).attr("height", function(d, i) {
                    return Math.max(Math.abs(y(d.y + (stacked ? d.y0 : 0)) - y(stacked ? d.y0 : 0)), 1);
                }).each("end", function() {
                    d3.transition(d3.select(this)).attr("x", function(d, i) {
                        return stacked ? 0 : d.series * x.rangeBand() / data.length;
                    }).attr("width", x.rangeBand() / (stacked ? 1 : data.length));
                }); else d3.transition(bars).delay(function(d, i) {
                    return i * delay / data[0].values.length;
                }).attr("x", function(d, i) {
                    return d.series * x.rangeBand() / data.length;
                }).attr("width", x.rangeBand() / data.length).each("end", function() {
                    d3.transition(d3.select(this)).attr("y", function(d, i) {
                        return getY(d, i) < 0 ? y(0) : y(0) - y(getY(d, i)) < 1 ? y(0) - 1 : y(getY(d, i)) || 0;
                    }).attr("height", function(d, i) {
                        return Math.max(Math.abs(y(getY(d, i)) - y(0)), 1) || 0;
                    });
                });
                x0 = x.copy();
                y0 = y.copy();
            });
            return chart;
        }
        chart.dispatch = dispatch;
        chart.x = function(_) {
            if (!arguments.length) return getX;
            getX = _;
            return chart;
        };
        chart.y = function(_) {
            if (!arguments.length) return getY;
            getY = _;
            return chart;
        };
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.xScale = function(_) {
            if (!arguments.length) return x;
            x = _;
            return chart;
        };
        chart.yScale = function(_) {
            if (!arguments.length) return y;
            y = _;
            return chart;
        };
        chart.xDomain = function(_) {
            if (!arguments.length) return xDomain;
            xDomain = _;
            return chart;
        };
        chart.yDomain = function(_) {
            if (!arguments.length) return yDomain;
            yDomain = _;
            return chart;
        };
        chart.forceY = function(_) {
            if (!arguments.length) return forceY;
            forceY = _;
            return chart;
        };
        chart.stacked = function(_) {
            if (!arguments.length) return stacked;
            stacked = _;
            return chart;
        };
        chart.clipEdge = function(_) {
            if (!arguments.length) return clipEdge;
            clipEdge = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            return chart;
        };
        chart.barColor = function(_) {
            if (!arguments.length) return barColor;
            barColor = nv.utils.getColor(_);
            return chart;
        };
        chart.disabled = function(_) {
            if (!arguments.length) return disabled;
            disabled = _;
            return chart;
        };
        chart.id = function(_) {
            if (!arguments.length) return id;
            id = _;
            return chart;
        };
        chart.hideable = function(_) {
            if (!arguments.length) return hideable;
            hideable = _;
            return chart;
        };
        chart.delay = function(_) {
            if (!arguments.length) return delay;
            delay = _;
            return chart;
        };
        return chart;
    };
    nv.models.multiBarChart = function() {
        var multibar = nv.models.multiBar(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), legend = nv.models.legend(), controls = nv.models.legend();
        var margin = {
            top: 30,
            right: 20,
            bottom: 50,
            left: 60
        }, width = null, height = null, color = nv.utils.defaultColor(), showControls = true, showLegend = true, reduceXTicks = true, staggerLabels = false, rotateLabels = 0, tooltips = true, tooltip = function(key, x, y, e, graph) {
            return "<h3>" + key + "</h3>" + "<p>" + y + " on " + x + "</p>";
        }, x, y, state = {
            stacked: false
        }, defaultState = null, noData = "No Data Available.", dispatch = d3.dispatch("tooltipShow", "tooltipHide", "stateChange", "changeState"), controlWidth = function() {
            return showControls ? 180 : 0;
        };
        multibar.stacked(false);
        xAxis.orient("bottom").tickPadding(7).highlightZero(false).showMaxMin(false).tickFormat(function(d) {
            return d;
        });
        yAxis.orient("left").tickFormat(d3.format(",.1f"));
        var showTooltip = function(e, offsetElement) {
            var left = e.pos[0] + (offsetElement.offsetLeft || 0), top = e.pos[1] + (offsetElement.offsetTop || 0), x = xAxis.tickFormat()(multibar.x()(e.point, e.pointIndex)), y = yAxis.tickFormat()(multibar.y()(e.point, e.pointIndex)), content = tooltip(e.series.key, x, y, e, chart);
            nv.tooltip.show([ left, top ], content, e.value < 0 ? "n" : "s", null, offsetElement);
        };
        function chart(selection) {
            selection.each(function(data) {
                var container = d3.select(this), that = this;
                var availableWidth = (width || parseInt(container.style("width")) || 960) - margin.left - margin.right, availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                chart.update = function() {
                    selection.transition().call(chart);
                };
                chart.container = this;
                state.disabled = data.map(function(d) {
                    return !!d.disabled;
                });
                if (!defaultState) {
                    var key;
                    defaultState = {};
                    for (key in state) {
                        if (state[key] instanceof Array) defaultState[key] = state[key].slice(0); else defaultState[key] = state[key];
                    }
                }
                if (!data || !data.length || !data.filter(function(d) {
                    return d.values.length;
                }).length) {
                    var noDataText = container.selectAll(".nv-noData").data([ noData ]);
                    noDataText.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle");
                    noDataText.attr("x", margin.left + availableWidth / 2).attr("y", margin.top + availableHeight / 2).text(function(d) {
                        return d;
                    });
                    return chart;
                } else {
                    container.selectAll(".nv-noData").remove();
                }
                x = multibar.xScale();
                y = multibar.yScale();
                var wrap = container.selectAll("g.nv-wrap.nv-multiBarWithLegend").data([ data ]);
                var gEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-multiBarWithLegend").append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-x nv-axis");
                gEnter.append("g").attr("class", "nv-y nv-axis");
                gEnter.append("g").attr("class", "nv-barsWrap");
                gEnter.append("g").attr("class", "nv-legendWrap");
                gEnter.append("g").attr("class", "nv-controlsWrap");
                if (showLegend) {
                    legend.width(availableWidth - controlWidth());
                    if (multibar.barColor()) data.forEach(function(series, i) {
                        series.color = d3.rgb("#ccc").darker(i * 1.5).toString();
                    });
                    g.select(".nv-legendWrap").datum(data).call(legend);
                    if (margin.top != legend.height()) {
                        margin.top = legend.height();
                        availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                    }
                    g.select(".nv-legendWrap").attr("transform", "translate(" + controlWidth() + "," + -margin.top + ")");
                }
                if (showControls) {
                    var controlsData = [ {
                        key: "Grouped",
                        disabled: multibar.stacked()
                    }, {
                        key: "Stacked",
                        disabled: !multibar.stacked()
                    } ];
                    controls.width(controlWidth()).color([ "#444", "#444", "#444" ]);
                    g.select(".nv-controlsWrap").datum(controlsData).attr("transform", "translate(0," + -margin.top + ")").call(controls);
                }
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                multibar.disabled(data.map(function(series) {
                    return series.disabled;
                })).width(availableWidth).height(availableHeight).color(data.map(function(d, i) {
                    return d.color || color(d, i);
                }).filter(function(d, i) {
                    return !data[i].disabled;
                }));
                var barsWrap = g.select(".nv-barsWrap").datum(data.filter(function(d) {
                    return !d.disabled;
                }));
                d3.transition(barsWrap).call(multibar);
                xAxis.scale(x).ticks(availableWidth / 100).tickSize(-availableHeight, 0);
                g.select(".nv-x.nv-axis").attr("transform", "translate(0," + y.range()[0] + ")");
                d3.transition(g.select(".nv-x.nv-axis")).call(xAxis);
                var xTicks = g.select(".nv-x.nv-axis > g").selectAll("g");
                xTicks.selectAll("line, text").style("opacity", 1);
                if (staggerLabels) {
                    var getTranslate = function(x, y) {
                        return "translate(" + x + "," + y + ")";
                    };
                    var staggerUp = 5, staggerDown = 17;
                    xTicks.selectAll("text").attr("transform", function(d, i, j) {
                        return getTranslate(0, j % 2 == 0 ? staggerUp : staggerDown);
                    });
                    var totalInBetweenTicks = d3.selectAll(".nv-x.nv-axis .nv-wrap g g text")[0].length;
                    g.selectAll(".nv-x.nv-axis .nv-axisMaxMin text").attr("transform", function(d, i) {
                        return getTranslate(0, i === 0 || totalInBetweenTicks % 2 !== 0 ? staggerDown : staggerUp);
                    });
                }
                if (reduceXTicks) xTicks.filter(function(d, i) {
                    return i % Math.ceil(data[0].values.length / (availableWidth / 100)) !== 0;
                }).selectAll("text, line").style("opacity", 0);
                if (rotateLabels) xTicks.selectAll("text").attr("transform", "rotate(" + rotateLabels + " 0,0)").attr("text-anchor", rotateLabels > 0 ? "start" : "end");
                g.select(".nv-x.nv-axis").selectAll("g.nv-axisMaxMin text").style("opacity", 1);
                yAxis.scale(y).ticks(availableHeight / 36).tickSize(-availableWidth, 0);
                d3.transition(g.select(".nv-y.nv-axis")).call(yAxis);
                legend.dispatch.on("legendClick", function(d, i) {
                    d.disabled = !d.disabled;
                    if (!data.filter(function(d) {
                        return !d.disabled;
                    }).length) {
                        data.map(function(d) {
                            d.disabled = false;
                            wrap.selectAll(".nv-series").classed("disabled", false);
                            return d;
                        });
                    }
                    state.disabled = data.map(function(d) {
                        return !!d.disabled;
                    });
                    dispatch.stateChange(state);
                    selection.transition().call(chart);
                });
                controls.dispatch.on("legendClick", function(d, i) {
                    if (!d.disabled) return;
                    controlsData = controlsData.map(function(s) {
                        s.disabled = true;
                        return s;
                    });
                    d.disabled = false;
                    switch (d.key) {
                      case "Grouped":
                        multibar.stacked(false);
                        break;

                      case "Stacked":
                        multibar.stacked(true);
                        break;
                    }
                    state.stacked = multibar.stacked();
                    dispatch.stateChange(state);
                    selection.transition().call(chart);
                });
                dispatch.on("tooltipShow", function(e) {
                    if (tooltips) showTooltip(e, that.parentNode);
                });
                dispatch.on("changeState", function(e) {
                    if (typeof e.disabled !== "undefined") {
                        data.forEach(function(series, i) {
                            series.disabled = e.disabled[i];
                        });
                        state.disabled = e.disabled;
                    }
                    if (typeof e.stacked !== "undefined") {
                        multibar.stacked(e.stacked);
                        state.stacked = e.stacked;
                    }
                    selection.call(chart);
                });
            });
            return chart;
        }
        multibar.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        multibar.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        dispatch.on("tooltipHide", function() {
            if (tooltips) nv.tooltip.cleanup();
        });
        chart.dispatch = dispatch;
        chart.multibar = multibar;
        chart.legend = legend;
        chart.xAxis = xAxis;
        chart.yAxis = yAxis;
        d3.rebind(chart, multibar, "x", "y", "xDomain", "yDomain", "forceX", "forceY", "clipEdge", "id", "stacked", "delay", "barColor");
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            legend.color(color);
            return chart;
        };
        chart.showControls = function(_) {
            if (!arguments.length) return showControls;
            showControls = _;
            return chart;
        };
        chart.showLegend = function(_) {
            if (!arguments.length) return showLegend;
            showLegend = _;
            return chart;
        };
        chart.reduceXTicks = function(_) {
            if (!arguments.length) return reduceXTicks;
            reduceXTicks = _;
            return chart;
        };
        chart.rotateLabels = function(_) {
            if (!arguments.length) return rotateLabels;
            rotateLabels = _;
            return chart;
        };
        chart.staggerLabels = function(_) {
            if (!arguments.length) return staggerLabels;
            staggerLabels = _;
            return chart;
        };
        chart.tooltip = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.tooltips = function(_) {
            if (!arguments.length) return tooltips;
            tooltips = _;
            return chart;
        };
        chart.tooltipContent = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.state = function(_) {
            if (!arguments.length) return state;
            state = _;
            return chart;
        };
        chart.defaultState = function(_) {
            if (!arguments.length) return defaultState;
            defaultState = _;
            return chart;
        };
        chart.noData = function(_) {
            if (!arguments.length) return noData;
            noData = _;
            return chart;
        };
        return chart;
    };
    nv.models.multiBarHorizontal = function() {
        var margin = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, width = 960, height = 500, id = Math.floor(Math.random() * 1e4), x = d3.scale.ordinal(), y = d3.scale.linear(), getX = function(d) {
            return d.x;
        }, getY = function(d) {
            return d.y;
        }, forceY = [ 0 ], color = nv.utils.defaultColor(), barColor = null, disabled, stacked = false, showValues = false, valuePadding = 60, valueFormat = d3.format(",.2f"), delay = 1200, xDomain, yDomain, dispatch = d3.dispatch("chartClick", "elementClick", "elementDblClick", "elementMouseover", "elementMouseout");
        var x0, y0;
        function chart(selection) {
            selection.each(function(data) {
                var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom, container = d3.select(this);
                if (stacked) data = d3.layout.stack().offset("zero").values(function(d) {
                    return d.values;
                }).y(getY)(data);
                data = data.map(function(series, i) {
                    series.values = series.values.map(function(point) {
                        point.series = i;
                        return point;
                    });
                    return series;
                });
                if (stacked) data[0].values.map(function(d, i) {
                    var posBase = 0, negBase = 0;
                    data.map(function(d) {
                        var f = d.values[i];
                        f.size = Math.abs(f.y);
                        if (f.y < 0) {
                            f.y1 = negBase - f.size;
                            negBase = negBase - f.size;
                        } else {
                            f.y1 = posBase;
                            posBase = posBase + f.size;
                        }
                    });
                });
                var seriesData = xDomain && yDomain ? [] : data.map(function(d) {
                    return d.values.map(function(d, i) {
                        return {
                            x: getX(d, i),
                            y: getY(d, i),
                            y0: d.y0,
                            y1: d.y1
                        };
                    });
                });
                x.domain(xDomain || d3.merge(seriesData).map(function(d) {
                    return d.x;
                })).rangeBands([ 0, availableHeight ], .1);
                y.domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) {
                    return stacked ? d.y > 0 ? d.y1 + d.y : d.y1 : d.y;
                }).concat(forceY)));
                if (showValues && !stacked) y.range([ y.domain()[0] < 0 ? valuePadding : 0, availableWidth - (y.domain()[1] > 0 ? valuePadding : 0) ]); else y.range([ 0, availableWidth ]);
                x0 = x0 || x;
                y0 = y0 || d3.scale.linear().domain(y.domain()).range([ y(0), y(0) ]);
                var wrap = d3.select(this).selectAll("g.nv-wrap.nv-multibarHorizontal").data([ data ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-multibarHorizontal");
                var defsEnter = wrapEnter.append("defs");
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-groups");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var groups = wrap.select(".nv-groups").selectAll(".nv-group").data(function(d) {
                    return d;
                }, function(d) {
                    return d.key;
                });
                groups.enter().append("g").style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6);
                d3.transition(groups.exit()).style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6).remove();
                groups.attr("class", function(d, i) {
                    return "nv-group nv-series-" + i;
                }).classed("hover", function(d) {
                    return d.hover;
                }).style("fill", function(d, i) {
                    return color(d, i);
                }).style("stroke", function(d, i) {
                    return color(d, i);
                });
                d3.transition(groups).style("stroke-opacity", 1).style("fill-opacity", .75);
                var bars = groups.selectAll("g.nv-bar").data(function(d) {
                    return d.values;
                });
                bars.exit().remove();
                var barsEnter = bars.enter().append("g").attr("transform", function(d, i, j) {
                    return "translate(" + y0(stacked ? d.y0 : 0) + "," + (stacked ? 0 : j * x.rangeBand() / data.length + x(getX(d, i))) + ")";
                });
                barsEnter.append("rect").attr("width", 0).attr("height", x.rangeBand() / (stacked ? 1 : data.length));
                bars.on("mouseover", function(d, i) {
                    d3.select(this).classed("hover", true);
                    dispatch.elementMouseover({
                        value: getY(d, i),
                        point: d,
                        series: data[d.series],
                        pos: [ y(getY(d, i) + (stacked ? d.y0 : 0)), x(getX(d, i)) + x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length ],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                }).on("mouseout", function(d, i) {
                    d3.select(this).classed("hover", false);
                    dispatch.elementMouseout({
                        value: getY(d, i),
                        point: d,
                        series: data[d.series],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                }).on("click", function(d, i) {
                    dispatch.elementClick({
                        value: getY(d, i),
                        point: d,
                        series: data[d.series],
                        pos: [ x(getX(d, i)) + x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length, y(getY(d, i) + (stacked ? d.y0 : 0)) ],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                }).on("dblclick", function(d, i) {
                    dispatch.elementDblClick({
                        value: getY(d, i),
                        point: d,
                        series: data[d.series],
                        pos: [ x(getX(d, i)) + x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length, y(getY(d, i) + (stacked ? d.y0 : 0)) ],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                });
                barsEnter.append("text");
                if (showValues && !stacked) {
                    bars.select("text").attr("text-anchor", function(d, i) {
                        return getY(d, i) < 0 ? "end" : "start";
                    }).attr("y", x.rangeBand() / (data.length * 2)).attr("dy", ".32em").text(function(d, i) {
                        return valueFormat(getY(d, i));
                    });
                    d3.transition(bars).select("text").attr("x", function(d, i) {
                        return getY(d, i) < 0 ? -4 : y(getY(d, i)) - y(0) + 4;
                    });
                } else {
                    bars.selectAll("text").text("");
                }
                bars.attr("class", function(d, i) {
                    return getY(d, i) < 0 ? "nv-bar negative" : "nv-bar positive";
                });
                if (barColor) {
                    if (!disabled) disabled = data.map(function() {
                        return true;
                    });
                    bars.style("fill", function(d, i, j) {
                        return d3.rgb(barColor(d, i)).darker(disabled.map(function(d, i) {
                            return i;
                        }).filter(function(d, i) {
                            return !disabled[i];
                        })[j]).toString();
                    }).style("stroke", function(d, i, j) {
                        return d3.rgb(barColor(d, i)).darker(disabled.map(function(d, i) {
                            return i;
                        }).filter(function(d, i) {
                            return !disabled[i];
                        })[j]).toString();
                    });
                }
                if (stacked) d3.transition(bars).attr("transform", function(d, i) {
                    return "translate(" + y(d.y1) + "," + x(getX(d, i)) + ")";
                }).select("rect").attr("width", function(d, i) {
                    return Math.abs(y(getY(d, i) + d.y0) - y(d.y0));
                }).attr("height", x.rangeBand()); else d3.transition(bars).attr("transform", function(d, i) {
                    return "translate(" + (getY(d, i) < 0 ? y(getY(d, i)) : y(0)) + "," + (d.series * x.rangeBand() / data.length + x(getX(d, i))) + ")";
                }).select("rect").attr("height", x.rangeBand() / data.length).attr("width", function(d, i) {
                    return Math.max(Math.abs(y(getY(d, i)) - y(0)), 1);
                });
                x0 = x.copy();
                y0 = y.copy();
            });
            return chart;
        }
        chart.dispatch = dispatch;
        chart.x = function(_) {
            if (!arguments.length) return getX;
            getX = _;
            return chart;
        };
        chart.y = function(_) {
            if (!arguments.length) return getY;
            getY = _;
            return chart;
        };
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.xScale = function(_) {
            if (!arguments.length) return x;
            x = _;
            return chart;
        };
        chart.yScale = function(_) {
            if (!arguments.length) return y;
            y = _;
            return chart;
        };
        chart.xDomain = function(_) {
            if (!arguments.length) return xDomain;
            xDomain = _;
            return chart;
        };
        chart.yDomain = function(_) {
            if (!arguments.length) return yDomain;
            yDomain = _;
            return chart;
        };
        chart.forceY = function(_) {
            if (!arguments.length) return forceY;
            forceY = _;
            return chart;
        };
        chart.stacked = function(_) {
            if (!arguments.length) return stacked;
            stacked = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            return chart;
        };
        chart.barColor = function(_) {
            if (!arguments.length) return barColor;
            barColor = nv.utils.getColor(_);
            return chart;
        };
        chart.disabled = function(_) {
            if (!arguments.length) return disabled;
            disabled = _;
            return chart;
        };
        chart.id = function(_) {
            if (!arguments.length) return id;
            id = _;
            return chart;
        };
        chart.delay = function(_) {
            if (!arguments.length) return delay;
            delay = _;
            return chart;
        };
        chart.showValues = function(_) {
            if (!arguments.length) return showValues;
            showValues = _;
            return chart;
        };
        chart.valueFormat = function(_) {
            if (!arguments.length) return valueFormat;
            valueFormat = _;
            return chart;
        };
        chart.valuePadding = function(_) {
            if (!arguments.length) return valuePadding;
            valuePadding = _;
            return chart;
        };
        return chart;
    };
    nv.models.multiBarHorizontalChart = function() {
        var multibar = nv.models.multiBarHorizontal(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), legend = nv.models.legend().height(30), controls = nv.models.legend().height(30);
        var margin = {
            top: 30,
            right: 20,
            bottom: 50,
            left: 60
        }, width = null, height = null, color = nv.utils.defaultColor(), showControls = true, showLegend = true, stacked = false, tooltips = true, tooltip = function(key, x, y, e, graph) {
            return "<h3>" + key + " - " + x + "</h3>" + "<p>" + y + "</p>";
        }, x, y, state = {
            stacked: stacked
        }, defaultState = null, noData = "No Data Available.", dispatch = d3.dispatch("tooltipShow", "tooltipHide", "stateChange", "changeState"), controlWidth = function() {
            return showControls ? 180 : 0;
        };
        multibar.stacked(stacked);
        xAxis.orient("left").tickPadding(5).highlightZero(false).showMaxMin(false).tickFormat(function(d) {
            return d;
        });
        yAxis.orient("bottom").tickFormat(d3.format(",.1f"));
        var showTooltip = function(e, offsetElement) {
            var left = e.pos[0] + (offsetElement.offsetLeft || 0), top = e.pos[1] + (offsetElement.offsetTop || 0), x = xAxis.tickFormat()(multibar.x()(e.point, e.pointIndex)), y = yAxis.tickFormat()(multibar.y()(e.point, e.pointIndex)), content = tooltip(e.series.key, x, y, e, chart);
            nv.tooltip.show([ left, top ], content, e.value < 0 ? "e" : "w", null, offsetElement);
        };
        function chart(selection) {
            selection.each(function(data) {
                var container = d3.select(this), that = this;
                var availableWidth = (width || parseInt(container.style("width")) || 960) - margin.left - margin.right, availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                chart.update = function() {
                    selection.transition().call(chart);
                };
                chart.container = this;
                state.disabled = data.map(function(d) {
                    return !!d.disabled;
                });
                if (!defaultState) {
                    var key;
                    defaultState = {};
                    for (key in state) {
                        if (state[key] instanceof Array) defaultState[key] = state[key].slice(0); else defaultState[key] = state[key];
                    }
                }
                if (!data || !data.length || !data.filter(function(d) {
                    return d.values.length;
                }).length) {
                    var noDataText = container.selectAll(".nv-noData").data([ noData ]);
                    noDataText.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle");
                    noDataText.attr("x", margin.left + availableWidth / 2).attr("y", margin.top + availableHeight / 2).text(function(d) {
                        return d;
                    });
                    return chart;
                } else {
                    container.selectAll(".nv-noData").remove();
                }
                x = multibar.xScale();
                y = multibar.yScale();
                var wrap = container.selectAll("g.nv-wrap.nv-multiBarHorizontalChart").data([ data ]);
                var gEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-multiBarHorizontalChart").append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-x nv-axis");
                gEnter.append("g").attr("class", "nv-y nv-axis");
                gEnter.append("g").attr("class", "nv-barsWrap");
                gEnter.append("g").attr("class", "nv-legendWrap");
                gEnter.append("g").attr("class", "nv-controlsWrap");
                if (showLegend) {
                    legend.width(availableWidth - controlWidth());
                    if (multibar.barColor()) data.forEach(function(series, i) {
                        series.color = d3.rgb("#ccc").darker(i * 1.5).toString();
                    });
                    g.select(".nv-legendWrap").datum(data).call(legend);
                    if (margin.top != legend.height()) {
                        margin.top = legend.height();
                        availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                    }
                    g.select(".nv-legendWrap").attr("transform", "translate(" + controlWidth() + "," + -margin.top + ")");
                }
                if (showControls) {
                    var controlsData = [ {
                        key: "Grouped",
                        disabled: multibar.stacked()
                    }, {
                        key: "Stacked",
                        disabled: !multibar.stacked()
                    } ];
                    controls.width(controlWidth()).color([ "#444", "#444", "#444" ]);
                    g.select(".nv-controlsWrap").datum(controlsData).attr("transform", "translate(0," + -margin.top + ")").call(controls);
                }
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                multibar.disabled(data.map(function(series) {
                    return series.disabled;
                })).width(availableWidth).height(availableHeight).color(data.map(function(d, i) {
                    return d.color || color(d, i);
                }).filter(function(d, i) {
                    return !data[i].disabled;
                }));
                var barsWrap = g.select(".nv-barsWrap").datum(data.filter(function(d) {
                    return !d.disabled;
                }));
                d3.transition(barsWrap).call(multibar);
                xAxis.scale(x).ticks(availableHeight / 24).tickSize(-availableWidth, 0);
                d3.transition(g.select(".nv-x.nv-axis")).call(xAxis);
                var xTicks = g.select(".nv-x.nv-axis").selectAll("g");
                xTicks.selectAll("line, text").style("opacity", 1);
                yAxis.scale(y).ticks(availableWidth / 100).tickSize(-availableHeight, 0);
                g.select(".nv-y.nv-axis").attr("transform", "translate(0," + availableHeight + ")");
                d3.transition(g.select(".nv-y.nv-axis")).call(yAxis);
                legend.dispatch.on("legendClick", function(d, i) {
                    d.disabled = !d.disabled;
                    if (!data.filter(function(d) {
                        return !d.disabled;
                    }).length) {
                        data.map(function(d) {
                            d.disabled = false;
                            wrap.selectAll(".nv-series").classed("disabled", false);
                            return d;
                        });
                    }
                    state.disabled = data.map(function(d) {
                        return !!d.disabled;
                    });
                    dispatch.stateChange(state);
                    selection.transition().call(chart);
                });
                controls.dispatch.on("legendClick", function(d, i) {
                    if (!d.disabled) return;
                    controlsData = controlsData.map(function(s) {
                        s.disabled = true;
                        return s;
                    });
                    d.disabled = false;
                    switch (d.key) {
                      case "Grouped":
                        multibar.stacked(false);
                        break;

                      case "Stacked":
                        multibar.stacked(true);
                        break;
                    }
                    state.stacked = multibar.stacked();
                    dispatch.stateChange(state);
                    selection.transition().call(chart);
                });
                dispatch.on("tooltipShow", function(e) {
                    if (tooltips) showTooltip(e, that.parentNode);
                });
                dispatch.on("changeState", function(e) {
                    if (typeof e.disabled !== "undefined") {
                        data.forEach(function(series, i) {
                            series.disabled = e.disabled[i];
                        });
                        state.disabled = e.disabled;
                    }
                    if (typeof e.stacked !== "undefined") {
                        multibar.stacked(e.stacked);
                        state.stacked = e.stacked;
                    }
                    selection.call(chart);
                });
            });
            return chart;
        }
        multibar.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        multibar.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        dispatch.on("tooltipHide", function() {
            if (tooltips) nv.tooltip.cleanup();
        });
        chart.dispatch = dispatch;
        chart.multibar = multibar;
        chart.legend = legend;
        chart.xAxis = xAxis;
        chart.yAxis = yAxis;
        d3.rebind(chart, multibar, "x", "y", "xDomain", "yDomain", "forceX", "forceY", "clipEdge", "id", "delay", "showValues", "valueFormat", "stacked", "barColor");
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            legend.color(color);
            return chart;
        };
        chart.showControls = function(_) {
            if (!arguments.length) return showControls;
            showControls = _;
            return chart;
        };
        chart.showLegend = function(_) {
            if (!arguments.length) return showLegend;
            showLegend = _;
            return chart;
        };
        chart.tooltip = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.tooltips = function(_) {
            if (!arguments.length) return tooltips;
            tooltips = _;
            return chart;
        };
        chart.tooltipContent = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.state = function(_) {
            if (!arguments.length) return state;
            state = _;
            return chart;
        };
        chart.defaultState = function(_) {
            if (!arguments.length) return defaultState;
            defaultState = _;
            return chart;
        };
        chart.noData = function(_) {
            if (!arguments.length) return noData;
            noData = _;
            return chart;
        };
        return chart;
    };
    nv.models.multiChart = function() {
        var margin = {
            top: 30,
            right: 20,
            bottom: 50,
            left: 60
        }, color = d3.scale.category20().range(), width = null, height = null, showLegend = true, tooltips = true, tooltip = function(key, x, y, e, graph) {
            return "<h3>" + key + "</h3>" + "<p>" + y + " at " + x + "</p>";
        }, x, y;
        var x = d3.scale.linear(), yScale1 = d3.scale.linear(), yScale2 = d3.scale.linear(), lines1 = nv.models.line().yScale(yScale1), lines2 = nv.models.line().yScale(yScale2), bars1 = nv.models.multiBar().stacked(false).yScale(yScale1), bars2 = nv.models.multiBar().stacked(false).yScale(yScale2), stack1 = nv.models.stackedArea().yScale(yScale1), stack2 = nv.models.stackedArea().yScale(yScale2), xAxis = nv.models.axis().scale(x).orient("bottom").tickPadding(5), yAxis1 = nv.models.axis().scale(yScale1).orient("left"), yAxis2 = nv.models.axis().scale(yScale2).orient("right"), legend = nv.models.legend().height(30), dispatch = d3.dispatch("tooltipShow", "tooltipHide");
        var showTooltip = function(e, offsetElement) {
            var left = e.pos[0] + (offsetElement.offsetLeft || 0), top = e.pos[1] + (offsetElement.offsetTop || 0), x = xAxis.tickFormat()(lines1.x()(e.point, e.pointIndex)), y = (e.series.yAxis == 2 ? yAxis2 : yAxis1).tickFormat()(lines1.y()(e.point, e.pointIndex)), content = tooltip(e.series.key, x, y, e, chart);
            nv.tooltip.show([ left, top ], content, undefined, undefined, offsetElement.offsetParent);
        };
        function chart(selection) {
            selection.each(function(data) {
                var container = d3.select(this), that = this;
                var availableWidth = (width || parseInt(container.style("width")) || 960) - margin.left - margin.right, availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                var dataLines1 = data.filter(function(d) {
                    return !d.disabled && d.type == "line" && d.yAxis == 1;
                });
                var dataLines2 = data.filter(function(d) {
                    return !d.disabled && d.type == "line" && d.yAxis == 2;
                });
                var dataBars1 = data.filter(function(d) {
                    return !d.disabled && d.type == "bar" && d.yAxis == 1;
                });
                var dataBars2 = data.filter(function(d) {
                    return !d.disabled && d.type == "bar" && d.yAxis == 2;
                });
                var dataStack1 = data.filter(function(d) {
                    return !d.disabled && d.type == "area" && d.yAxis == 1;
                });
                var dataStack2 = data.filter(function(d) {
                    return !d.disabled && d.type == "area" && d.yAxis == 2;
                });
                var series1 = data.filter(function(d) {
                    return !d.disabled && d.yAxis == 1;
                }).map(function(d) {
                    return d.values.map(function(d, i) {
                        return {
                            x: d.x,
                            y: d.y
                        };
                    });
                });
                var series2 = data.filter(function(d) {
                    return !d.disabled && d.yAxis == 2;
                }).map(function(d) {
                    return d.values.map(function(d, i) {
                        return {
                            x: d.x,
                            y: d.y
                        };
                    });
                });
                x.domain(d3.extent(d3.merge(series1.concat(series2)), function(d) {
                    return d.x;
                })).range([ 0, availableWidth ]);
                var wrap = container.selectAll("g.wrap.multiChart").data([ data ]);
                var gEnter = wrap.enter().append("g").attr("class", "wrap nvd3 multiChart").append("g");
                gEnter.append("g").attr("class", "x axis");
                gEnter.append("g").attr("class", "y1 axis");
                gEnter.append("g").attr("class", "y2 axis");
                gEnter.append("g").attr("class", "lines1Wrap");
                gEnter.append("g").attr("class", "lines2Wrap");
                gEnter.append("g").attr("class", "bars1Wrap");
                gEnter.append("g").attr("class", "bars2Wrap");
                gEnter.append("g").attr("class", "stack1Wrap");
                gEnter.append("g").attr("class", "stack2Wrap");
                gEnter.append("g").attr("class", "legendWrap");
                var g = wrap.select("g");
                if (showLegend) {
                    legend.width(availableWidth / 2);
                    g.select(".legendWrap").datum(data.map(function(series) {
                        series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;
                        series.key = series.originalKey + (series.yAxis == 1 ? "" : " (right axis)");
                        return series;
                    })).call(legend);
                    if (margin.top != legend.height()) {
                        margin.top = legend.height();
                        availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                    }
                    g.select(".legendWrap").attr("transform", "translate(" + availableWidth / 2 + "," + -margin.top + ")");
                }
                lines1.width(availableWidth).height(availableHeight).interpolate("monotone").color(data.map(function(d, i) {
                    return d.color || color[i % color.length];
                }).filter(function(d, i) {
                    return !data[i].disabled && data[i].yAxis == 1 && data[i].type == "line";
                }));
                lines2.width(availableWidth).height(availableHeight).interpolate("monotone").color(data.map(function(d, i) {
                    return d.color || color[i % color.length];
                }).filter(function(d, i) {
                    return !data[i].disabled && data[i].yAxis == 2 && data[i].type == "line";
                }));
                bars1.width(availableWidth).height(availableHeight).color(data.map(function(d, i) {
                    return d.color || color[i % color.length];
                }).filter(function(d, i) {
                    return !data[i].disabled && data[i].yAxis == 1 && data[i].type == "bar";
                }));
                bars2.width(availableWidth).height(availableHeight).color(data.map(function(d, i) {
                    return d.color || color[i % color.length];
                }).filter(function(d, i) {
                    return !data[i].disabled && data[i].yAxis == 2 && data[i].type == "bar";
                }));
                stack1.width(availableWidth).height(availableHeight).color(data.map(function(d, i) {
                    return d.color || color[i % color.length];
                }).filter(function(d, i) {
                    return !data[i].disabled && data[i].yAxis == 1 && data[i].type == "area";
                }));
                stack2.width(availableWidth).height(availableHeight).color(data.map(function(d, i) {
                    return d.color || color[i % color.length];
                }).filter(function(d, i) {
                    return !data[i].disabled && data[i].yAxis == 2 && data[i].type == "area";
                }));
                g.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var lines1Wrap = g.select(".lines1Wrap").datum(dataLines1);
                var bars1Wrap = g.select(".bars1Wrap").datum(dataBars1);
                var stack1Wrap = g.select(".stack1Wrap").datum(dataStack1);
                var lines2Wrap = g.select(".lines2Wrap").datum(dataLines2);
                var bars2Wrap = g.select(".bars2Wrap").datum(dataBars2);
                var stack2Wrap = g.select(".stack2Wrap").datum(dataStack2);
                var extraValue1 = dataStack1.length ? dataStack1.map(function(a) {
                    return a.values;
                }).reduce(function(a, b) {
                    return a.map(function(aVal, i) {
                        return {
                            x: aVal.x,
                            y: aVal.y + b[i].y
                        };
                    });
                }).concat([ {
                    x: 0,
                    y: 0
                } ]) : [];
                var extraValue2 = dataStack2.length ? dataStack2.map(function(a) {
                    return a.values;
                }).reduce(function(a, b) {
                    return a.map(function(aVal, i) {
                        return {
                            x: aVal.x,
                            y: aVal.y + b[i].y
                        };
                    });
                }).concat([ {
                    x: 0,
                    y: 0
                } ]) : [];
                yScale1.domain(d3.extent(d3.merge(series1).concat(extraValue1), function(d) {
                    return d.y;
                })).range([ 0, availableHeight ]);
                yScale2.domain(d3.extent(d3.merge(series2).concat(extraValue2), function(d) {
                    return d.y;
                })).range([ 0, availableHeight ]);
                lines1.yDomain(yScale1.domain());
                bars1.yDomain(yScale1.domain());
                stack1.yDomain(yScale1.domain());
                lines2.yDomain(yScale2.domain());
                bars2.yDomain(yScale2.domain());
                stack2.yDomain(yScale2.domain());
                if (dataStack1.length) {
                    d3.transition(stack1Wrap).call(stack1);
                }
                if (dataStack2.length) {
                    d3.transition(stack2Wrap).call(stack2);
                }
                if (dataBars1.length) {
                    d3.transition(bars1Wrap).call(bars1);
                }
                if (dataBars2.length) {
                    d3.transition(bars2Wrap).call(bars2);
                }
                if (dataLines1.length) {
                    d3.transition(lines1Wrap).call(lines1);
                }
                if (dataLines2.length) {
                    d3.transition(lines2Wrap).call(lines2);
                }
                xAxis.ticks(availableWidth / 100).tickSize(-availableHeight, 0);
                g.select(".x.axis").attr("transform", "translate(0," + availableHeight + ")");
                d3.transition(g.select(".x.axis")).call(xAxis);
                yAxis1.ticks(availableHeight / 36).tickSize(-availableWidth, 0);
                d3.transition(g.select(".y1.axis")).call(yAxis1);
                yAxis2.ticks(availableHeight / 36).tickSize(-availableWidth, 0);
                d3.transition(g.select(".y2.axis")).call(yAxis2);
                g.select(".y2.axis").style("opacity", series2.length ? 1 : 0).attr("transform", "translate(" + x.range()[1] + ",0)");
                legend.dispatch.on("legendClick", function(d, i) {
                    d.disabled = !d.disabled;
                    if (!data.filter(function(d) {
                        return !d.disabled;
                    }).length) {
                        data.map(function(d) {
                            d.disabled = false;
                            wrap.selectAll(".series").classed("disabled", false);
                            return d;
                        });
                    }
                    selection.transition().call(chart);
                });
                dispatch.on("tooltipShow", function(e) {
                    if (tooltips) showTooltip(e, that.parentNode);
                });
            });
            chart.update = function() {
                chart(selection);
            };
            chart.container = this;
            return chart;
        }
        lines1.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        lines1.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        lines2.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        lines2.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        bars1.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        bars1.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        bars2.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        bars2.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        stack1.dispatch.on("tooltipShow", function(e) {
            if (!Math.round(stack1.y()(e.point) * 100)) {
                setTimeout(function() {
                    d3.selectAll(".point.hover").classed("hover", false);
                }, 0);
                return false;
            }
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ], dispatch.tooltipShow(e);
        });
        stack1.dispatch.on("tooltipHide", function(e) {
            dispatch.tooltipHide(e);
        });
        stack2.dispatch.on("tooltipShow", function(e) {
            if (!Math.round(stack2.y()(e.point) * 100)) {
                setTimeout(function() {
                    d3.selectAll(".point.hover").classed("hover", false);
                }, 0);
                return false;
            }
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ], dispatch.tooltipShow(e);
        });
        stack2.dispatch.on("tooltipHide", function(e) {
            dispatch.tooltipHide(e);
        });
        lines1.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        lines1.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        lines2.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        lines2.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        dispatch.on("tooltipHide", function() {
            if (tooltips) nv.tooltip.cleanup();
        });
        chart.dispatch = dispatch;
        chart.lines1 = lines1;
        chart.lines2 = lines2;
        chart.bars1 = bars1;
        chart.bars2 = bars2;
        chart.stack1 = stack1;
        chart.stack2 = stack2;
        chart.xAxis = xAxis;
        chart.yAxis1 = yAxis1;
        chart.yAxis2 = yAxis2;
        chart.x = function(_) {
            if (!arguments.length) return getX;
            getX = _;
            lines1.x(_);
            bars1.x(_);
            return chart;
        };
        chart.y = function(_) {
            if (!arguments.length) return getY;
            getY = _;
            lines1.y(_);
            bars1.y(_);
            return chart;
        };
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin = _;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = _;
            legend.color(_);
            return chart;
        };
        chart.showLegend = function(_) {
            if (!arguments.length) return showLegend;
            showLegend = _;
            return chart;
        };
        chart.tooltips = function(_) {
            if (!arguments.length) return tooltips;
            tooltips = _;
            return chart;
        };
        chart.tooltipContent = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        return chart;
    };
    nv.models.ohlcBar = function() {
        var margin = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, width = 960, height = 500, id = Math.floor(Math.random() * 1e4), x = d3.scale.linear(), y = d3.scale.linear(), getX = function(d) {
            return d.x;
        }, getY = function(d) {
            return d.y;
        }, getOpen = function(d) {
            return d.open;
        }, getClose = function(d) {
            return d.close;
        }, getHigh = function(d) {
            return d.high;
        }, getLow = function(d) {
            return d.low;
        }, forceX = [], forceY = [], padData = false, clipEdge = true, color = nv.utils.defaultColor(), xDomain, yDomain, dispatch = d3.dispatch("chartClick", "elementClick", "elementDblClick", "elementMouseover", "elementMouseout");
        function chart(selection) {
            selection.each(function(data) {
                var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom, container = d3.select(this);
                x.domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX)));
                if (padData) x.range([ availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5) / data[0].values.length ]); else x.range([ 0, availableWidth ]);
                y.domain(yDomain || [ d3.min(data[0].values.map(getLow).concat(forceY)), d3.max(data[0].values.map(getHigh).concat(forceY)) ]).range([ availableHeight, 0 ]);
                if (x.domain()[0] === x.domain()[1] || y.domain()[0] === y.domain()[1]) singlePoint = true;
                if (x.domain()[0] === x.domain()[1]) x.domain()[0] ? x.domain([ x.domain()[0] - x.domain()[0] * .01, x.domain()[1] + x.domain()[1] * .01 ]) : x.domain([ -1, 1 ]);
                if (y.domain()[0] === y.domain()[1]) y.domain()[0] ? y.domain([ y.domain()[0] + y.domain()[0] * .01, y.domain()[1] - y.domain()[1] * .01 ]) : y.domain([ -1, 1 ]);
                var wrap = d3.select(this).selectAll("g.nv-wrap.nv-ohlcBar").data([ data[0].values ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-ohlcBar");
                var defsEnter = wrapEnter.append("defs");
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-ticks");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                container.on("click", function(d, i) {
                    dispatch.chartClick({
                        data: d,
                        index: i,
                        pos: d3.event,
                        id: id
                    });
                });
                defsEnter.append("clipPath").attr("id", "nv-chart-clip-path-" + id).append("rect");
                wrap.select("#nv-chart-clip-path-" + id + " rect").attr("width", availableWidth).attr("height", availableHeight);
                g.attr("clip-path", clipEdge ? "url(#nv-chart-clip-path-" + id + ")" : "");
                var ticks = wrap.select(".nv-ticks").selectAll(".nv-tick").data(function(d) {
                    return d;
                });
                ticks.exit().remove();
                var ticksEnter = ticks.enter().append("path").attr("class", function(d, i, j) {
                    return (getOpen(d, i) > getClose(d, i) ? "nv-tick negative" : "nv-tick positive") + " nv-tick-" + j + "-" + i;
                }).attr("d", function(d, i) {
                    var w = availableWidth / data[0].values.length * .9;
                    return "m0,0l0," + (y(getOpen(d, i)) - y(getHigh(d, i))) + "l" + -w / 2 + ",0l" + w / 2 + ",0l0," + (y(getLow(d, i)) - y(getOpen(d, i))) + "l0," + (y(getClose(d, i)) - y(getLow(d, i))) + "l" + w / 2 + ",0l" + -w / 2 + ",0z";
                }).attr("transform", function(d, i) {
                    return "translate(" + x(getX(d, i)) + "," + y(getHigh(d, i)) + ")";
                }).on("mouseover", function(d, i) {
                    d3.select(this).classed("hover", true);
                    dispatch.elementMouseover({
                        point: d,
                        series: data[0],
                        pos: [ x(getX(d, i)), y(getY(d, i)) ],
                        pointIndex: i,
                        seriesIndex: 0,
                        e: d3.event
                    });
                }).on("mouseout", function(d, i) {
                    d3.select(this).classed("hover", false);
                    dispatch.elementMouseout({
                        point: d,
                        series: data[0],
                        pointIndex: i,
                        seriesIndex: 0,
                        e: d3.event
                    });
                }).on("click", function(d, i) {
                    dispatch.elementClick({
                        value: getY(d, i),
                        data: d,
                        index: i,
                        pos: [ x(getX(d, i)), y(getY(d, i)) ],
                        e: d3.event,
                        id: id
                    });
                    d3.event.stopPropagation();
                }).on("dblclick", function(d, i) {
                    dispatch.elementDblClick({
                        value: getY(d, i),
                        data: d,
                        index: i,
                        pos: [ x(getX(d, i)), y(getY(d, i)) ],
                        e: d3.event,
                        id: id
                    });
                    d3.event.stopPropagation();
                });
                ticks.attr("class", function(d, i, j) {
                    return (getOpen(d, i) > getClose(d, i) ? "nv-tick negative" : "nv-tick positive") + " nv-tick-" + j + "-" + i;
                });
                d3.transition(ticks).attr("transform", function(d, i) {
                    return "translate(" + x(getX(d, i)) + "," + y(getHigh(d, i)) + ")";
                }).attr("d", function(d, i) {
                    var w = availableWidth / data[0].values.length * .9;
                    return "m0,0l0," + (y(getOpen(d, i)) - y(getHigh(d, i))) + "l" + -w / 2 + ",0l" + w / 2 + ",0l0," + (y(getLow(d, i)) - y(getOpen(d, i))) + "l0," + (y(getClose(d, i)) - y(getLow(d, i))) + "l" + w / 2 + ",0l" + -w / 2 + ",0z";
                });
            });
            return chart;
        }
        chart.dispatch = dispatch;
        chart.x = function(_) {
            if (!arguments.length) return getX;
            getX = _;
            return chart;
        };
        chart.y = function(_) {
            if (!arguments.length) return getY;
            getY = _;
            return chart;
        };
        chart.open = function(_) {
            if (!arguments.length) return getOpen;
            getOpen = _;
            return chart;
        };
        chart.close = function(_) {
            if (!arguments.length) return getClose;
            getClose = _;
            return chart;
        };
        chart.high = function(_) {
            if (!arguments.length) return getHigh;
            getHigh = _;
            return chart;
        };
        chart.low = function(_) {
            if (!arguments.length) return getLow;
            getLow = _;
            return chart;
        };
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.xScale = function(_) {
            if (!arguments.length) return x;
            x = _;
            return chart;
        };
        chart.yScale = function(_) {
            if (!arguments.length) return y;
            y = _;
            return chart;
        };
        chart.xDomain = function(_) {
            if (!arguments.length) return xDomain;
            xDomain = _;
            return chart;
        };
        chart.yDomain = function(_) {
            if (!arguments.length) return yDomain;
            yDomain = _;
            return chart;
        };
        chart.forceX = function(_) {
            if (!arguments.length) return forceX;
            forceX = _;
            return chart;
        };
        chart.forceY = function(_) {
            if (!arguments.length) return forceY;
            forceY = _;
            return chart;
        };
        chart.padData = function(_) {
            if (!arguments.length) return padData;
            padData = _;
            return chart;
        };
        chart.clipEdge = function(_) {
            if (!arguments.length) return clipEdge;
            clipEdge = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            return chart;
        };
        chart.id = function(_) {
            if (!arguments.length) return id;
            id = _;
            return chart;
        };
        return chart;
    };
    nv.models.pie = function() {
        var margin = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, width = 500, height = 500, getValues = function(d) {
            return d.values;
        }, getX = function(d) {
            return d.x;
        }, getY = function(d) {
            return d.y;
        }, getDescription = function(d) {
            return d.description;
        }, id = Math.floor(Math.random() * 1e4), color = nv.utils.defaultColor(), valueFormat = d3.format(",.2f"), showLabels = true, pieLabelsOutside = true, donutLabelsOutside = false, labelThreshold = .02, donut = false, labelSunbeamLayout = false, startAngle = false, endAngle = false, donutRatio = .5, dispatch = d3.dispatch("chartClick", "elementClick", "elementDblClick", "elementMouseover", "elementMouseout");
        function chart(selection) {
            selection.each(function(data) {
                var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom, radius = Math.min(availableWidth, availableHeight) / 2, arcRadius = radius - radius / 5, container = d3.select(this);
                var wrap = container.selectAll(".nv-wrap.nv-pie").data([ getValues(data[0]) ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-pie nv-chart-" + id);
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-pie");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                g.select(".nv-pie").attr("transform", "translate(" + availableWidth / 2 + "," + availableHeight / 2 + ")");
                container.on("click", function(d, i) {
                    dispatch.chartClick({
                        data: d,
                        index: i,
                        pos: d3.event,
                        id: id
                    });
                });
                var arc = d3.svg.arc().outerRadius(arcRadius);
                if (startAngle) arc.startAngle(startAngle);
                if (endAngle) arc.endAngle(endAngle);
                if (donut) arc.innerRadius(radius * donutRatio);
                var pie = d3.layout.pie().sort(null).value(function(d) {
                    return d.disabled ? 0 : getY(d);
                });
                var slices = wrap.select(".nv-pie").selectAll(".nv-slice").data(pie);
                slices.exit().remove();
                var ae = slices.enter().append("g").attr("class", "nv-slice").on("mouseover", function(d, i) {
                    d3.select(this).classed("hover", true);
                    dispatch.elementMouseover({
                        label: getX(d.data),
                        value: getY(d.data),
                        point: d.data,
                        pointIndex: i,
                        pos: [ d3.event.pageX, d3.event.pageY ],
                        id: id
                    });
                }).on("mouseout", function(d, i) {
                    d3.select(this).classed("hover", false);
                    dispatch.elementMouseout({
                        label: getX(d.data),
                        value: getY(d.data),
                        point: d.data,
                        index: i,
                        id: id
                    });
                }).on("click", function(d, i) {
                    dispatch.elementClick({
                        label: getX(d.data),
                        value: getY(d.data),
                        point: d.data,
                        index: i,
                        pos: d3.event,
                        id: id
                    });
                    d3.event.stopPropagation();
                }).on("dblclick", function(d, i) {
                    dispatch.elementDblClick({
                        label: getX(d.data),
                        value: getY(d.data),
                        point: d.data,
                        index: i,
                        pos: d3.event,
                        id: id
                    });
                    d3.event.stopPropagation();
                });
                slices.attr("fill", function(d, i) {
                    return color(d, i);
                }).attr("stroke", function(d, i) {
                    return color(d, i);
                });
                var paths = ae.append("path").each(function(d) {
                    this._current = d;
                });
                d3.transition(slices.select("path")).attr("d", arc).attrTween("d", arcTween);
                if (showLabels) {
                    var labelsArc = d3.svg.arc().innerRadius(0);
                    if (pieLabelsOutside) {
                        labelsArc = arc;
                    }
                    if (donutLabelsOutside) {
                        labelsArc = d3.svg.arc().outerRadius(arc.outerRadius());
                    }
                    ae.append("g").classed("nv-label", true).each(function(d, i) {
                        var group = d3.select(this);
                        group.attr("transform", function(d) {
                            if (labelSunbeamLayout) {
                                d.outerRadius = arcRadius + 10;
                                d.innerRadius = arcRadius + 15;
                                var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);
                                if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
                                    rotateAngle -= 90;
                                } else {
                                    rotateAngle += 90;
                                }
                                return "translate(" + labelsArc.centroid(d) + ") rotate(" + rotateAngle + ")";
                            } else {
                                d.outerRadius = radius + 10;
                                d.innerRadius = radius + 15;
                                return "translate(" + labelsArc.centroid(d) + ")";
                            }
                        });
                        group.append("rect").style("stroke", "#fff").style("fill", "#fff").attr("rx", 3).attr("ry", 3);
                        group.append("text").style("text-anchor", labelSunbeamLayout ? (d.startAngle + d.endAngle) / 2 < Math.PI ? "start" : "end" : "middle").style("fill", "#000");
                    });
                    slices.select(".nv-label").transition().attr("transform", function(d) {
                        if (labelSunbeamLayout) {
                            d.outerRadius = arcRadius + 10;
                            d.innerRadius = arcRadius + 15;
                            var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);
                            if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
                                rotateAngle -= 90;
                            } else {
                                rotateAngle += 90;
                            }
                            return "translate(" + labelsArc.centroid(d) + ") rotate(" + rotateAngle + ")";
                        } else {
                            d.outerRadius = radius + 10;
                            d.innerRadius = radius + 15;
                            return "translate(" + labelsArc.centroid(d) + ")";
                        }
                    });
                    slices.each(function(d, i) {
                        var slice = d3.select(this);
                        slice.select(".nv-label text").style("text-anchor", labelSunbeamLayout ? (d.startAngle + d.endAngle) / 2 < Math.PI ? "start" : "end" : "middle").text(function(d, i) {
                            var percent = (d.endAngle - d.startAngle) / (2 * Math.PI);
                            return d.value && percent > labelThreshold ? getX(d.data) : "";
                        });
                        var textBox = slice.select("text").node().getBBox();
                        slice.select(".nv-label rect").attr("width", textBox.width + 10).attr("height", textBox.height + 10).attr("transform", function() {
                            return "translate(" + [ textBox.x - 5, textBox.y - 5 ] + ")";
                        });
                    });
                }
                function angle(d) {
                    var a = (d.startAngle + d.endAngle) * 90 / Math.PI - 90;
                    return a > 90 ? a - 180 : a;
                }
                function arcTween(a) {
                    if (!donut) a.innerRadius = 0;
                    var i = d3.interpolate(this._current, a);
                    this._current = i(0);
                    return function(t) {
                        return arc(i(t));
                    };
                }
                function tweenPie(b) {
                    b.innerRadius = 0;
                    var i = d3.interpolate({
                        startAngle: 0,
                        endAngle: 0
                    }, b);
                    return function(t) {
                        return arc(i(t));
                    };
                }
            });
            return chart;
        }
        chart.dispatch = dispatch;
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.values = function(_) {
            if (!arguments.length) return getValues;
            getValues = _;
            return chart;
        };
        chart.x = function(_) {
            if (!arguments.length) return getX;
            getX = _;
            return chart;
        };
        chart.y = function(_) {
            if (!arguments.length) return getY;
            getY = d3.functor(_);
            return chart;
        };
        chart.description = function(_) {
            if (!arguments.length) return getDescription;
            getDescription = _;
            return chart;
        };
        chart.showLabels = function(_) {
            if (!arguments.length) return showLabels;
            showLabels = _;
            return chart;
        };
        chart.labelSunbeamLayout = function(_) {
            if (!arguments.length) return labelSunbeamLayout;
            labelSunbeamLayout = _;
            return chart;
        };
        chart.donutLabelsOutside = function(_) {
            if (!arguments.length) return donutLabelsOutside;
            donutLabelsOutside = _;
            return chart;
        };
        chart.pieLabelsOutside = function(_) {
            if (!arguments.length) return pieLabelsOutside;
            pieLabelsOutside = _;
            return chart;
        };
        chart.donut = function(_) {
            if (!arguments.length) return donut;
            donut = _;
            return chart;
        };
        chart.donutRatio = function(_) {
            if (!arguments.length) return donutRatio;
            donutRatio = _;
            return chart;
        };
        chart.startAngle = function(_) {
            if (!arguments.length) return startAngle;
            startAngle = _;
            return chart;
        };
        chart.endAngle = function(_) {
            if (!arguments.length) return endAngle;
            endAngle = _;
            return chart;
        };
        chart.id = function(_) {
            if (!arguments.length) return id;
            id = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            return chart;
        };
        chart.valueFormat = function(_) {
            if (!arguments.length) return valueFormat;
            valueFormat = _;
            return chart;
        };
        chart.labelThreshold = function(_) {
            if (!arguments.length) return labelThreshold;
            labelThreshold = _;
            return chart;
        };
        return chart;
    };
    nv.models.pieChart = function() {
        var pie = nv.models.pie(), legend = nv.models.legend();
        var margin = {
            top: 30,
            right: 20,
            bottom: 20,
            left: 20
        }, width = null, height = null, showLegend = true, color = nv.utils.defaultColor(), tooltips = true, tooltip = function(key, y, e, graph) {
            return "<h3>" + key + "</h3>" + "<p>" + y + "</p>";
        }, state = {}, defaultState = null, noData = "No Data Available.", dispatch = d3.dispatch("tooltipShow", "tooltipHide", "stateChange", "changeState");
        var showTooltip = function(e, offsetElement) {
            var tooltipLabel = pie.description()(e.point) || pie.x()(e.point);
            var left = e.pos[0] + (offsetElement && offsetElement.offsetLeft || 0), top = e.pos[1] + (offsetElement && offsetElement.offsetTop || 0), y = pie.valueFormat()(pie.y()(e.point)), content = tooltip(tooltipLabel, y, e, chart);
            nv.tooltip.show([ left, top ], content, e.value < 0 ? "n" : "s", null, offsetElement);
        };
        function chart(selection) {
            selection.each(function(data) {
                var container = d3.select(this), that = this;
                var availableWidth = (width || parseInt(container.style("width")) || 960) - margin.left - margin.right, availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                chart.update = function() {
                    chart(selection);
                };
                chart.container = this;
                state.disabled = data[0].map(function(d) {
                    return !!d.disabled;
                });
                if (!defaultState) {
                    var key;
                    defaultState = {};
                    for (key in state) {
                        if (state[key] instanceof Array) defaultState[key] = state[key].slice(0); else defaultState[key] = state[key];
                    }
                }
                if (!data[0] || !data[0].length) {
                    var noDataText = container.selectAll(".nv-noData").data([ noData ]);
                    noDataText.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle");
                    noDataText.attr("x", margin.left + availableWidth / 2).attr("y", margin.top + availableHeight / 2).text(function(d) {
                        return d;
                    });
                    return chart;
                } else {
                    container.selectAll(".nv-noData").remove();
                }
                var wrap = container.selectAll("g.nv-wrap.nv-pieChart").data([ data ]);
                var gEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-pieChart").append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-pieWrap");
                gEnter.append("g").attr("class", "nv-legendWrap");
                if (showLegend) {
                    legend.width(availableWidth).key(pie.x());
                    wrap.select(".nv-legendWrap").datum(pie.values()(data[0])).call(legend);
                    if (margin.top != legend.height()) {
                        margin.top = legend.height();
                        availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                    }
                    wrap.select(".nv-legendWrap").attr("transform", "translate(0," + -margin.top + ")");
                }
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                pie.width(availableWidth).height(availableHeight);
                var pieWrap = g.select(".nv-pieWrap").datum(data);
                d3.transition(pieWrap).call(pie);
                legend.dispatch.on("legendClick", function(d, i, that) {
                    d.disabled = !d.disabled;
                    if (!pie.values()(data[0]).filter(function(d) {
                        return !d.disabled;
                    }).length) {
                        pie.values()(data[0]).map(function(d) {
                            d.disabled = false;
                            wrap.selectAll(".nv-series").classed("disabled", false);
                            return d;
                        });
                    }
                    state.disabled = data[0].map(function(d) {
                        return !!d.disabled;
                    });
                    dispatch.stateChange(state);
                    selection.transition().call(chart);
                });
                pie.dispatch.on("elementMouseout.tooltip", function(e) {
                    dispatch.tooltipHide(e);
                });
                dispatch.on("changeState", function(e) {
                    if (typeof e.disabled !== "undefined") {
                        data[0].forEach(function(series, i) {
                            series.disabled = e.disabled[i];
                        });
                        state.disabled = e.disabled;
                    }
                    selection.call(chart);
                });
            });
            return chart;
        }
        pie.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
            dispatch.tooltipShow(e);
        });
        dispatch.on("tooltipShow", function(e) {
            if (tooltips) showTooltip(e);
        });
        dispatch.on("tooltipHide", function() {
            if (tooltips) nv.tooltip.cleanup();
        });
        chart.legend = legend;
        chart.dispatch = dispatch;
        chart.pie = pie;
        d3.rebind(chart, pie, "valueFormat", "values", "x", "y", "description", "id", "showLabels", "donutLabelsOutside", "pieLabelsOutside", "donut", "donutRatio", "labelThreshold");
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            legend.color(color);
            pie.color(color);
            return chart;
        };
        chart.showLegend = function(_) {
            if (!arguments.length) return showLegend;
            showLegend = _;
            return chart;
        };
        chart.tooltips = function(_) {
            if (!arguments.length) return tooltips;
            tooltips = _;
            return chart;
        };
        chart.tooltipContent = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.state = function(_) {
            if (!arguments.length) return state;
            state = _;
            return chart;
        };
        chart.defaultState = function(_) {
            if (!arguments.length) return defaultState;
            defaultState = _;
            return chart;
        };
        chart.noData = function(_) {
            if (!arguments.length) return noData;
            noData = _;
            return chart;
        };
        return chart;
    };
    nv.models.scatter = function() {
        var margin = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, width = 960, height = 500, color = nv.utils.defaultColor(), id = Math.floor(Math.random() * 1e5), x = d3.scale.linear(), y = d3.scale.linear(), z = d3.scale.linear(), getX = function(d) {
            return d.x;
        }, getY = function(d) {
            return d.y;
        }, getSize = function(d) {
            return d.size || 1;
        }, getShape = function(d) {
            return d.shape || "circle";
        }, onlyCircles = true, forceX = [], forceY = [], forceSize = [], interactive = true, pointActive = function(d) {
            return !d.notActive;
        }, padData = false, padDataOuter = .1, clipEdge = false, clipVoronoi = true, clipRadius = function() {
            return 25;
        }, xDomain = null, yDomain = null, sizeDomain = null, sizeRange = null, singlePoint = false, dispatch = d3.dispatch("elementClick", "elementMouseover", "elementMouseout"), useVoronoi = true;
        var x0, y0, z0, timeoutID, needsUpdate = false;
        function chart(selection) {
            selection.each(function(data) {
                var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom, container = d3.select(this);
                data = data.map(function(series, i) {
                    series.values = series.values.map(function(point) {
                        point.series = i;
                        return point;
                    });
                    return series;
                });
                var seriesData = xDomain && yDomain && sizeDomain ? [] : d3.merge(data.map(function(d) {
                    return d.values.map(function(d, i) {
                        return {
                            x: getX(d, i),
                            y: getY(d, i),
                            size: getSize(d, i)
                        };
                    });
                }));
                x.domain(xDomain || d3.extent(seriesData.map(function(d) {
                    return d.x;
                }).concat(forceX)));
                if (padData && data[0]) x.range([ (availableWidth * padDataOuter + availableWidth) / (2 * data[0].values.length), availableWidth - availableWidth * (1 + padDataOuter) / (2 * data[0].values.length) ]); else x.range([ 0, availableWidth ]);
                y.domain(yDomain || d3.extent(seriesData.map(function(d) {
                    return d.y;
                }).concat(forceY))).range([ availableHeight, 0 ]);
                z.domain(sizeDomain || d3.extent(seriesData.map(function(d) {
                    return d.size;
                }).concat(forceSize))).range(sizeRange || [ 16, 256 ]);
                if (x.domain()[0] === x.domain()[1] || y.domain()[0] === y.domain()[1]) singlePoint = true;
                if (x.domain()[0] === x.domain()[1]) x.domain()[0] ? x.domain([ x.domain()[0] - x.domain()[0] * .01, x.domain()[1] + x.domain()[1] * .01 ]) : x.domain([ -1, 1 ]);
                if (y.domain()[0] === y.domain()[1]) y.domain()[0] ? y.domain([ y.domain()[0] + y.domain()[0] * .01, y.domain()[1] - y.domain()[1] * .01 ]) : y.domain([ -1, 1 ]);
                if (isNaN(x.domain()[0])) {
                    x.domain([ -1, 1 ]);
                }
                if (isNaN(y.domain()[0])) {
                    y.domain([ -1, 1 ]);
                }
                x0 = x0 || x;
                y0 = y0 || y;
                z0 = z0 || z;
                var wrap = container.selectAll("g.nv-wrap.nv-scatter").data([ data ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-scatter nv-chart-" + id + (singlePoint ? " nv-single-point" : ""));
                var defsEnter = wrapEnter.append("defs");
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-groups");
                gEnter.append("g").attr("class", "nv-point-paths");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                defsEnter.append("clipPath").attr("id", "nv-edge-clip-" + id).append("rect");
                wrap.select("#nv-edge-clip-" + id + " rect").attr("width", availableWidth).attr("height", availableHeight);
                g.attr("clip-path", clipEdge ? "url(#nv-edge-clip-" + id + ")" : "");
                function updateInteractiveLayer() {
                    if (!interactive) return false;
                    var eventElements;
                    var vertices = d3.merge(data.map(function(group, groupIndex) {
                        return group.values.map(function(point, pointIndex) {
                            var pX = getX(point, pointIndex) + Math.random() * 1e-10;
                            var pY = getY(point, pointIndex) + Math.random() * 1e-10;
                            return [ x(pX), y(pY), groupIndex, pointIndex, point ];
                        }).filter(function(pointArray, pointIndex) {
                            return pointActive(pointArray[4], pointIndex);
                        });
                    }));
                    if (useVoronoi === true) {
                        if (clipVoronoi) {
                            var pointClipsEnter = wrap.select("defs").selectAll(".nv-point-clips").data([ id ]).enter();
                            pointClipsEnter.append("clipPath").attr("class", "nv-point-clips").attr("id", "nv-points-clip-" + id);
                            var pointClips = wrap.select("#nv-points-clip-" + id).selectAll("circle").data(vertices);
                            pointClips.enter().append("circle").attr("r", clipRadius);
                            pointClips.exit().remove();
                            pointClips.attr("cx", function(d) {
                                return d[0];
                            }).attr("cy", function(d) {
                                return d[1];
                            });
                            wrap.select(".nv-point-paths").attr("clip-path", "url(#nv-points-clip-" + id + ")");
                        }
                        vertices.push([ x.range()[0] - 20, y.range()[0] - 20, null, null ]);
                        vertices.push([ x.range()[1] + 20, y.range()[1] + 20, null, null ]);
                        vertices.push([ x.range()[0] - 20, y.range()[0] + 20, null, null ]);
                        vertices.push([ x.range()[1] + 20, y.range()[1] - 20, null, null ]);
                        var bounds = d3.geom.polygon([ [ -10, -10 ], [ -10, height + 10 ], [ width + 10, height + 10 ], [ width + 10, -10 ] ]);
                        var voronoi = d3.geom.voronoi(vertices).map(function(d, i) {
                            return {
                                data: bounds.clip(d),
                                series: vertices[i][2],
                                point: vertices[i][3]
                            };
                        });
                        var pointPaths = wrap.select(".nv-point-paths").selectAll("path").data(voronoi);
                        pointPaths.enter().append("path").attr("class", function(d, i) {
                            return "nv-path-" + i;
                        });
                        pointPaths.exit().remove();
                        pointPaths.attr("d", function(d) {
                            if (d.data.length === 0) return "M 0 0"; else return "M" + d.data.join("L") + "Z";
                        });
                        pointPaths.on("click", function(d) {
                            if (needsUpdate) return 0;
                            var series = data[d.series], point = series.values[d.point];
                            dispatch.elementClick({
                                point: point,
                                series: series,
                                pos: [ x(getX(point, d.point)) + margin.left, y(getY(point, d.point)) + margin.top ],
                                seriesIndex: d.series,
                                pointIndex: d.point
                            });
                        }).on("mouseover", function(d) {
                            if (needsUpdate) return 0;
                            var series = data[d.series], point = series.values[d.point];
                            dispatch.elementMouseover({
                                point: point,
                                series: series,
                                pos: [ x(getX(point, d.point)) + margin.left, y(getY(point, d.point)) + margin.top ],
                                seriesIndex: d.series,
                                pointIndex: d.point
                            });
                        }).on("mouseout", function(d, i) {
                            if (needsUpdate) return 0;
                            var series = data[d.series], point = series.values[d.point];
                            dispatch.elementMouseout({
                                point: point,
                                series: series,
                                seriesIndex: d.series,
                                pointIndex: d.point
                            });
                        });
                    } else {
                        wrap.select(".nv-groups").selectAll(".nv-group").selectAll(".nv-point").on("click", function(d, i) {
                            if (needsUpdate || !data[d.series]) return 0;
                            var series = data[d.series], point = series.values[i];
                            dispatch.elementClick({
                                point: point,
                                series: series,
                                pos: [ x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top ],
                                seriesIndex: d.series,
                                pointIndex: i
                            });
                        }).on("mouseover", function(d, i) {
                            if (needsUpdate || !data[d.series]) return 0;
                            var series = data[d.series], point = series.values[i];
                            dispatch.elementMouseover({
                                point: point,
                                series: series,
                                pos: [ x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top ],
                                seriesIndex: d.series,
                                pointIndex: i
                            });
                        }).on("mouseout", function(d, i) {
                            if (needsUpdate || !data[d.series]) return 0;
                            var series = data[d.series], point = series.values[i];
                            dispatch.elementMouseout({
                                point: point,
                                series: series,
                                seriesIndex: d.series,
                                pointIndex: i
                            });
                        });
                    }
                    needsUpdate = false;
                }
                needsUpdate = true;
                var groups = wrap.select(".nv-groups").selectAll(".nv-group").data(function(d) {
                    return d;
                }, function(d) {
                    return d.key;
                });
                groups.enter().append("g").style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6);
                d3.transition(groups.exit()).style("stroke-opacity", 1e-6).style("fill-opacity", 1e-6).remove();
                groups.attr("class", function(d, i) {
                    return "nv-group nv-series-" + i;
                }).classed("hover", function(d) {
                    return d.hover;
                });
                d3.transition(groups).style("fill", function(d, i) {
                    return color(d, i);
                }).style("stroke", function(d, i) {
                    return color(d, i);
                }).style("stroke-opacity", 1).style("fill-opacity", .5);
                if (onlyCircles) {
                    var points = groups.selectAll("circle.nv-point").data(function(d) {
                        return d.values;
                    });
                    points.enter().append("circle").attr("cx", function(d, i) {
                        return x0(getX(d, i));
                    }).attr("cy", function(d, i) {
                        return y0(getY(d, i));
                    }).attr("r", function(d, i) {
                        return Math.sqrt(z(getSize(d, i)) / Math.PI);
                    });
                    points.exit().remove();
                    d3.transition(groups.exit().selectAll("path.nv-point")).attr("cx", function(d, i) {
                        return x(getX(d, i));
                    }).attr("cy", function(d, i) {
                        return y(getY(d, i));
                    }).remove();
                    points.attr("class", function(d, i) {
                        return "nv-point nv-point-" + i;
                    });
                    d3.transition(points).attr("cx", function(d, i) {
                        return x(getX(d, i));
                    }).attr("cy", function(d, i) {
                        return y(getY(d, i));
                    }).attr("r", function(d, i) {
                        return Math.sqrt(z(getSize(d, i)) / Math.PI);
                    });
                } else {
                    var points = groups.selectAll("path.nv-point").data(function(d) {
                        return d.values;
                    });
                    points.enter().append("path").attr("transform", function(d, i) {
                        return "translate(" + x0(getX(d, i)) + "," + y0(getY(d, i)) + ")";
                    }).attr("d", d3.svg.symbol().type(getShape).size(function(d, i) {
                        return z(getSize(d, i));
                    }));
                    points.exit().remove();
                    d3.transition(groups.exit().selectAll("path.nv-point")).attr("transform", function(d, i) {
                        return "translate(" + x(getX(d, i)) + "," + y(getY(d, i)) + ")";
                    }).remove();
                    points.attr("class", function(d, i) {
                        return "nv-point nv-point-" + i;
                    });
                    d3.transition(points).attr("transform", function(d, i) {
                        return "translate(" + x(getX(d, i)) + "," + y(getY(d, i)) + ")";
                    }).attr("d", d3.svg.symbol().type(getShape).size(function(d, i) {
                        return z(getSize(d, i));
                    }));
                }
                clearTimeout(timeoutID);
                timeoutID = setTimeout(updateInteractiveLayer, 300);
                x0 = x.copy();
                y0 = y.copy();
                z0 = z.copy();
            });
            return chart;
        }
        dispatch.on("elementMouseover.point", function(d) {
            if (interactive) d3.select(".nv-chart-" + id + " .nv-series-" + d.seriesIndex + " .nv-point-" + d.pointIndex).classed("hover", true);
        });
        dispatch.on("elementMouseout.point", function(d) {
            if (interactive) d3.select(".nv-chart-" + id + " .nv-series-" + d.seriesIndex + " .nv-point-" + d.pointIndex).classed("hover", false);
        });
        chart.dispatch = dispatch;
        chart.x = function(_) {
            if (!arguments.length) return getX;
            getX = d3.functor(_);
            return chart;
        };
        chart.y = function(_) {
            if (!arguments.length) return getY;
            getY = d3.functor(_);
            return chart;
        };
        chart.size = function(_) {
            if (!arguments.length) return getSize;
            getSize = d3.functor(_);
            return chart;
        };
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.xScale = function(_) {
            if (!arguments.length) return x;
            x = _;
            return chart;
        };
        chart.yScale = function(_) {
            if (!arguments.length) return y;
            y = _;
            return chart;
        };
        chart.zScale = function(_) {
            if (!arguments.length) return z;
            z = _;
            return chart;
        };
        chart.xDomain = function(_) {
            if (!arguments.length) return xDomain;
            xDomain = _;
            return chart;
        };
        chart.yDomain = function(_) {
            if (!arguments.length) return yDomain;
            yDomain = _;
            return chart;
        };
        chart.sizeDomain = function(_) {
            if (!arguments.length) return sizeDomain;
            sizeDomain = _;
            return chart;
        };
        chart.sizeRange = function(_) {
            if (!arguments.length) return sizeRange;
            sizeRange = _;
            return chart;
        };
        chart.forceX = function(_) {
            if (!arguments.length) return forceX;
            forceX = _;
            return chart;
        };
        chart.forceY = function(_) {
            if (!arguments.length) return forceY;
            forceY = _;
            return chart;
        };
        chart.forceSize = function(_) {
            if (!arguments.length) return forceSize;
            forceSize = _;
            return chart;
        };
        chart.interactive = function(_) {
            if (!arguments.length) return interactive;
            interactive = _;
            return chart;
        };
        chart.pointActive = function(_) {
            if (!arguments.length) return pointActive;
            pointActive = _;
            return chart;
        };
        chart.padData = function(_) {
            if (!arguments.length) return padData;
            padData = _;
            return chart;
        };
        chart.padDataOuter = function(_) {
            if (!arguments.length) return padDataOuter;
            padDataOuter = _;
            return chart;
        };
        chart.clipEdge = function(_) {
            if (!arguments.length) return clipEdge;
            clipEdge = _;
            return chart;
        };
        chart.clipVoronoi = function(_) {
            if (!arguments.length) return clipVoronoi;
            clipVoronoi = _;
            return chart;
        };
        chart.useVoronoi = function(_) {
            if (!arguments.length) return useVoronoi;
            useVoronoi = _;
            if (useVoronoi === false) {
                clipVoronoi = false;
            }
            return chart;
        };
        chart.clipRadius = function(_) {
            if (!arguments.length) return clipRadius;
            clipRadius = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            return chart;
        };
        chart.shape = function(_) {
            if (!arguments.length) return getShape;
            getShape = _;
            return chart;
        };
        chart.onlyCircles = function(_) {
            if (!arguments.length) return onlyCircles;
            onlyCircles = _;
            return chart;
        };
        chart.id = function(_) {
            if (!arguments.length) return id;
            id = _;
            return chart;
        };
        chart.singlePoint = function(_) {
            if (!arguments.length) return singlePoint;
            singlePoint = _;
            return chart;
        };
        return chart;
    };
    nv.models.scatterChart = function() {
        var scatter = nv.models.scatter(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), legend = nv.models.legend(), controls = nv.models.legend(), distX = nv.models.distribution(), distY = nv.models.distribution();
        var margin = {
            top: 30,
            right: 20,
            bottom: 50,
            left: 75
        }, width = null, height = null, color = nv.utils.defaultColor(), x = d3.fisheye ? d3.fisheye.scale(d3.scale.linear).distortion(0) : scatter.xScale(), y = d3.fisheye ? d3.fisheye.scale(d3.scale.linear).distortion(0) : scatter.yScale(), xPadding = 0, yPadding = 0, showDistX = false, showDistY = false, showLegend = true, showControls = !!d3.fisheye, fisheye = 0, pauseFisheye = false, tooltips = true, tooltipX = function(key, x, y) {
            return "<strong>" + x + "</strong>";
        }, tooltipY = function(key, x, y) {
            return "<strong>" + y + "</strong>";
        }, tooltip = null, state = {}, defaultState = null, dispatch = d3.dispatch("tooltipShow", "tooltipHide", "stateChange", "changeState"), noData = "No Data Available.";
        scatter.xScale(x).yScale(y);
        xAxis.orient("bottom").tickPadding(10);
        yAxis.orient("left").tickPadding(10);
        distX.axis("x");
        distY.axis("y");
        var x0, y0;
        var showTooltip = function(e, offsetElement) {
            var left = e.pos[0] + (offsetElement.offsetLeft || 0), top = e.pos[1] + (offsetElement.offsetTop || 0), leftX = e.pos[0] + (offsetElement.offsetLeft || 0), topX = y.range()[0] + margin.top + (offsetElement.offsetTop || 0), leftY = x.range()[0] + margin.left + (offsetElement.offsetLeft || 0), topY = e.pos[1] + (offsetElement.offsetTop || 0), xVal = xAxis.tickFormat()(scatter.x()(e.point, e.pointIndex)), yVal = yAxis.tickFormat()(scatter.y()(e.point, e.pointIndex));
            if (tooltipX != null) nv.tooltip.show([ leftX, topX ], tooltipX(e.series.key, xVal, yVal, e, chart), "n", 1, offsetElement, "x-nvtooltip");
            if (tooltipY != null) nv.tooltip.show([ leftY, topY ], tooltipY(e.series.key, xVal, yVal, e, chart), "e", 1, offsetElement, "y-nvtooltip");
            if (tooltip != null) nv.tooltip.show([ left, top ], tooltip(e.series.key, xVal, yVal, e, chart), e.value < 0 ? "n" : "s", null, offsetElement);
        };
        var controlsData = [ {
            key: "Magnify",
            disabled: true
        } ];
        function chart(selection) {
            selection.each(function(data) {
                var container = d3.select(this), that = this;
                var availableWidth = (width || parseInt(container.style("width")) || 960) - margin.left - margin.right, availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                chart.update = function() {
                    chart(selection);
                };
                chart.container = this;
                state.disabled = data.map(function(d) {
                    return !!d.disabled;
                });
                if (!defaultState) {
                    var key;
                    defaultState = {};
                    for (key in state) {
                        if (state[key] instanceof Array) defaultState[key] = state[key].slice(0); else defaultState[key] = state[key];
                    }
                }
                if (!data || !data.length || !data.filter(function(d) {
                    return d.values.length;
                }).length) {
                    var noDataText = container.selectAll(".nv-noData").data([ noData ]);
                    noDataText.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle");
                    noDataText.attr("x", margin.left + availableWidth / 2).attr("y", margin.top + availableHeight / 2).text(function(d) {
                        return d;
                    });
                    return chart;
                } else {
                    container.selectAll(".nv-noData").remove();
                }
                x0 = x0 || x;
                y0 = y0 || y;
                var wrap = container.selectAll("g.nv-wrap.nv-scatterChart").data([ data ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-scatterChart nv-chart-" + scatter.id());
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                gEnter.append("rect").attr("class", "nvd3 nv-background");
                gEnter.append("g").attr("class", "nv-x nv-axis");
                gEnter.append("g").attr("class", "nv-y nv-axis");
                gEnter.append("g").attr("class", "nv-scatterWrap");
                gEnter.append("g").attr("class", "nv-distWrap");
                gEnter.append("g").attr("class", "nv-legendWrap");
                gEnter.append("g").attr("class", "nv-controlsWrap");
                if (showLegend) {
                    legend.width(availableWidth / 2);
                    wrap.select(".nv-legendWrap").datum(data).call(legend);
                    if (margin.top != legend.height()) {
                        margin.top = legend.height();
                        availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                    }
                    wrap.select(".nv-legendWrap").attr("transform", "translate(" + availableWidth / 2 + "," + -margin.top + ")");
                }
                if (showControls) {
                    controls.width(180).color([ "#444" ]);
                    g.select(".nv-controlsWrap").datum(controlsData).attr("transform", "translate(0," + -margin.top + ")").call(controls);
                }
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                scatter.width(availableWidth).height(availableHeight).color(data.map(function(d, i) {
                    return d.color || color(d, i);
                }).filter(function(d, i) {
                    return !data[i].disabled;
                }));
                wrap.select(".nv-scatterWrap").datum(data.filter(function(d) {
                    return !d.disabled;
                })).call(scatter);
                if (xPadding) {
                    var xRange = x.domain()[1] - x.domain()[0];
                    x.domain([ x.domain()[0] - xPadding * xRange, x.domain()[1] + xPadding * xRange ]);
                }
                if (yPadding) {
                    var yRange = y.domain()[1] - y.domain()[0];
                    y.domain([ y.domain()[0] - yPadding * yRange, y.domain()[1] + yPadding * yRange ]);
                }
                xAxis.scale(x).ticks(xAxis.ticks() && xAxis.ticks().length ? xAxis.ticks() : availableWidth / 100).tickSize(-availableHeight, 0);
                g.select(".nv-x.nv-axis").attr("transform", "translate(0," + y.range()[0] + ")").call(xAxis);
                yAxis.scale(y).ticks(yAxis.ticks() && yAxis.ticks().length ? yAxis.ticks() : availableHeight / 36).tickSize(-availableWidth, 0);
                g.select(".nv-y.nv-axis").call(yAxis);
                if (showDistX) {
                    distX.getData(scatter.x()).scale(x).width(availableWidth).color(data.map(function(d, i) {
                        return d.color || color(d, i);
                    }).filter(function(d, i) {
                        return !data[i].disabled;
                    }));
                    gEnter.select(".nv-distWrap").append("g").attr("class", "nv-distributionX");
                    g.select(".nv-distributionX").attr("transform", "translate(0," + y.range()[0] + ")").datum(data.filter(function(d) {
                        return !d.disabled;
                    })).call(distX);
                }
                if (showDistY) {
                    distY.getData(scatter.y()).scale(y).width(availableHeight).color(data.map(function(d, i) {
                        return d.color || color(d, i);
                    }).filter(function(d, i) {
                        return !data[i].disabled;
                    }));
                    gEnter.select(".nv-distWrap").append("g").attr("class", "nv-distributionY");
                    g.select(".nv-distributionY").attr("transform", "translate(-" + distY.size() + ",0)").datum(data.filter(function(d) {
                        return !d.disabled;
                    })).call(distY);
                }
                if (d3.fisheye) {
                    g.select(".nv-background").attr("width", availableWidth).attr("height", availableHeight);
                    g.select(".nv-background").on("mousemove", updateFisheye);
                    g.select(".nv-background").on("click", function() {
                        pauseFisheye = !pauseFisheye;
                    });
                    scatter.dispatch.on("elementClick.freezeFisheye", function() {
                        pauseFisheye = !pauseFisheye;
                    });
                }
                function updateFisheye() {
                    if (pauseFisheye) {
                        g.select(".nv-point-paths").style("pointer-events", "all");
                        return false;
                    }
                    g.select(".nv-point-paths").style("pointer-events", "none");
                    var mouse = d3.mouse(this);
                    x.distortion(fisheye).focus(mouse[0]);
                    y.distortion(fisheye).focus(mouse[1]);
                    g.select(".nv-scatterWrap").call(scatter);
                    g.select(".nv-x.nv-axis").call(xAxis);
                    g.select(".nv-y.nv-axis").call(yAxis);
                    g.select(".nv-distributionX").datum(data.filter(function(d) {
                        return !d.disabled;
                    })).call(distX);
                    g.select(".nv-distributionY").datum(data.filter(function(d) {
                        return !d.disabled;
                    })).call(distY);
                }
                controls.dispatch.on("legendClick", function(d, i) {
                    d.disabled = !d.disabled;
                    fisheye = d.disabled ? 0 : 2.5;
                    g.select(".nv-background").style("pointer-events", d.disabled ? "none" : "all");
                    g.select(".nv-point-paths").style("pointer-events", d.disabled ? "all" : "none");
                    if (d.disabled) {
                        x.distortion(fisheye).focus(0);
                        y.distortion(fisheye).focus(0);
                        g.select(".nv-scatterWrap").call(scatter);
                        g.select(".nv-x.nv-axis").call(xAxis);
                        g.select(".nv-y.nv-axis").call(yAxis);
                    } else {
                        pauseFisheye = false;
                    }
                    chart(selection);
                });
                legend.dispatch.on("legendClick", function(d, i, that) {
                    d.disabled = !d.disabled;
                    if (!data.filter(function(d) {
                        return !d.disabled;
                    }).length) {
                        data.map(function(d) {
                            d.disabled = false;
                            wrap.selectAll(".nv-series").classed("disabled", false);
                            return d;
                        });
                    }
                    state.disabled = data.map(function(d) {
                        return !!d.disabled;
                    });
                    dispatch.stateChange(state);
                    chart(selection);
                });
                scatter.dispatch.on("elementMouseover.tooltip", function(e) {
                    d3.select(".nv-chart-" + scatter.id() + " .nv-series-" + e.seriesIndex + " .nv-distx-" + e.pointIndex).attr("y1", e.pos[1] - availableHeight);
                    d3.select(".nv-chart-" + scatter.id() + " .nv-series-" + e.seriesIndex + " .nv-disty-" + e.pointIndex).attr("x2", e.pos[0] + distX.size());
                    e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
                    dispatch.tooltipShow(e);
                });
                dispatch.on("tooltipShow", function(e) {
                    if (tooltips) showTooltip(e, that.parentNode);
                });
                dispatch.on("changeState", function(e) {
                    if (typeof e.disabled !== "undefined") {
                        data.forEach(function(series, i) {
                            series.disabled = e.disabled[i];
                        });
                        state.disabled = e.disabled;
                    }
                    selection.call(chart);
                });
                x0 = x.copy();
                y0 = y.copy();
            });
            return chart;
        }
        scatter.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
            d3.select(".nv-chart-" + scatter.id() + " .nv-series-" + e.seriesIndex + " .nv-distx-" + e.pointIndex).attr("y1", 0);
            d3.select(".nv-chart-" + scatter.id() + " .nv-series-" + e.seriesIndex + " .nv-disty-" + e.pointIndex).attr("x2", distY.size());
        });
        dispatch.on("tooltipHide", function() {
            if (tooltips) nv.tooltip.cleanup();
        });
        chart.dispatch = dispatch;
        chart.scatter = scatter;
        chart.legend = legend;
        chart.controls = controls;
        chart.xAxis = xAxis;
        chart.yAxis = yAxis;
        chart.distX = distX;
        chart.distY = distY;
        d3.rebind(chart, scatter, "id", "interactive", "pointActive", "x", "y", "shape", "size", "xScale", "yScale", "zScale", "xDomain", "yDomain", "sizeDomain", "sizeRange", "forceX", "forceY", "forceSize", "clipVoronoi", "clipRadius", "useVoronoi");
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            legend.color(color);
            distX.color(color);
            distY.color(color);
            return chart;
        };
        chart.showDistX = function(_) {
            if (!arguments.length) return showDistX;
            showDistX = _;
            return chart;
        };
        chart.showDistY = function(_) {
            if (!arguments.length) return showDistY;
            showDistY = _;
            return chart;
        };
        chart.showControls = function(_) {
            if (!arguments.length) return showControls;
            showControls = _;
            return chart;
        };
        chart.showLegend = function(_) {
            if (!arguments.length) return showLegend;
            showLegend = _;
            return chart;
        };
        chart.fisheye = function(_) {
            if (!arguments.length) return fisheye;
            fisheye = _;
            return chart;
        };
        chart.xPadding = function(_) {
            if (!arguments.length) return xPadding;
            xPadding = _;
            return chart;
        };
        chart.yPadding = function(_) {
            if (!arguments.length) return yPadding;
            yPadding = _;
            return chart;
        };
        chart.tooltips = function(_) {
            if (!arguments.length) return tooltips;
            tooltips = _;
            return chart;
        };
        chart.tooltipContent = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.tooltipXContent = function(_) {
            if (!arguments.length) return tooltipX;
            tooltipX = _;
            return chart;
        };
        chart.tooltipYContent = function(_) {
            if (!arguments.length) return tooltipY;
            tooltipY = _;
            return chart;
        };
        chart.state = function(_) {
            if (!arguments.length) return state;
            state = _;
            return chart;
        };
        chart.defaultState = function(_) {
            if (!arguments.length) return defaultState;
            defaultState = _;
            return chart;
        };
        chart.noData = function(_) {
            if (!arguments.length) return noData;
            noData = _;
            return chart;
        };
        return chart;
    };
    nv.models.scatterPlusLineChart = function() {
        var scatter = nv.models.scatter(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), legend = nv.models.legend(), controls = nv.models.legend(), distX = nv.models.distribution(), distY = nv.models.distribution();
        var margin = {
            top: 30,
            right: 20,
            bottom: 50,
            left: 75
        }, width = null, height = null, color = nv.utils.defaultColor(), x = d3.fisheye ? d3.fisheye.scale(d3.scale.linear).distortion(0) : scatter.xScale(), y = d3.fisheye ? d3.fisheye.scale(d3.scale.linear).distortion(0) : scatter.yScale(), showDistX = false, showDistY = false, showLegend = true, showControls = !!d3.fisheye, fisheye = 0, pauseFisheye = false, tooltips = true, tooltipX = function(key, x, y) {
            return "<strong>" + x + "</strong>";
        }, tooltipY = function(key, x, y) {
            return "<strong>" + y + "</strong>";
        }, tooltip = function(key, x, y, date) {
            return "<h3>" + key + "</h3>" + "<p>" + date + "</p>";
        }, state = {}, defaultState = null, dispatch = d3.dispatch("tooltipShow", "tooltipHide", "stateChange", "changeState"), noData = "No Data Available.";
        scatter.xScale(x).yScale(y);
        xAxis.orient("bottom").tickPadding(10);
        yAxis.orient("left").tickPadding(10);
        distX.axis("x");
        distY.axis("y");
        var x0, y0;
        var showTooltip = function(e, offsetElement) {
            var left = e.pos[0] + (offsetElement.offsetLeft || 0), top = e.pos[1] + (offsetElement.offsetTop || 0), leftX = e.pos[0] + (offsetElement.offsetLeft || 0), topX = y.range()[0] + margin.top + (offsetElement.offsetTop || 0), leftY = x.range()[0] + margin.left + (offsetElement.offsetLeft || 0), topY = e.pos[1] + (offsetElement.offsetTop || 0), xVal = xAxis.tickFormat()(scatter.x()(e.point, e.pointIndex)), yVal = yAxis.tickFormat()(scatter.y()(e.point, e.pointIndex));
            if (tooltipX != null) nv.tooltip.show([ leftX, topX ], tooltipX(e.series.key, xVal, yVal, e, chart), "n", 1, offsetElement, "x-nvtooltip");
            if (tooltipY != null) nv.tooltip.show([ leftY, topY ], tooltipY(e.series.key, xVal, yVal, e, chart), "e", 1, offsetElement, "y-nvtooltip");
            if (tooltip != null) nv.tooltip.show([ left, top ], tooltip(e.series.key, xVal, yVal, e.point.tooltip, e, chart), e.value < 0 ? "n" : "s", null, offsetElement);
        };
        var controlsData = [ {
            key: "Magnify",
            disabled: true
        } ];
        function chart(selection) {
            selection.each(function(data) {
                var container = d3.select(this), that = this;
                var availableWidth = (width || parseInt(container.style("width")) || 960) - margin.left - margin.right, availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                chart.update = function() {
                    chart(selection);
                };
                chart.container = this;
                state.disabled = data.map(function(d) {
                    return !!d.disabled;
                });
                if (!defaultState) {
                    var key;
                    defaultState = {};
                    for (key in state) {
                        if (state[key] instanceof Array) defaultState[key] = state[key].slice(0); else defaultState[key] = state[key];
                    }
                }
                if (!data || !data.length || !data.filter(function(d) {
                    return d.values.length;
                }).length) {
                    var noDataText = container.selectAll(".nv-noData").data([ noData ]);
                    noDataText.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle");
                    noDataText.attr("x", margin.left + availableWidth / 2).attr("y", margin.top + availableHeight / 2).text(function(d) {
                        return d;
                    });
                    return chart;
                } else {
                    container.selectAll(".nv-noData").remove();
                }
                x = scatter.xScale();
                y = scatter.yScale();
                x0 = x0 || x;
                y0 = y0 || y;
                var wrap = container.selectAll("g.nv-wrap.nv-scatterChart").data([ data ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-scatterChart nv-chart-" + scatter.id());
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                gEnter.append("rect").attr("class", "nvd3 nv-background");
                gEnter.append("g").attr("class", "nv-x nv-axis");
                gEnter.append("g").attr("class", "nv-y nv-axis");
                gEnter.append("g").attr("class", "nv-scatterWrap");
                gEnter.append("g").attr("class", "nv-regressionLinesWrap");
                gEnter.append("g").attr("class", "nv-distWrap");
                gEnter.append("g").attr("class", "nv-legendWrap");
                gEnter.append("g").attr("class", "nv-controlsWrap");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                if (showLegend) {
                    legend.width(availableWidth / 2);
                    wrap.select(".nv-legendWrap").datum(data).call(legend);
                    if (margin.top != legend.height()) {
                        margin.top = legend.height();
                        availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                    }
                    wrap.select(".nv-legendWrap").attr("transform", "translate(" + availableWidth / 2 + "," + -margin.top + ")");
                }
                if (showControls) {
                    controls.width(180).color([ "#444" ]);
                    g.select(".nv-controlsWrap").datum(controlsData).attr("transform", "translate(0," + -margin.top + ")").call(controls);
                }
                scatter.width(availableWidth).height(availableHeight).color(data.map(function(d, i) {
                    return d.color || color(d, i);
                }).filter(function(d, i) {
                    return !data[i].disabled;
                }));
                wrap.select(".nv-scatterWrap").datum(data.filter(function(d) {
                    return !d.disabled;
                })).call(scatter);
                wrap.select(".nv-regressionLinesWrap").attr("clip-path", "url(#nv-edge-clip-" + scatter.id() + ")");
                var regWrap = wrap.select(".nv-regressionLinesWrap").selectAll(".nv-regLines").data(function(d) {
                    return d;
                });
                var reglines = regWrap.enter().append("g").attr("class", "nv-regLines").append("line").attr("class", "nv-regLine").style("stroke-opacity", 0);
                regWrap.selectAll(".nv-regLines line").attr("x1", x.range()[0]).attr("x2", x.range()[1]).attr("y1", function(d, i) {
                    return y(x.domain()[0] * d.slope + d.intercept);
                }).attr("y2", function(d, i) {
                    return y(x.domain()[1] * d.slope + d.intercept);
                }).style("stroke", function(d, i, j) {
                    return color(d, j);
                }).style("stroke-opacity", function(d, i) {
                    return d.disabled || typeof d.slope === "undefined" || typeof d.intercept === "undefined" ? 0 : 1;
                });
                xAxis.scale(x).ticks(xAxis.ticks() ? xAxis.ticks() : availableWidth / 100).tickSize(-availableHeight, 0);
                g.select(".nv-x.nv-axis").attr("transform", "translate(0," + y.range()[0] + ")").call(xAxis);
                yAxis.scale(y).ticks(yAxis.ticks() ? yAxis.ticks() : availableHeight / 36).tickSize(-availableWidth, 0);
                g.select(".nv-y.nv-axis").call(yAxis);
                if (showDistX) {
                    distX.getData(scatter.x()).scale(x).width(availableWidth).color(data.map(function(d, i) {
                        return d.color || color(d, i);
                    }).filter(function(d, i) {
                        return !data[i].disabled;
                    }));
                    gEnter.select(".nv-distWrap").append("g").attr("class", "nv-distributionX");
                    g.select(".nv-distributionX").attr("transform", "translate(0," + y.range()[0] + ")").datum(data.filter(function(d) {
                        return !d.disabled;
                    })).call(distX);
                }
                if (showDistY) {
                    distY.getData(scatter.y()).scale(y).width(availableHeight).color(data.map(function(d, i) {
                        return d.color || color(d, i);
                    }).filter(function(d, i) {
                        return !data[i].disabled;
                    }));
                    gEnter.select(".nv-distWrap").append("g").attr("class", "nv-distributionY");
                    g.select(".nv-distributionY").attr("transform", "translate(-" + distY.size() + ",0)").datum(data.filter(function(d) {
                        return !d.disabled;
                    })).call(distY);
                }
                if (d3.fisheye) {
                    g.select(".nv-background").attr("width", availableWidth).attr("height", availableHeight);
                    g.select(".nv-background").on("mousemove", updateFisheye);
                    g.select(".nv-background").on("click", function() {
                        pauseFisheye = !pauseFisheye;
                    });
                    scatter.dispatch.on("elementClick.freezeFisheye", function() {
                        pauseFisheye = !pauseFisheye;
                    });
                }
                function updateFisheye() {
                    if (pauseFisheye) {
                        g.select(".nv-point-paths").style("pointer-events", "all");
                        return false;
                    }
                    g.select(".nv-point-paths").style("pointer-events", "none");
                    var mouse = d3.mouse(this);
                    x.distortion(fisheye).focus(mouse[0]);
                    y.distortion(fisheye).focus(mouse[1]);
                    g.select(".nv-scatterWrap").datum(data.filter(function(d) {
                        return !d.disabled;
                    })).call(scatter);
                    g.select(".nv-x.nv-axis").call(xAxis);
                    g.select(".nv-y.nv-axis").call(yAxis);
                    g.select(".nv-distributionX").datum(data.filter(function(d) {
                        return !d.disabled;
                    })).call(distX);
                    g.select(".nv-distributionY").datum(data.filter(function(d) {
                        return !d.disabled;
                    })).call(distY);
                }
                controls.dispatch.on("legendClick", function(d, i) {
                    d.disabled = !d.disabled;
                    fisheye = d.disabled ? 0 : 2.5;
                    g.select(".nv-background").style("pointer-events", d.disabled ? "none" : "all");
                    g.select(".nv-point-paths").style("pointer-events", d.disabled ? "all" : "none");
                    if (d.disabled) {
                        x.distortion(fisheye).focus(0);
                        y.distortion(fisheye).focus(0);
                        g.select(".nv-scatterWrap").call(scatter);
                        g.select(".nv-x.nv-axis").call(xAxis);
                        g.select(".nv-y.nv-axis").call(yAxis);
                    } else {
                        pauseFisheye = false;
                    }
                    chart(selection);
                });
                legend.dispatch.on("legendClick", function(d, i, that) {
                    d.disabled = !d.disabled;
                    if (!data.filter(function(d) {
                        return !d.disabled;
                    }).length) {
                        data.map(function(d) {
                            d.disabled = false;
                            wrap.selectAll(".nv-series").classed("disabled", false);
                            return d;
                        });
                    }
                    state.disabled = data.map(function(d) {
                        return !!d.disabled;
                    });
                    dispatch.stateChange(state);
                    chart(selection);
                });
                scatter.dispatch.on("elementMouseover.tooltip", function(e) {
                    d3.select(".nv-chart-" + scatter.id() + " .nv-series-" + e.seriesIndex + " .nv-distx-" + e.pointIndex).attr("y1", e.pos[1] - availableHeight);
                    d3.select(".nv-chart-" + scatter.id() + " .nv-series-" + e.seriesIndex + " .nv-disty-" + e.pointIndex).attr("x2", e.pos[0] + distX.size());
                    e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ];
                    dispatch.tooltipShow(e);
                });
                dispatch.on("tooltipShow", function(e) {
                    if (tooltips) showTooltip(e, that.parentNode);
                });
                dispatch.on("changeState", function(e) {
                    if (typeof e.disabled !== "undefined") {
                        data.forEach(function(series, i) {
                            series.disabled = e.disabled[i];
                        });
                        state.disabled = e.disabled;
                    }
                    selection.call(chart);
                });
                x0 = x.copy();
                y0 = y.copy();
            });
            return chart;
        }
        scatter.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
            d3.select(".nv-chart-" + scatter.id() + " .nv-series-" + e.seriesIndex + " .nv-distx-" + e.pointIndex).attr("y1", 0);
            d3.select(".nv-chart-" + scatter.id() + " .nv-series-" + e.seriesIndex + " .nv-disty-" + e.pointIndex).attr("x2", distY.size());
        });
        dispatch.on("tooltipHide", function() {
            if (tooltips) nv.tooltip.cleanup();
        });
        chart.dispatch = dispatch;
        chart.scatter = scatter;
        chart.legend = legend;
        chart.controls = controls;
        chart.xAxis = xAxis;
        chart.yAxis = yAxis;
        chart.distX = distX;
        chart.distY = distY;
        d3.rebind(chart, scatter, "id", "interactive", "pointActive", "x", "y", "shape", "size", "xScale", "yScale", "zScale", "xDomain", "yDomain", "sizeDomain", "sizeRange", "forceX", "forceY", "forceSize", "clipVoronoi", "clipRadius", "useVoronoi");
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            legend.color(color);
            distX.color(color);
            distY.color(color);
            return chart;
        };
        chart.showDistX = function(_) {
            if (!arguments.length) return showDistX;
            showDistX = _;
            return chart;
        };
        chart.showDistY = function(_) {
            if (!arguments.length) return showDistY;
            showDistY = _;
            return chart;
        };
        chart.showControls = function(_) {
            if (!arguments.length) return showControls;
            showControls = _;
            return chart;
        };
        chart.showLegend = function(_) {
            if (!arguments.length) return showLegend;
            showLegend = _;
            return chart;
        };
        chart.fisheye = function(_) {
            if (!arguments.length) return fisheye;
            fisheye = _;
            return chart;
        };
        chart.tooltips = function(_) {
            if (!arguments.length) return tooltips;
            tooltips = _;
            return chart;
        };
        chart.tooltipContent = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.tooltipXContent = function(_) {
            if (!arguments.length) return tooltipX;
            tooltipX = _;
            return chart;
        };
        chart.tooltipYContent = function(_) {
            if (!arguments.length) return tooltipY;
            tooltipY = _;
            return chart;
        };
        chart.state = function(_) {
            if (!arguments.length) return state;
            state = _;
            return chart;
        };
        chart.defaultState = function(_) {
            if (!arguments.length) return defaultState;
            defaultState = _;
            return chart;
        };
        chart.noData = function(_) {
            if (!arguments.length) return noData;
            noData = _;
            return chart;
        };
        return chart;
    };
    nv.models.sparkline = function() {
        var margin = {
            top: 2,
            right: 0,
            bottom: 2,
            left: 0
        }, width = 400, height = 32, animate = true, x = d3.scale.linear(), y = d3.scale.linear(), getX = function(d) {
            return d.x;
        }, getY = function(d) {
            return d.y;
        }, color = nv.utils.getColor([ "#000" ]), xDomain, yDomain;
        function chart(selection) {
            selection.each(function(data) {
                var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom, container = d3.select(this);
                x.domain(xDomain || d3.extent(data, getX)).range([ 0, availableWidth ]);
                y.domain(yDomain || d3.extent(data, getY)).range([ availableHeight, 0 ]);
                var wrap = container.selectAll("g.nv-wrap.nv-sparkline").data([ data ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-sparkline");
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var paths = wrap.selectAll("path").data(function(d) {
                    return [ d ];
                });
                paths.enter().append("path");
                paths.exit().remove();
                paths.style("stroke", function(d, i) {
                    return d.color || color(d, i);
                }).attr("d", d3.svg.line().x(function(d, i) {
                    return x(getX(d, i));
                }).y(function(d, i) {
                    return y(getY(d, i));
                }));
                var points = wrap.selectAll("circle.nv-point").data(function(data) {
                    var yValues = data.map(function(d, i) {
                        return getY(d, i);
                    });
                    function pointIndex(index) {
                        if (index != -1) {
                            var result = data[index];
                            result.pointIndex = index;
                            return result;
                        } else {
                            return null;
                        }
                    }
                    var maxPoint = pointIndex(yValues.lastIndexOf(y.domain()[1])), minPoint = pointIndex(yValues.indexOf(y.domain()[0])), currentPoint = pointIndex(yValues.length - 1);
                    return [ minPoint, maxPoint, currentPoint ].filter(function(d) {
                        return d != null;
                    });
                });
                points.enter().append("circle");
                points.exit().remove();
                points.attr("cx", function(d, i) {
                    return x(getX(d, d.pointIndex));
                }).attr("cy", function(d, i) {
                    return y(getY(d, d.pointIndex));
                }).attr("r", 2).attr("class", function(d, i) {
                    return getX(d, d.pointIndex) == x.domain()[1] ? "nv-point nv-currentValue" : getY(d, d.pointIndex) == y.domain()[0] ? "nv-point nv-minValue" : "nv-point nv-maxValue";
                });
            });
            return chart;
        }
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.x = function(_) {
            if (!arguments.length) return getX;
            getX = d3.functor(_);
            return chart;
        };
        chart.y = function(_) {
            if (!arguments.length) return getY;
            getY = d3.functor(_);
            return chart;
        };
        chart.xScale = function(_) {
            if (!arguments.length) return x;
            x = _;
            return chart;
        };
        chart.yScale = function(_) {
            if (!arguments.length) return y;
            y = _;
            return chart;
        };
        chart.xDomain = function(_) {
            if (!arguments.length) return xDomain;
            xDomain = _;
            return chart;
        };
        chart.yDomain = function(_) {
            if (!arguments.length) return yDomain;
            yDomain = _;
            return chart;
        };
        chart.animate = function(_) {
            if (!arguments.length) return animate;
            animate = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            return chart;
        };
        return chart;
    };
    nv.models.sparklinePlus = function() {
        var sparkline = nv.models.sparkline();
        var margin = {
            top: 15,
            right: 100,
            bottom: 10,
            left: 50
        }, width = null, height = null, x, y, index = [], paused = false, xTickFormat = d3.format(",r"), yTickFormat = d3.format(",.2f"), showValue = true, alignValue = true, rightAlignValue = false, noData = "No Data Available.";
        function chart(selection) {
            selection.each(function(data) {
                var container = d3.select(this);
                var availableWidth = (width || parseInt(container.style("width")) || 960) - margin.left - margin.right, availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                chart.update = function() {
                    chart(selection);
                };
                chart.container = this;
                if (!data || !data.length) {
                    var noDataText = container.selectAll(".nv-noData").data([ noData ]);
                    noDataText.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle");
                    noDataText.attr("x", margin.left + availableWidth / 2).attr("y", margin.top + availableHeight / 2).text(function(d) {
                        return d;
                    });
                    return chart;
                } else {
                    container.selectAll(".nv-noData").remove();
                }
                var currentValue = sparkline.y()(data[data.length - 1], data.length - 1);
                x = sparkline.xScale();
                y = sparkline.yScale();
                var wrap = container.selectAll("g.nv-wrap.nv-sparklineplus").data([ data ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-sparklineplus");
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-sparklineWrap");
                gEnter.append("g").attr("class", "nv-valueWrap");
                gEnter.append("g").attr("class", "nv-hoverArea");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var sparklineWrap = g.select(".nv-sparklineWrap");
                sparkline.width(availableWidth).height(availableHeight);
                sparklineWrap.call(sparkline);
                var valueWrap = g.select(".nv-valueWrap");
                var value = valueWrap.selectAll(".nv-currentValue").data([ currentValue ]);
                value.enter().append("text").attr("class", "nv-currentValue").attr("dx", rightAlignValue ? -8 : 8).attr("dy", ".9em").style("text-anchor", rightAlignValue ? "end" : "start");
                value.attr("x", availableWidth + (rightAlignValue ? margin.right : 0)).attr("y", alignValue ? function(d) {
                    return y(d);
                } : 0).style("fill", sparkline.color()(data[data.length - 1], data.length - 1)).text(yTickFormat(currentValue));
                gEnter.select(".nv-hoverArea").append("rect").on("mousemove", sparklineHover).on("click", function() {
                    paused = !paused;
                }).on("mouseout", function() {
                    index = [];
                    updateValueLine();
                });
                g.select(".nv-hoverArea rect").attr("transform", function(d) {
                    return "translate(" + -margin.left + "," + -margin.top + ")";
                }).attr("width", availableWidth + margin.left + margin.right).attr("height", availableHeight + margin.top);
                function updateValueLine() {
                    if (paused) return;
                    var hoverValue = g.selectAll(".nv-hoverValue").data(index);
                    var hoverEnter = hoverValue.enter().append("g").attr("class", "nv-hoverValue").style("stroke-opacity", 0).style("fill-opacity", 0);
                    hoverValue.exit().transition().duration(250).style("stroke-opacity", 0).style("fill-opacity", 0).remove();
                    hoverValue.attr("transform", function(d) {
                        return "translate(" + x(sparkline.x()(data[d], d)) + ",0)";
                    }).transition().duration(250).style("stroke-opacity", 1).style("fill-opacity", 1);
                    if (!index.length) return;
                    hoverEnter.append("line").attr("x1", 0).attr("y1", -margin.top).attr("x2", 0).attr("y2", availableHeight);
                    hoverEnter.append("text").attr("class", "nv-xValue").attr("x", -6).attr("y", -margin.top).attr("text-anchor", "end").attr("dy", ".9em");
                    g.select(".nv-hoverValue .nv-xValue").text(xTickFormat(sparkline.x()(data[index[0]], index[0])));
                    hoverEnter.append("text").attr("class", "nv-yValue").attr("x", 6).attr("y", -margin.top).attr("text-anchor", "start").attr("dy", ".9em");
                    g.select(".nv-hoverValue .nv-yValue").text(yTickFormat(sparkline.y()(data[index[0]], index[0])));
                }
                function sparklineHover() {
                    if (paused) return;
                    var pos = d3.mouse(this)[0] - margin.left;
                    function getClosestIndex(data, x) {
                        var distance = Math.abs(sparkline.x()(data[0], 0) - x);
                        var closestIndex = 0;
                        for (var i = 0; i < data.length; i++) {
                            if (Math.abs(sparkline.x()(data[i], i) - x) < distance) {
                                distance = Math.abs(sparkline.x()(data[i], i) - x);
                                closestIndex = i;
                            }
                        }
                        return closestIndex;
                    }
                    index = [ getClosestIndex(data, Math.round(x.invert(pos))) ];
                    updateValueLine();
                }
            });
            return chart;
        }
        chart.sparkline = sparkline;
        d3.rebind(chart, sparkline, "x", "y", "xScale", "yScale", "color");
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.xTickFormat = function(_) {
            if (!arguments.length) return xTickFormat;
            xTickFormat = _;
            return chart;
        };
        chart.yTickFormat = function(_) {
            if (!arguments.length) return yTickFormat;
            yTickFormat = _;
            return chart;
        };
        chart.showValue = function(_) {
            if (!arguments.length) return showValue;
            showValue = _;
            return chart;
        };
        chart.alignValue = function(_) {
            if (!arguments.length) return alignValue;
            alignValue = _;
            return chart;
        };
        chart.rightAlignValue = function(_) {
            if (!arguments.length) return rightAlignValue;
            rightAlignValue = _;
            return chart;
        };
        chart.noData = function(_) {
            if (!arguments.length) return noData;
            noData = _;
            return chart;
        };
        return chart;
    };
    nv.models.stackedArea = function() {
        var margin = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, width = 960, height = 500, color = nv.utils.defaultColor(), id = Math.floor(Math.random() * 1e5), getX = function(d) {
            return d.x;
        }, getY = function(d) {
            return d.y;
        }, style = "stack", offset = "zero", order = "default", interpolate = "linear", clipEdge = false, x, y, scatter = nv.models.scatter(), dispatch = d3.dispatch("tooltipShow", "tooltipHide", "areaClick", "areaMouseover", "areaMouseout");
        scatter.size(2.2).sizeDomain([ 2.2, 2.2 ]);
        function chart(selection) {
            selection.each(function(data) {
                var availableWidth = width - margin.left - margin.right, availableHeight = height - margin.top - margin.bottom, container = d3.select(this);
                x = scatter.xScale();
                y = scatter.yScale();
                data = data.map(function(aseries, i) {
                    aseries.values = aseries.values.map(function(d, j) {
                        d.index = j;
                        d.stackedY = aseries.disabled ? 0 : getY(d, j);
                        return d;
                    });
                    return aseries;
                });
                data = d3.layout.stack().order(order).offset(offset).values(function(d) {
                    return d.values;
                }).x(getX).y(function(d) {
                    return d.stackedY;
                }).out(function(d, y0, y) {
                    d.display = {
                        y: y,
                        y0: y0
                    };
                })(data);
                var wrap = container.selectAll("g.nv-wrap.nv-stackedarea").data([ data ]);
                var wrapEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-stackedarea");
                var defsEnter = wrapEnter.append("defs");
                var gEnter = wrapEnter.append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-areaWrap");
                gEnter.append("g").attr("class", "nv-scatterWrap");
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                scatter.width(availableWidth).height(availableHeight).x(getX).y(function(d) {
                    return d.display.y + d.display.y0;
                }).forceY([ 0 ]).color(data.map(function(d, i) {
                    return d.color || color(d, i);
                }).filter(function(d, i) {
                    return !data[i].disabled;
                }));
                var scatterWrap = g.select(".nv-scatterWrap").datum(data.filter(function(d) {
                    return !d.disabled;
                }));
                scatterWrap.call(scatter);
                defsEnter.append("clipPath").attr("id", "nv-edge-clip-" + id).append("rect");
                wrap.select("#nv-edge-clip-" + id + " rect").attr("width", availableWidth).attr("height", availableHeight);
                g.attr("clip-path", clipEdge ? "url(#nv-edge-clip-" + id + ")" : "");
                var area = d3.svg.area().x(function(d, i) {
                    return x(getX(d, i));
                }).y0(function(d) {
                    return y(d.display.y0);
                }).y1(function(d) {
                    return y(d.display.y + d.display.y0);
                }).interpolate(interpolate);
                var zeroArea = d3.svg.area().x(function(d, i) {
                    return x(getX(d, i));
                }).y0(function(d) {
                    return y(d.display.y0);
                }).y1(function(d) {
                    return y(d.display.y0);
                });
                var path = g.select(".nv-areaWrap").selectAll("path.nv-area").data(function(d) {
                    return d;
                });
                path.enter().append("path").attr("class", function(d, i) {
                    return "nv-area nv-area-" + i;
                }).on("mouseover", function(d, i) {
                    d3.select(this).classed("hover", true);
                    dispatch.areaMouseover({
                        point: d,
                        series: d.key,
                        pos: [ d3.event.pageX, d3.event.pageY ],
                        seriesIndex: i
                    });
                }).on("mouseout", function(d, i) {
                    d3.select(this).classed("hover", false);
                    dispatch.areaMouseout({
                        point: d,
                        series: d.key,
                        pos: [ d3.event.pageX, d3.event.pageY ],
                        seriesIndex: i
                    });
                }).on("click", function(d, i) {
                    d3.select(this).classed("hover", false);
                    dispatch.areaClick({
                        point: d,
                        series: d.key,
                        pos: [ d3.event.pageX, d3.event.pageY ],
                        seriesIndex: i
                    });
                });
                path.exit().attr("d", function(d, i) {
                    return zeroArea(d.values, i);
                }).remove();
                path.style("fill", function(d, i) {
                    return d.color || color(d, i);
                }).style("stroke", function(d, i) {
                    return d.color || color(d, i);
                });
                path.attr("d", function(d, i) {
                    return area(d.values, i);
                });
                scatter.dispatch.on("elementMouseover.area", function(e) {
                    g.select(".nv-chart-" + id + " .nv-area-" + e.seriesIndex).classed("hover", true);
                });
                scatter.dispatch.on("elementMouseout.area", function(e) {
                    g.select(".nv-chart-" + id + " .nv-area-" + e.seriesIndex).classed("hover", false);
                });
            });
            return chart;
        }
        scatter.dispatch.on("elementClick.area", function(e) {
            dispatch.areaClick(e);
        });
        scatter.dispatch.on("elementMouseover.tooltip", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ], dispatch.tooltipShow(e);
        });
        scatter.dispatch.on("elementMouseout.tooltip", function(e) {
            dispatch.tooltipHide(e);
        });
        chart.dispatch = dispatch;
        chart.scatter = scatter;
        d3.rebind(chart, scatter, "interactive", "size", "xScale", "yScale", "zScale", "xDomain", "yDomain", "sizeDomain", "forceX", "forceY", "forceSize", "clipVoronoi", "clipRadius");
        chart.x = function(_) {
            if (!arguments.length) return getX;
            getX = d3.functor(_);
            return chart;
        };
        chart.y = function(_) {
            if (!arguments.length) return getY;
            getY = d3.functor(_);
            return chart;
        };
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return width;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return height;
            height = _;
            return chart;
        };
        chart.clipEdge = function(_) {
            if (!arguments.length) return clipEdge;
            clipEdge = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            return chart;
        };
        chart.offset = function(_) {
            if (!arguments.length) return offset;
            offset = _;
            return chart;
        };
        chart.order = function(_) {
            if (!arguments.length) return order;
            order = _;
            return chart;
        };
        chart.style = function(_) {
            if (!arguments.length) return style;
            style = _;
            switch (style) {
              case "stack":
                chart.offset("zero");
                chart.order("default");
                break;

              case "stream":
                chart.offset("wiggle");
                chart.order("inside-out");
                break;

              case "stream-center":
                chart.offset("silhouette");
                chart.order("inside-out");
                break;

              case "expand":
                chart.offset("expand");
                chart.order("default");
                break;
            }
            return chart;
        };
        chart.interpolate = function(_) {
            if (!arguments.length) return interpolate;
            interpolate = _;
            return interpolate;
        };
        return chart;
    };
    nv.models.stackedAreaChart = function() {
        var stacked = nv.models.stackedArea(), xAxis = nv.models.axis(), yAxis = nv.models.axis(), legend = nv.models.legend(), controls = nv.models.legend();
        var margin = {
            top: 30,
            right: 25,
            bottom: 50,
            left: 60
        }, width = null, height = null, color = nv.utils.defaultColor(), showControls = true, showLegend = true, tooltips = true, tooltip = function(key, x, y, e, graph) {
            return "<h3>" + key + "</h3>" + "<p>" + y + " on " + x + "</p>";
        }, x, y, yAxisTickFormat = d3.format(",.2f"), state = {
            style: stacked.style()
        }, defaultState = null, noData = "No Data Available.", dispatch = d3.dispatch("tooltipShow", "tooltipHide", "stateChange", "changeState"), controlWidth = 250;
        xAxis.orient("bottom").tickPadding(7);
        yAxis.orient("left");
        stacked.scatter.pointActive(function(d) {
            return !!Math.round(stacked.y()(d) * 100);
        });
        var showTooltip = function(e, offsetElement) {
            var left = e.pos[0] + (offsetElement.offsetLeft || 0), top = e.pos[1] + (offsetElement.offsetTop || 0), x = xAxis.tickFormat()(stacked.x()(e.point, e.pointIndex)), y = yAxis.tickFormat()(stacked.y()(e.point, e.pointIndex)), content = tooltip(e.series.key, x, y, e, chart);
            nv.tooltip.show([ left, top ], content, e.value < 0 ? "n" : "s", null, offsetElement);
        };
        function chart(selection) {
            selection.each(function(data) {
                var container = d3.select(this), that = this;
                var availableWidth = (width || parseInt(container.style("width")) || 960) - margin.left - margin.right, availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                chart.update = function() {
                    chart(selection);
                };
                chart.container = this;
                state.disabled = data.map(function(d) {
                    return !!d.disabled;
                });
                if (!defaultState) {
                    var key;
                    defaultState = {};
                    for (key in state) {
                        if (state[key] instanceof Array) defaultState[key] = state[key].slice(0); else defaultState[key] = state[key];
                    }
                }
                if (!data || !data.length || !data.filter(function(d) {
                    return d.values.length;
                }).length) {
                    var noDataText = container.selectAll(".nv-noData").data([ noData ]);
                    noDataText.enter().append("text").attr("class", "nvd3 nv-noData").attr("dy", "-.7em").style("text-anchor", "middle");
                    noDataText.attr("x", margin.left + availableWidth / 2).attr("y", margin.top + availableHeight / 2).text(function(d) {
                        return d;
                    });
                    return chart;
                } else {
                    container.selectAll(".nv-noData").remove();
                }
                x = stacked.xScale();
                y = stacked.yScale();
                var wrap = container.selectAll("g.nv-wrap.nv-stackedAreaChart").data([ data ]);
                var gEnter = wrap.enter().append("g").attr("class", "nvd3 nv-wrap nv-stackedAreaChart").append("g");
                var g = wrap.select("g");
                gEnter.append("g").attr("class", "nv-x nv-axis");
                gEnter.append("g").attr("class", "nv-y nv-axis");
                gEnter.append("g").attr("class", "nv-stackedWrap");
                gEnter.append("g").attr("class", "nv-legendWrap");
                gEnter.append("g").attr("class", "nv-controlsWrap");
                if (showLegend) {
                    legend.width(availableWidth - controlWidth);
                    g.select(".nv-legendWrap").datum(data).call(legend);
                    if (margin.top != legend.height()) {
                        margin.top = legend.height();
                        availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                    }
                    g.select(".nv-legendWrap").attr("transform", "translate(" + controlWidth + "," + -margin.top + ")");
                }
                if (showControls) {
                    var controlsData = [ {
                        key: "Stacked",
                        disabled: stacked.offset() != "zero"
                    }, {
                        key: "Stream",
                        disabled: stacked.offset() != "wiggle"
                    }, {
                        key: "Expanded",
                        disabled: stacked.offset() != "expand"
                    } ];
                    controls.width(controlWidth).color([ "#444", "#444", "#444" ]);
                    g.select(".nv-controlsWrap").datum(controlsData).call(controls);
                    if (margin.top != Math.max(controls.height(), legend.height())) {
                        margin.top = Math.max(controls.height(), legend.height());
                        availableHeight = (height || parseInt(container.style("height")) || 400) - margin.top - margin.bottom;
                    }
                    g.select(".nv-controlsWrap").attr("transform", "translate(0," + -margin.top + ")");
                }
                wrap.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                stacked.width(availableWidth).height(availableHeight);
                var stackedWrap = g.select(".nv-stackedWrap").datum(data);
                stackedWrap.call(stacked);
                xAxis.scale(x).ticks(availableWidth / 100).tickSize(-availableHeight, 0);
                g.select(".nv-x.nv-axis").attr("transform", "translate(0," + availableHeight + ")");
                g.select(".nv-x.nv-axis").transition().duration(0).call(xAxis);
                yAxis.scale(y).ticks(stacked.offset() == "wiggle" ? 0 : availableHeight / 36).tickSize(-availableWidth, 0).setTickFormat(stacked.offset() == "expand" ? d3.format("%") : yAxisTickFormat);
                g.select(".nv-y.nv-axis").transition().duration(0).call(yAxis);
                stacked.dispatch.on("areaClick.toggle", function(e) {
                    if (data.filter(function(d) {
                        return !d.disabled;
                    }).length === 1) data = data.map(function(d) {
                        d.disabled = false;
                        return d;
                    }); else data = data.map(function(d, i) {
                        d.disabled = i != e.seriesIndex;
                        return d;
                    });
                    state.disabled = data.map(function(d) {
                        return !!d.disabled;
                    });
                    dispatch.stateChange(state);
                    chart(selection);
                });
                legend.dispatch.on("legendClick", function(d, i) {
                    d.disabled = !d.disabled;
                    if (!data.filter(function(d) {
                        return !d.disabled;
                    }).length) {
                        data.map(function(d) {
                            d.disabled = false;
                            return d;
                        });
                    }
                    state.disabled = data.map(function(d) {
                        return !!d.disabled;
                    });
                    dispatch.stateChange(state);
                    chart(selection);
                });
                controls.dispatch.on("legendClick", function(d, i) {
                    if (!d.disabled) return;
                    controlsData = controlsData.map(function(s) {
                        s.disabled = true;
                        return s;
                    });
                    d.disabled = false;
                    switch (d.key) {
                      case "Stacked":
                        stacked.style("stack");
                        break;

                      case "Stream":
                        stacked.style("stream");
                        break;

                      case "Expanded":
                        stacked.style("expand");
                        break;
                    }
                    state.style = stacked.style();
                    dispatch.stateChange(state);
                    chart(selection);
                });
                dispatch.on("tooltipShow", function(e) {
                    if (tooltips) showTooltip(e, that.parentNode);
                });
                dispatch.on("changeState", function(e) {
                    if (typeof e.disabled !== "undefined") {
                        data.forEach(function(series, i) {
                            series.disabled = e.disabled[i];
                        });
                        state.disabled = e.disabled;
                    }
                    if (typeof e.style !== "undefined") {
                        stacked.style(e.style);
                    }
                    selection.call(chart);
                });
            });
            return chart;
        }
        stacked.dispatch.on("tooltipShow", function(e) {
            e.pos = [ e.pos[0] + margin.left, e.pos[1] + margin.top ], dispatch.tooltipShow(e);
        });
        stacked.dispatch.on("tooltipHide", function(e) {
            dispatch.tooltipHide(e);
        });
        dispatch.on("tooltipHide", function() {
            if (tooltips) nv.tooltip.cleanup();
        });
        chart.dispatch = dispatch;
        chart.stacked = stacked;
        chart.legend = legend;
        chart.controls = controls;
        chart.xAxis = xAxis;
        chart.yAxis = yAxis;
        d3.rebind(chart, stacked, "x", "y", "size", "xScale", "yScale", "xDomain", "yDomain", "sizeDomain", "interactive", "offset", "order", "style", "clipEdge", "forceX", "forceY", "forceSize", "interpolate");
        chart.margin = function(_) {
            if (!arguments.length) return margin;
            margin.top = typeof _.top != "undefined" ? _.top : margin.top;
            margin.right = typeof _.right != "undefined" ? _.right : margin.right;
            margin.bottom = typeof _.bottom != "undefined" ? _.bottom : margin.bottom;
            margin.left = typeof _.left != "undefined" ? _.left : margin.left;
            return chart;
        };
        chart.width = function(_) {
            if (!arguments.length) return getWidth;
            width = _;
            return chart;
        };
        chart.height = function(_) {
            if (!arguments.length) return getHeight;
            height = _;
            return chart;
        };
        chart.color = function(_) {
            if (!arguments.length) return color;
            color = nv.utils.getColor(_);
            legend.color(color);
            stacked.color(color);
            return chart;
        };
        chart.showControls = function(_) {
            if (!arguments.length) return showControls;
            showControls = _;
            return chart;
        };
        chart.showLegend = function(_) {
            if (!arguments.length) return showLegend;
            showLegend = _;
            return chart;
        };
        chart.tooltip = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.tooltips = function(_) {
            if (!arguments.length) return tooltips;
            tooltips = _;
            return chart;
        };
        chart.tooltipContent = function(_) {
            if (!arguments.length) return tooltip;
            tooltip = _;
            return chart;
        };
        chart.state = function(_) {
            if (!arguments.length) return state;
            state = _;
            return chart;
        };
        chart.defaultState = function(_) {
            if (!arguments.length) return defaultState;
            defaultState = _;
            return chart;
        };
        chart.noData = function(_) {
            if (!arguments.length) return noData;
            noData = _;
            return chart;
        };
        yAxis.setTickFormat = yAxis.tickFormat;
        yAxis.tickFormat = function(_) {
            if (!arguments.length) return yAxisTickFormat;
            yAxisTickFormat = _;
            return yAxis;
        };
        return chart;
    };
})();

(function(undefined) {
    var moment, VERSION = "2.0.0", round = Math.round, i, languages = {}, hasModule = typeof module !== "undefined" && module.exports, aspNetJsonRegex = /^\/?Date\((\-?\d+)/i, formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g, parseMultipleFormatChunker = /([0-9a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+)/gi, parseTokenOneOrTwoDigits = /\d\d?/, parseTokenOneToThreeDigits = /\d{1,3}/, parseTokenThreeDigits = /\d{3}/, parseTokenFourDigits = /\d{1,4}/, parseTokenSixDigits = /[+\-]?\d{1,6}/, parseTokenWord = /[0-9]*[a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF]+\s*?[\u0600-\u06FF]+/i, parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i, parseTokenT = /T/i, parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, isoRegex = /^\s*\d{4}-\d\d-\d\d((T| )(\d\d(:\d\d(:\d\d(\.\d\d?\d?)?)?)?)?([\+\-]\d\d:?\d\d)?)?/, isoFormat = "YYYY-MM-DDTHH:mm:ssZ", isoTimes = [ [ "HH:mm:ss.S", /(T| )\d\d:\d\d:\d\d\.\d{1,3}/ ], [ "HH:mm:ss", /(T| )\d\d:\d\d:\d\d/ ], [ "HH:mm", /(T| )\d\d:\d\d/ ], [ "HH", /(T| )\d\d/ ] ], parseTimezoneChunker = /([\+\-]|\d\d)/gi, proxyGettersAndSetters = "Month|Date|Hours|Minutes|Seconds|Milliseconds".split("|"), unitMillisecondFactors = {
        Milliseconds: 1,
        Seconds: 1e3,
        Minutes: 6e4,
        Hours: 36e5,
        Days: 864e5,
        Months: 2592e6,
        Years: 31536e6
    }, formatFunctions = {}, ordinalizeTokens = "DDD w W M D d".split(" "), paddedTokens = "M D H h m s w W".split(" "), formatTokenFunctions = {
        M: function() {
            return this.month() + 1;
        },
        MMM: function(format) {
            return this.lang().monthsShort(this, format);
        },
        MMMM: function(format) {
            return this.lang().months(this, format);
        },
        D: function() {
            return this.date();
        },
        DDD: function() {
            return this.dayOfYear();
        },
        d: function() {
            return this.day();
        },
        dd: function(format) {
            return this.lang().weekdaysMin(this, format);
        },
        ddd: function(format) {
            return this.lang().weekdaysShort(this, format);
        },
        dddd: function(format) {
            return this.lang().weekdays(this, format);
        },
        w: function() {
            return this.week();
        },
        W: function() {
            return this.isoWeek();
        },
        YY: function() {
            return leftZeroFill(this.year() % 100, 2);
        },
        YYYY: function() {
            return leftZeroFill(this.year(), 4);
        },
        YYYYY: function() {
            return leftZeroFill(this.year(), 5);
        },
        a: function() {
            return this.lang().meridiem(this.hours(), this.minutes(), true);
        },
        A: function() {
            return this.lang().meridiem(this.hours(), this.minutes(), false);
        },
        H: function() {
            return this.hours();
        },
        h: function() {
            return this.hours() % 12 || 12;
        },
        m: function() {
            return this.minutes();
        },
        s: function() {
            return this.seconds();
        },
        S: function() {
            return ~~(this.milliseconds() / 100);
        },
        SS: function() {
            return leftZeroFill(~~(this.milliseconds() / 10), 2);
        },
        SSS: function() {
            return leftZeroFill(this.milliseconds(), 3);
        },
        Z: function() {
            var a = -this.zone(), b = "+";
            if (a < 0) {
                a = -a;
                b = "-";
            }
            return b + leftZeroFill(~~(a / 60), 2) + ":" + leftZeroFill(~~a % 60, 2);
        },
        ZZ: function() {
            var a = -this.zone(), b = "+";
            if (a < 0) {
                a = -a;
                b = "-";
            }
            return b + leftZeroFill(~~(10 * a / 6), 4);
        },
        X: function() {
            return this.unix();
        }
    };
    function padToken(func, count) {
        return function(a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func) {
        return function(a) {
            return this.lang().ordinal(func.call(this, a));
        };
    }
    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + "o"] = ordinalizeToken(formatTokenFunctions[i]);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
    function Language() {}
    function Moment(config) {
        extend(this, config);
    }
    function Duration(duration) {
        var data = this._data = {}, years = duration.years || duration.year || duration.y || 0, months = duration.months || duration.month || duration.M || 0, weeks = duration.weeks || duration.week || duration.w || 0, days = duration.days || duration.day || duration.d || 0, hours = duration.hours || duration.hour || duration.h || 0, minutes = duration.minutes || duration.minute || duration.m || 0, seconds = duration.seconds || duration.second || duration.s || 0, milliseconds = duration.milliseconds || duration.millisecond || duration.ms || 0;
        this._milliseconds = milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;
        this._days = days + weeks * 7;
        this._months = months + years * 12;
        data.milliseconds = milliseconds % 1e3;
        seconds += absRound(milliseconds / 1e3);
        data.seconds = seconds % 60;
        minutes += absRound(seconds / 60);
        data.minutes = minutes % 60;
        hours += absRound(minutes / 60);
        data.hours = hours % 24;
        days += absRound(hours / 24);
        days += weeks * 7;
        data.days = days % 30;
        months += absRound(days / 30);
        data.months = months % 12;
        years += absRound(months / 12);
        data.years = years;
    }
    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }
        return a;
    }
    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }
    function leftZeroFill(number, targetLength) {
        var output = number + "";
        while (output.length < targetLength) {
            output = "0" + output;
        }
        return output;
    }
    function addOrSubtractDurationFromMoment(mom, duration, isAdding) {
        var ms = duration._milliseconds, d = duration._days, M = duration._months, currentDate;
        if (ms) {
            mom._d.setTime(+mom + ms * isAdding);
        }
        if (d) {
            mom.date(mom.date() + d * isAdding);
        }
        if (M) {
            currentDate = mom.date();
            mom.date(1).month(mom.month() + M * isAdding).date(Math.min(currentDate, mom.daysInMonth()));
        }
    }
    function isArray(input) {
        return Object.prototype.toString.call(input) === "[object Array]";
    }
    function compareArrays(array1, array2) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
            if (~~array1[i] !== ~~array2[i]) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    Language.prototype = {
        set: function(config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === "function") {
                    this[i] = prop;
                } else {
                    this["_" + i] = prop;
                }
            }
        },
        _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months: function(m) {
            return this._months[m.month()];
        },
        _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort: function(m) {
            return this._monthsShort[m.month()];
        },
        monthsParse: function(monthName) {
            var i, mom, regex, output;
            if (!this._monthsParse) {
                this._monthsParse = [];
            }
            for (i = 0; i < 12; i++) {
                if (!this._monthsParse[i]) {
                    mom = moment([ 2e3, i ]);
                    regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                    this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
                }
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },
        _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays: function(m) {
            return this._weekdays[m.day()];
        },
        _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort: function(m) {
            return this._weekdaysShort[m.day()];
        },
        _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin: function(m) {
            return this._weekdaysMin[m.day()];
        },
        _longDateFormat: {
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D YYYY",
            LLL: "MMMM D YYYY LT",
            LLLL: "dddd, MMMM D YYYY LT"
        },
        longDateFormat: function(key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function(val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "pm" : "PM";
            } else {
                return isLower ? "am" : "AM";
            }
        },
        _calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[last] dddd [at] LT",
            sameElse: "L"
        },
        calendar: function(key, mom) {
            var output = this._calendar[key];
            return typeof output === "function" ? output.apply(mom) : output;
        },
        _relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        relativeTime: function(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return typeof output === "function" ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        },
        pastFuture: function(diff, output) {
            var format = this._relativeTime[diff > 0 ? "future" : "past"];
            return typeof format === "function" ? format(output) : format.replace(/%s/i, output);
        },
        ordinal: function(number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal: "%d",
        preparse: function(string) {
            return string;
        },
        postformat: function(string) {
            return string;
        },
        week: function(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy);
        },
        _week: {
            dow: 0,
            doy: 6
        }
    };
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }
    function getLangDefinition(key) {
        if (!key) {
            return moment.fn._lang;
        }
        if (!languages[key] && hasModule) {
            require("./lang/" + key);
        }
        return languages[key];
    }
    function removeFormattingTokens(input) {
        if (input.match(/\[.*\]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
        return function(mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += typeof array[i].call === "function" ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }
    function formatMoment(m, format) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return m.lang().longDateFormat(input) || input;
        }
        while (i-- && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        }
        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }
        return formatFunctions[format](m);
    }
    function getParseRegexForToken(token) {
        switch (token) {
          case "DDDD":
            return parseTokenThreeDigits;

          case "YYYY":
            return parseTokenFourDigits;

          case "YYYYY":
            return parseTokenSixDigits;

          case "S":
          case "SS":
          case "SSS":
          case "DDD":
            return parseTokenOneToThreeDigits;

          case "MMM":
          case "MMMM":
          case "dd":
          case "ddd":
          case "dddd":
          case "a":
          case "A":
            return parseTokenWord;

          case "X":
            return parseTokenTimestampMs;

          case "Z":
          case "ZZ":
            return parseTokenTimezone;

          case "T":
            return parseTokenT;

          case "MM":
          case "DD":
          case "YY":
          case "HH":
          case "hh":
          case "mm":
          case "ss":
          case "M":
          case "D":
          case "d":
          case "H":
          case "h":
          case "m":
          case "s":
            return parseTokenOneOrTwoDigits;

          default:
            return new RegExp(token.replace("\\", ""));
        }
    }
    function addTimeToArrayFromToken(token, input, config) {
        var a, b, datePartArray = config._a;
        switch (token) {
          case "M":
          case "MM":
            datePartArray[1] = input == null ? 0 : ~~input - 1;
            break;

          case "MMM":
          case "MMMM":
            a = getLangDefinition(config._l).monthsParse(input);
            if (a != null) {
                datePartArray[1] = a;
            } else {
                config._isValid = false;
            }
            break;

          case "D":
          case "DD":
          case "DDD":
          case "DDDD":
            if (input != null) {
                datePartArray[2] = ~~input;
            }
            break;

          case "YY":
            datePartArray[0] = ~~input + (~~input > 68 ? 1900 : 2e3);
            break;

          case "YYYY":
          case "YYYYY":
            datePartArray[0] = ~~input;
            break;

          case "a":
          case "A":
            config._isPm = (input + "").toLowerCase() === "pm";
            break;

          case "H":
          case "HH":
          case "h":
          case "hh":
            datePartArray[3] = ~~input;
            break;

          case "m":
          case "mm":
            datePartArray[4] = ~~input;
            break;

          case "s":
          case "ss":
            datePartArray[5] = ~~input;
            break;

          case "S":
          case "SS":
          case "SSS":
            datePartArray[6] = ~~(("0." + input) * 1e3);
            break;

          case "X":
            config._d = new Date(parseFloat(input) * 1e3);
            break;

          case "Z":
          case "ZZ":
            config._useUTC = true;
            a = (input + "").match(parseTimezoneChunker);
            if (a && a[1]) {
                config._tzh = ~~a[1];
            }
            if (a && a[2]) {
                config._tzm = ~~a[2];
            }
            if (a && a[0] === "+") {
                config._tzh = -config._tzh;
                config._tzm = -config._tzm;
            }
            break;
        }
        if (input == null) {
            config._isValid = false;
        }
    }
    function dateFromArray(config) {
        var i, date, input = [];
        if (config._d) {
            return;
        }
        for (i = 0; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        input[3] += config._tzh || 0;
        input[4] += config._tzm || 0;
        date = new Date(0);
        if (config._useUTC) {
            date.setUTCFullYear(input[0], input[1], input[2]);
            date.setUTCHours(input[3], input[4], input[5], input[6]);
        } else {
            date.setFullYear(input[0], input[1], input[2]);
            date.setHours(input[3], input[4], input[5], input[6]);
        }
        config._d = date;
    }
    function makeDateFromStringAndFormat(config) {
        var tokens = config._f.match(formattingTokens), string = config._i, i, parsedInput;
        config._a = [];
        for (i = 0; i < tokens.length; i++) {
            parsedInput = (getParseRegexForToken(tokens[i]).exec(string) || [])[0];
            if (parsedInput) {
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            }
            if (formatTokenFunctions[tokens[i]]) {
                addTimeToArrayFromToken(tokens[i], parsedInput, config);
            }
        }
        if (config._isPm && config._a[3] < 12) {
            config._a[3] += 12;
        }
        if (config._isPm === false && config._a[3] === 12) {
            config._a[3] = 0;
        }
        dateFromArray(config);
    }
    function makeDateFromStringAndArray(config) {
        var tempConfig, tempMoment, bestMoment, scoreToBeat = 99, i, currentDate, currentScore;
        while (config._f.length) {
            tempConfig = extend({}, config);
            tempConfig._f = config._f.pop();
            makeDateFromStringAndFormat(tempConfig);
            tempMoment = new Moment(tempConfig);
            if (tempMoment.isValid()) {
                bestMoment = tempMoment;
                break;
            }
            currentScore = compareArrays(tempConfig._a, tempMoment.toArray());
            if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempMoment;
            }
        }
        extend(config, bestMoment);
    }
    function makeDateFromString(config) {
        var i, string = config._i;
        if (isoRegex.exec(string)) {
            config._f = "YYYY-MM-DDT";
            for (i = 0; i < 4; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (parseTokenTimezone.exec(string)) {
                config._f += " Z";
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._d = new Date(string);
        }
    }
    function makeDateFromInput(config) {
        var input = config._i, matched = aspNetJsonRegex.exec(input);
        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === "string") {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromArray(config);
        } else {
            config._d = input instanceof Date ? new Date(+input) : new Date(input);
        }
    }
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1e3), minutes = round(seconds / 60), hours = round(minutes / 60), days = round(hours / 24), years = round(days / 365), args = seconds < 45 && [ "s", seconds ] || minutes === 1 && [ "m" ] || minutes < 45 && [ "mm", minutes ] || hours === 1 && [ "h" ] || hours < 22 && [ "hh", hours ] || days === 1 && [ "d" ] || days <= 25 && [ "dd", days ] || days <= 45 && [ "M" ] || days < 345 && [ "MM", round(days / 30) ] || years === 1 && [ "y" ] || [ "yy", years ];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day();
        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }
        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }
        return Math.ceil(moment(mom).add("d", daysToDayOfWeek).dayOfYear() / 7);
    }
    function makeMoment(config) {
        var input = config._i, format = config._f;
        if (input === null || input === "") {
            return null;
        }
        if (typeof input === "string") {
            config._i = input = getLangDefinition().preparse(input);
        }
        if (moment.isMoment(input)) {
            config = extend({}, input);
            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }
        return new Moment(config);
    }
    moment = function(input, format, lang) {
        return makeMoment({
            _i: input,
            _f: format,
            _l: lang,
            _isUTC: false
        });
    };
    moment.utc = function(input, format, lang) {
        return makeMoment({
            _useUTC: true,
            _isUTC: true,
            _l: lang,
            _i: input,
            _f: format
        });
    };
    moment.unix = function(input) {
        return moment(input * 1e3);
    };
    moment.duration = function(input, key) {
        var isDuration = moment.isDuration(input), isNumber = typeof input === "number", duration = isDuration ? input._data : isNumber ? {} : input, ret;
        if (isNumber) {
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        }
        ret = new Duration(duration);
        if (isDuration && input.hasOwnProperty("_lang")) {
            ret._lang = input._lang;
        }
        return ret;
    };
    moment.version = VERSION;
    moment.defaultFormat = isoFormat;
    moment.lang = function(key, values) {
        var i;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(key, values);
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
    };
    moment.langData = function(key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };
    moment.isMoment = function(obj) {
        return obj instanceof Moment;
    };
    moment.isDuration = function(obj) {
        return obj instanceof Duration;
    };
    moment.fn = Moment.prototype = {
        clone: function() {
            return moment(this);
        },
        valueOf: function() {
            return +this._d;
        },
        unix: function() {
            return Math.floor(+this._d / 1e3);
        },
        toString: function() {
            return this.format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },
        toDate: function() {
            return this._d;
        },
        toJSON: function() {
            return moment.utc(this).format("YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
        },
        toArray: function() {
            var m = this;
            return [ m.year(), m.month(), m.date(), m.hours(), m.minutes(), m.seconds(), m.milliseconds() ];
        },
        isValid: function() {
            if (this._isValid == null) {
                if (this._a) {
                    this._isValid = !compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray());
                } else {
                    this._isValid = !isNaN(this._d.getTime());
                }
            }
            return !!this._isValid;
        },
        utc: function() {
            this._isUTC = true;
            return this;
        },
        local: function() {
            this._isUTC = false;
            return this;
        },
        format: function(inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },
        add: function(input, val) {
            var dur;
            if (typeof input === "string") {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },
        subtract: function(input, val) {
            var dur;
            if (typeof input === "string") {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },
        diff: function(input, units, asFloat) {
            var that = this._isUTC ? moment(input).utc() : moment(input).local(), zoneDiff = (this.zone() - that.zone()) * 6e4, diff, output;
            if (units) {
                units = units.replace(/s$/, "");
            }
            if (units === "year" || units === "month") {
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5;
                output = (this.year() - that.year()) * 12 + (this.month() - that.month());
                output += (this - moment(this).startOf("month") - (that - moment(that).startOf("month"))) / diff;
                if (units === "year") {
                    output = output / 12;
                }
            } else {
                diff = this - that - zoneDiff;
                output = units === "second" ? diff / 1e3 : units === "minute" ? diff / 6e4 : units === "hour" ? diff / 36e5 : units === "day" ? diff / 864e5 : units === "week" ? diff / 6048e5 : diff;
            }
            return asFloat ? output : absRound(output);
        },
        from: function(time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },
        fromNow: function(withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },
        calendar: function() {
            var diff = this.diff(moment().startOf("day"), "days", true), format = diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
            return this.format(this.lang().calendar(format, this));
        },
        isLeapYear: function() {
            var year = this.year();
            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        },
        isDST: function() {
            return this.zone() < moment([ this.year() ]).zone() || this.zone() < moment([ this.year(), 5 ]).zone();
        },
        day: function(input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            return input == null ? day : this.add({
                d: input - day
            });
        },
        startOf: function(units) {
            units = units.replace(/s$/, "");
            switch (units) {
              case "year":
                this.month(0);

              case "month":
                this.date(1);

              case "week":
              case "day":
                this.hours(0);

              case "hour":
                this.minutes(0);

              case "minute":
                this.seconds(0);

              case "second":
                this.milliseconds(0);
            }
            if (units === "week") {
                this.day(0);
            }
            return this;
        },
        endOf: function(units) {
            return this.startOf(units).add(units.replace(/s?$/, "s"), 1).subtract("ms", 1);
        },
        isAfter: function(input, units) {
            units = typeof units !== "undefined" ? units : "millisecond";
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },
        isBefore: function(input, units) {
            units = typeof units !== "undefined" ? units : "millisecond";
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },
        isSame: function(input, units) {
            units = typeof units !== "undefined" ? units : "millisecond";
            return +this.clone().startOf(units) === +moment(input).startOf(units);
        },
        zone: function() {
            return this._isUTC ? 0 : this._d.getTimezoneOffset();
        },
        daysInMonth: function() {
            return moment.utc([ this.year(), this.month() + 1, 0 ]).date();
        },
        dayOfYear: function(input) {
            var dayOfYear = round((moment(this).startOf("day") - moment(this).startOf("year")) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", input - dayOfYear);
        },
        isoWeek: function(input) {
            var week = weekOfYear(this, 1, 4);
            return input == null ? week : this.add("d", (input - week) * 7);
        },
        week: function(input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },
        lang: function(key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    };
    function makeGetterAndSetter(name, key) {
        moment.fn[name] = moment.fn[name + "s"] = function(input) {
            var utc = this._isUTC ? "UTC" : "";
            if (input != null) {
                this._d["set" + utc + key](input);
                return this;
            } else {
                return this._d["get" + utc + key]();
            }
        };
    }
    for (i = 0; i < proxyGettersAndSetters.length; i++) {
        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ""), proxyGettersAndSetters[i]);
    }
    makeGetterAndSetter("year", "FullYear");
    moment.fn.days = moment.fn.day;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.duration.fn = Duration.prototype = {
        weeks: function() {
            return absRound(this.days() / 7);
        },
        valueOf: function() {
            return this._milliseconds + this._days * 864e5 + this._months * 2592e6;
        },
        humanize: function(withSuffix) {
            var difference = +this, output = relativeTime(difference, !withSuffix, this.lang());
            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }
            return this.lang().postformat(output);
        },
        lang: moment.fn.lang
    };
    function makeDurationGetter(name) {
        moment.duration.fn[name] = function() {
            return this._data[name];
        };
    }
    function makeDurationAsGetter(name, factor) {
        moment.duration.fn["as" + name] = function() {
            return +this / factor;
        };
    }
    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }
    makeDurationAsGetter("Weeks", 6048e5);
    moment.lang("en", {
        ordinal: function(number) {
            var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        }
    });
    if (hasModule) {
        module.exports = moment;
    }
    if (typeof ender === "undefined") {
        this["moment"] = moment;
    }
    if (typeof define === "function" && define.amd) {
        define("moment", [], function() {
            return moment;
        });
    }
}).call(this);

(function() {
    var lang = {
        months: "Xaneiro_Febreiro_Marzo_Abril_Maio_Xuño_Xullo_Agosto_Setembro_Octubro_Novembro_Decembro".split("_"),
        monthsShort: "Xan._Feb._Mar._Abr._Mai._Xuñ._Xul._Ago._Set._Out._Nov._Dec.".split("_"),
        weekdays: "Domingo_Luns_Martes_Mércores_Xoves_Venres_Sábado".split("_"),
        weekdaysShort: "Dom._Lun._Mar._Mér._Xov._Ven._Sáb.".split("_"),
        weekdaysMin: "Do_Lu_Ma_Mé_Xo_Ve_Sá".split("_"),
        longDateFormat: {
            LT: "H:mm",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY LT",
            LLLL: "dddd D MMMM YYYY LT"
        },
        calendar: {
            sameDay: function() {
                return "[hoxe " + (this.hours() !== 1 ? "ás" : "a") + "] LT";
            },
            nextDay: function() {
                return "[mañá " + (this.hours() !== 1 ? "ás" : "a") + "] LT";
            },
            nextWeek: function() {
                return "dddd [" + (this.hours() !== 1 ? "ás" : "a") + "] LT";
            },
            lastDay: function() {
                return "[onte " + (this.hours() !== 1 ? "á" : "a") + "] LT";
            },
            lastWeek: function() {
                return "[o] dddd [pasado " + (this.hours() !== 1 ? "ás" : "a") + "] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "en %s",
            past: "fai %s",
            s: "uns segundo",
            m: "un minuto",
            mm: "%d minutos",
            h: "unha hora",
            hh: "%d horas",
            d: "un día",
            dd: "%d días",
            M: "un mes",
            MM: "%d meses",
            y: "un ano",
            yy: "%d anos"
        },
        ordinal: function(number) {
            return "º";
        }
    };
    if (typeof module !== "undefined" && module.exports) {
        module.exports = lang;
    }
    if (typeof window !== "undefined" && this.moment && this.moment.lang) {
        this.moment.lang("gl", lang);
    }
})();

(function() {
    var lang = {
        months: "Enero_Febrero_Marzo_Abril_Mayo_Junio_Julio_Agosto_Septiembre_Octubre_Noviembre_Diciembre".split("_"),
        monthsShort: "Ene._Feb._Mar._Abr._May._Jun._Jul._Ago._Sep._Oct._Nov._Dic.".split("_"),
        weekdays: "Domingo_Lunes_Martes_Miércoles_Jueves_Viernes_Sábado".split("_"),
        weekdaysShort: "Dom._Lun._Mar._Mié._Jue._Vie._Sáb.".split("_"),
        weekdaysMin: "Do_Lu_Ma_Mi_Ju_Vi_Sá".split("_"),
        longDateFormat: {
            LT: "H:mm",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY LT",
            LLLL: "dddd D MMMM YYYY LT"
        },
        calendar: {
            sameDay: function() {
                return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            nextDay: function() {
                return "[mañana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            nextWeek: function() {
                return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            lastDay: function() {
                return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            lastWeek: function() {
                return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "en %s",
            past: "hace %s",
            s: "unos segundos",
            m: "un minuto",
            mm: "%d minutos",
            h: "una hora",
            hh: "%d horas",
            d: "un día",
            dd: "%d días",
            M: "un mes",
            MM: "%d meses",
            y: "un año",
            yy: "%d años"
        },
        ordinal: function(number) {
            return "º";
        }
    };
    if (typeof module !== "undefined" && module.exports) {
        module.exports = lang;
    }
    if (typeof window !== "undefined" && this.moment && this.moment.lang) {
        this.moment.lang("es", lang);
    }
})();

(function($, moment) {
    var updateInterval = 1e3, paused = false, $livestamps = $([]), init = function() {
        livestampGlobal.resume();
    }, prep = function($el, timestamp) {
        var oldData = $el.data("livestampdata");
        if (typeof timestamp == "number") timestamp *= 1e3;
        $el.removeAttr("data-livestamp").removeData("livestamp");
        timestamp = moment(timestamp);
        if (moment.isMoment(timestamp) && !isNaN(+timestamp)) {
            var newData = $.extend({}, {
                original: $el.contents()
            }, oldData);
            newData.moment = moment(timestamp);
            $el.data("livestampdata", newData).empty();
            $livestamps.push($el[0]);
        }
    }, run = function() {
        if (paused) return;
        livestampGlobal.update();
        setTimeout(run, updateInterval);
    }, livestampGlobal = {
        update: function() {
            $("[data-livestamp]").each(function() {
                var $this = $(this);
                prep($this, $this.data("livestamp"));
            });
            var toRemove = [];
            $livestamps.each(function() {
                var $this = $(this), data = $this.data("livestampdata");
                if (data === undefined) toRemove.push(this); else if (moment.isMoment(data.moment)) {
                    var from = $this.html(), to = data.moment.fromNow();
                    if (from != to) {
                        var e = $.Event("change.livestamp");
                        $this.trigger(e, [ from, to ]);
                        if (!e.isDefaultPrevented()) $this.html(to);
                    }
                }
            });
            $livestamps = $livestamps.not(toRemove);
        },
        pause: function() {
            paused = true;
        },
        resume: function() {
            paused = false;
            run();
        },
        interval: function(interval) {
            if (interval === undefined) return updateInterval;
            updateInterval = interval;
        }
    }, livestampLocal = {
        add: function($el, timestamp) {
            if (typeof timestamp == "number") timestamp *= 1e3;
            timestamp = moment(timestamp);
            if (moment.isMoment(timestamp) && !isNaN(+timestamp)) {
                $el.each(function() {
                    prep($(this), timestamp);
                });
                livestampGlobal.update();
            }
            return $el;
        },
        destroy: function($el) {
            $livestamps = $livestamps.not($el);
            $el.each(function() {
                var $this = $(this), data = $this.data("livestampdata");
                if (data === undefined) return $el;
                $this.html(data.original ? data.original : "").removeData("livestampdata");
            });
            return $el;
        },
        isLivestamp: function($el) {
            return $el.data("livestampdata") !== undefined;
        }
    };
    $.livestamp = livestampGlobal;
    $(init);
    $.fn.livestamp = function(method, options) {
        if (!livestampLocal[method]) {
            options = method;
            method = "add";
        }
        return livestampLocal[method](this, options);
    };
})(jQuery, moment);

(function($) {
    var Checker, __bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    };
    Checker = function() {
        function Checker($el, field) {
            this.run = __bind(this.run, this);
            var sel;
            sel = field[0], this.metric = field[1];
            this.getVal = this.makeGetVal($el, sel);
        }
        Checker.prototype.run = function() {
            return this.verify(this.metric, this.getVal());
        };
        Checker.prototype.makeGetVal = function($el, sel) {
            var inputs, name, type;
            type = $el.attr("type");
            if (type === "checkbox") {
                return function() {
                    return $el.is(":checked");
                };
            } else if (type === "radio") {
                name = $el.attr("name");
                return function() {
                    return jQuery('[name="' + name + '"]').filter(":checked").val();
                };
            } else {
                if (this.metric === "one-of") {
                    inputs = jQuery(sel);
                    return function() {
                        return inputs.map(function() {
                            return jQuery.trim(this.value);
                        }).get().join("");
                    };
                } else {
                    return function() {
                        return jQuery.trim($el.val());
                    };
                }
            }
        };
        Checker.prototype.verify = function(m, v) {
            var arg, sec, type, _ref;
            if (!!(m && m.constructor && m.call && m.apply)) {
                return m(v);
            }
            if (m instanceof RegExp) {
                return m.test(v);
            }
            _ref = jQuery.map(m.split(":"), jQuery.trim), type = _ref[0], arg = _ref[1], sec = _ref[2];
            if (type === "same-as" && jQuery(arg).length !== 1) {
                throw new Error("same-as selector must target one and only one element");
            }
            if (!v && type !== "presence" && type !== "one-of") {
                return true;
            }
            switch (type) {
              case "presence":
                return !!v;

              case "one-of":
                return !!v;

              case "exact":
                return v === arg;

              case "not":
                return v !== arg;

              case "same-as":
                return v === jQuery(arg).val();

              case "min-num":
                return +v >= +arg;

              case "max-num":
                return +v <= +arg;

              case "between-num":
                return +v >= +arg && +v <= +sec;

              case "min-length":
                return v.length >= +arg;

              case "max-length":
                return v.length <= +arg;

              case "exact-length":
                return v.length === +arg;

              case "between":
                return v.length >= +arg && v.length <= +sec;

              case "integer":
                return /^\s*\d+\s*$/.test(v);

              case "float":
                return /^[-+]?[0-9]+(\.[0-9]+)?$/.test(v);

              case "email":
                return this.email(v);

              default:
                throw new Error("I don't know " + type + ", sorry.");
            }
        };
        Checker.prototype.email = function(v) {
            var RFC822;
            RFC822 = /^([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x22([^\x0d\x22\x5c\x80-\xff]|\x5c[\x00-\x7f])*\x22))*\x40([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d)(\x2e([^\x00-\x20\x22\x28\x29\x2c\x2e\x3a-\x3c\x3e\x40\x5b-\x5d\x7f-\xff]+|\x5b([^\x0d\x5b-\x5d\x80-\xff]|\x5c[\x00-\x7f])*\x5d))*$/;
            return RFC822.test(v);
        };
        return Checker;
    }();
    var Listener, __bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    };
    Listener = function() {
        function Listener(el, get, field) {
            this.get = get;
            this.field = field;
            this.change_status = __bind(this.change_status, this);
            this.runCheck = __bind(this.runCheck, this);
            this.delayedCheck = __bind(this.delayedCheck, this);
            this.events = __bind(this.events, this);
            this.$el = jQuery(el);
            this.delayId = "";
            this.status = null;
            this.checker = new Checker(this.$el, this.field);
            this.msg = new Msg(this.$el, this.get, this.field);
            this.events();
        }
        Listener.prototype.events = function() {
            if (this.$el.attr("type") === "radio") {
                return jQuery('[name="' + this.$el.attr("name") + '"]').on("change", this.runCheck);
            } else {
                this.$el.on("change", this.runCheck);
                this.$el.on("blur", this.runCheck);
                if (this.field[1] === "one-of") {
                    jQuery(window).on("nod-run-one-of", this.runCheck);
                }
                if (this.get.delay) {
                    return this.$el.on("keyup", this.delayedCheck);
                }
            }
        };
        Listener.prototype.delayedCheck = function() {
            clearTimeout(this.delayId);
            return this.delayId = setTimeout(this.runCheck, this.get.delay);
        };
        Listener.prototype.runCheck = function() {
            return jQuery.when(this.checker.run()).then(this.change_status);
        };
        Listener.prototype.change_status = function(status) {
            var isCorrect;
            try {
                status = eval(status);
            } catch (_error) {}
            isCorrect = !!status;
            if (this.status === isCorrect) {
                return;
            }
            this.status = isCorrect;
            this.msg.toggle(this.status);
            jQuery(this).trigger("nod_toggle");
            if (this.field[1] === "one-of" && status) {
                return jQuery(window).trigger("nod-run-one-of");
            }
        };
        return Listener;
    }();
    var Msg, __bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    };
    Msg = function() {
        function Msg($el, get, field) {
            this.$el = $el;
            this.get = get;
            this.createShowMsg = __bind(this.createShowMsg, this);
            this.toggle = __bind(this.toggle, this);
            this.createMsg = __bind(this.createMsg, this);
            this.$msg = this.createMsg(field[2]);
            this.showMsg = this.createShowMsg();
        }
        Msg.prototype.createMsg = function(msg) {
            return jQuery("<span/>", {
                html: msg,
                "class": this.get.helpSpanDisplay + " " + this.get.errorClass
            });
        };
        Msg.prototype.toggle = function(status) {
            if (status) {
                return this.$msg.remove();
            } else {
                this.showMsg();
                if (this.get.broadcastError) {
                    return this.broadcast();
                }
            }
        };
        Msg.prototype.createShowMsg = function() {
            var pos, type;
            type = this.$el.attr("type");
            if (type === "checkbox" || type === "radio") {
                return function() {
                    return this.$el.parent().append(this.$msg);
                };
            } else {
                pos = this.findPos(this.$el);
                return function() {
                    return pos.after(this.$msg);
                };
            }
        };
        Msg.prototype.findPos = function($el) {
            if (this.elHasClass("parent", $el)) {
                return this.findPos($el.parent());
            }
            if (this.elHasClass("next", $el)) {
                return this.findPos($el.next());
            }
            return $el;
        };
        Msg.prototype.elHasClass = function(dir, $el) {
            var sel, _i, _len, _ref;
            _ref = this.get.errorPosClasses;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                sel = _ref[_i];
                if ($el[dir](sel).length) {
                    return true;
                }
            }
            return false;
        };
        Msg.prototype.broadcast = function() {
            return jQuery(window).trigger("nod_error_fired", {
                el: this.$el,
                msg: this.$msg.html()
            });
        };
        return Msg;
    }();
    var Nod, __bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    };
    Nod = function() {
        function Nod(form, fields, options) {
            this.form = form;
            form[0].__nod = this;
            this.formIsErrorFree = __bind(this.formIsErrorFree, this);
            this.submitForm = __bind(this.submitForm, this);
            this.toggleSubmitBtnText = __bind(this.toggleSubmitBtnText, this);
            this.toggleSubmitBtn = __bind(this.toggleSubmitBtn, this);
            this.toggleGroupClass = __bind(this.toggleGroupClass, this);
            this.toggle_status = __bind(this.toggle_status, this);
            this.massCheck = __bind(this.massCheck, this);
            this.listenForEnter = __bind(this.listenForEnter, this);
            this.events = __bind(this.events, this);
            this.createListeners = __bind(this.createListeners, this);
            if (!fields) {
                return;
            }
            this.get = jQuery.extend({
                delay: 700,
                disableSubmitBtn: true,
                helpSpanDisplay: "help-inline",
                groupClass: "error",
                submitBtnSelector: "[type=submit]",
                metricsSplitter: ":",
                errorPosClasses: [ ".help-inline", ".add-on", "button", ".input-append" ],
                silentSubmit: false,
                broadcastError: false,
                errorClass: "nod_msg",
                groupSelector: ".control-group"
            }, options);
            this.listeners = this.createListeners(fields);
            this.submit = this.form.find(this.get.submitBtnSelector);
            this.checkIfElementsExist(this.form, this.submit, this.get.disableSubmitBtn);
            this.events();
        }
        Nod.prototype.createListeners = function(fields) {
            var el, field, listeners, _i, _j, _len, _len1, _ref;
            listeners = [];
            for (_i = 0, _len = fields.length; _i < _len; _i++) {
                field = fields[_i];
                if (field.length !== 3) {
                    this["throw"]("field", field);
                }
                _ref = this.form.find(field[0]);
                for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                    el = _ref[_j];
                    listeners.push(new Listener(el, this.get, field));
                }
            }
            return listeners;
        };
        Nod.prototype.events = function() {
            var l, _i, _len, _ref;
            _ref = this.listeners;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                l = _ref[_i];
                jQuery(l).on("nod_toggle", this.toggle_status);
            }
            if (this.submit.length) {
                return this.submit.on("click", this.massCheck);
            } else {
                return this.form.on("keyup", this.listenForEnter);
            }
        };
        Nod.prototype.listenForEnter = function(event) {
            if (event.keyCode === 13) {
                return this.massCheck();
            }
        };
        Nod.prototype.massCheck = function(event) {
            var checks, l, _i, _len, _ref;
            if (event != null) {
                event.preventDefault();
            }
            checks = [];
            _ref = this.listeners;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                l = _ref[_i];
                checks.push(l.runCheck());
            }
            this.toggleSubmitBtnText();
            return jQuery.when.apply(jQuery, checks).then(this.submitForm).then(this.toggleSubmitBtnText);
        };
        Nod.prototype.toggle_status = function(event) {
            this.toggleGroupClass(event.target.$el.parents(this.get.groupSelector));
            if (this.get.disableSubmitBtn) {
                return this.toggleSubmitBtn();
            }
        };
        Nod.prototype.toggleGroupClass = function($group) {
            if ($group.find("." + this.get.errorClass).length) {
                return $group.addClass(this.get.groupClass);
            } else {
                return $group.removeClass(this.get.groupClass);
            }
        };
        Nod.prototype.toggleSubmitBtn = function() {
            if (this.formIsErrorFree()) {
                return this.submit.removeClass("disabled").removeAttr("disabled");
            } else {
                return this.submit.addClass("disabled").attr("disabled", "disabled");
            }
        };
        Nod.prototype.toggleSubmitBtnText = function() {
            var tmp;
            tmp = this.submit.attr("data-loading-text");
            if (tmp) {
                this.submit.attr("data-loading-text", this.submit.html());
                return this.submit.html(tmp);
            }
        };
        Nod.prototype.submitForm = function() {
            var $form;
            if (!this.formIsErrorFree()) {
                return;
            }
            if (this.get.silentSubmit) {
                $form = jQuery(this.form);
                return $form.trigger("silentSubmit", $form.serialize());
            } else {
                return this.form.submit();
            }
        };
        Nod.prototype.formIsErrorFree = function() {
            return !jQuery(this.listeners).filter(function() {
                if (this.status == null) {
                    this.runCheck();
                }
                return !this.status;
            }).length;
        };
        Nod.prototype.checkIfElementsExist = function(form, submit, disableSubmitBtn) {
            if (!form.selector || !form.length) {
                this["throw"]("form", form);
            }
            if (!submit.length && disableSubmitBtn) {
                return this["throw"]("submit", submit);
            }
        };
        Nod.prototype["throw"] = function(type, el) {
            var txt;
            switch (type) {
              case "form":
                txt = "Couldn't find form: ";
                break;

              case "submit":
                txt = "Couldn't find submit button: ";
                break;

              case "field":
                txt = "Metrics for each field must have three parts: ";
            }
            throw new Error(txt + el);
        };
        return Nod;
    }();
    $.fn.nod = function(fields, settings) {
        if (fields == undefined && settings == undefined) {
            return this[0].__nod;
        }
        new Nod(this, fields, settings);
        return this;
    };
})(jQuery);

var Showdown = {
    extensions: {}
};

var forEach = Showdown.forEach = function(obj, callback) {
    if (typeof obj.forEach === "function") {
        obj.forEach(callback);
    } else {
        var i, len = obj.length;
        for (i = 0; i < len; i++) {
            callback(obj[i], i, obj);
        }
    }
};

var stdExtName = function(s) {
    return s.replace(/[_-]||\s/g, "").toLowerCase();
};

Showdown.converter = function(converter_options) {
    var g_urls;
    var g_titles;
    var g_html_blocks;
    var g_list_level = 0;
    var g_lang_extensions = [];
    var g_output_modifiers = [];
    if (typeof module !== "undefind" && typeof exports !== "undefined" && typeof require !== "undefind") {
        var fs = require("fs");
        if (fs) {
            var extensions = fs.readdirSync((__dirname || ".") + "/extensions").filter(function(file) {
                return ~file.indexOf(".js");
            }).map(function(file) {
                return file.replace(/\.js$/, "");
            });
            Showdown.forEach(extensions, function(ext) {
                var name = stdExtName(ext);
                Showdown.extensions[name] = require("./extensions/" + ext);
            });
        }
    }
    this.makeHtml = function(text) {
        g_urls = {};
        g_titles = {};
        g_html_blocks = [];
        text = text.replace(/~/g, "~T");
        text = text.replace(/\$/g, "~D");
        text = text.replace(/\r\n/g, "\n");
        text = text.replace(/\r/g, "\n");
        text = "\n\n" + text + "\n\n";
        text = _Detab(text);
        text = text.replace(/^[ \t]+$/gm, "");
        Showdown.forEach(g_lang_extensions, function(x) {
            text = _ExecuteExtension(x, text);
        });
        text = _DoGithubCodeBlocks(text);
        text = _HashHTMLBlocks(text);
        text = _StripLinkDefinitions(text);
        text = _RunBlockGamut(text);
        text = _UnescapeSpecialChars(text);
        text = text.replace(/~D/g, "$$");
        text = text.replace(/~T/g, "~");
        Showdown.forEach(g_output_modifiers, function(x) {
            text = _ExecuteExtension(x, text);
        });
        return text;
    };
    if (converter_options && converter_options.extensions) {
        var self = this;
        Showdown.forEach(converter_options.extensions, function(plugin) {
            if (typeof plugin === "string") {
                plugin = Showdown.extensions[stdExtName(plugin)];
            }
            if (typeof plugin === "function") {
                Showdown.forEach(plugin(self), function(ext) {
                    if (ext.type) {
                        if (ext.type === "language" || ext.type === "lang") {
                            g_lang_extensions.push(ext);
                        } else if (ext.type === "output" || ext.type === "html") {
                            g_output_modifiers.push(ext);
                        }
                    } else {
                        g_output_modifiers.push(ext);
                    }
                });
            } else {
                throw "Extension '" + plugin + "' could not be loaded.  It was either not found or is not a valid extension.";
            }
        });
    }
    var _ExecuteExtension = function(ext, text) {
        if (ext.regex) {
            var re = new RegExp(ext.regex, "g");
            return text.replace(re, ext.replace);
        } else if (ext.filter) {
            return ext.filter(text);
        }
    };
    var _StripLinkDefinitions = function(text) {
        text += "~0";
        text = text.replace(/^[ ]{0,3}\[(.+)\]:[ \t]*\n?[ \t]*<?(\S+?)>?[ \t]*\n?[ \t]*(?:(\n*)["(](.+?)[")][ \t]*)?(?:\n+|(?=~0))/gm, function(wholeMatch, m1, m2, m3, m4) {
            m1 = m1.toLowerCase();
            g_urls[m1] = _EncodeAmpsAndAngles(m2);
            if (m3) {
                return m3 + m4;
            } else if (m4) {
                g_titles[m1] = m4.replace(/"/g, "&quot;");
            }
            return "";
        });
        text = text.replace(/~0/, "");
        return text;
    };
    var _HashHTMLBlocks = function(text) {
        text = text.replace(/\n/g, "\n\n");
        var block_tags_a = "p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del|style|section|header|footer|nav|article|aside";
        var block_tags_b = "p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|style|section|header|footer|nav|article|aside";
        text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\b[^\r]*?\n<\/\2>[ \t]*(?=\n+))/gm, hashElement);
        text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|style|section|header|footer|nav|article|aside)\b[^\r]*?<\/\2>[ \t]*(?=\n+)\n)/gm, hashElement);
        text = text.replace(/(\n[ ]{0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g, hashElement);
        text = text.replace(/(\n\n[ ]{0,3}<!(--[^\r]*?--\s*)+>[ \t]*(?=\n{2,}))/g, hashElement);
        text = text.replace(/(?:\n\n)([ ]{0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g, hashElement);
        text = text.replace(/\n\n/g, "\n");
        return text;
    };
    var hashElement = function(wholeMatch, m1) {
        var blockText = m1;
        blockText = blockText.replace(/\n\n/g, "\n");
        blockText = blockText.replace(/^\n/, "");
        blockText = blockText.replace(/\n+$/g, "");
        blockText = "\n\n~K" + (g_html_blocks.push(blockText) - 1) + "K\n\n";
        return blockText;
    };
    var _RunBlockGamut = function(text) {
        text = _DoHeaders(text);
        var key = hashBlock("<hr />");
        text = text.replace(/^[ ]{0,2}([ ]?\*[ ]?){3,}[ \t]*$/gm, key);
        text = text.replace(/^[ ]{0,2}([ ]?\-[ ]?){3,}[ \t]*$/gm, key);
        text = text.replace(/^[ ]{0,2}([ ]?\_[ ]?){3,}[ \t]*$/gm, key);
        text = _DoLists(text);
        text = _DoCodeBlocks(text);
        text = _DoBlockQuotes(text);
        text = _HashHTMLBlocks(text);
        text = _FormParagraphs(text);
        return text;
    };
    var _RunSpanGamut = function(text) {
        text = _DoCodeSpans(text);
        text = _EscapeSpecialCharsWithinTagAttributes(text);
        text = _EncodeBackslashEscapes(text);
        text = _DoImages(text);
        text = _DoAnchors(text);
        text = _DoAutoLinks(text);
        text = _EncodeAmpsAndAngles(text);
        text = _DoItalicsAndBold(text);
        text = text.replace(/  +\n/g, " <br />\n");
        return text;
    };
    var _EscapeSpecialCharsWithinTagAttributes = function(text) {
        var regex = /(<[a-z\/!$]("[^"]*"|'[^']*'|[^'">])*>|<!(--.*?--\s*)+>)/gi;
        text = text.replace(regex, function(wholeMatch) {
            var tag = wholeMatch.replace(/(.)<\/?code>(?=.)/g, "$1`");
            tag = escapeCharacters(tag, "\\`*_");
            return tag;
        });
        return text;
    };
    var _DoAnchors = function(text) {
        text = text.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g, writeAnchorTag);
        text = text.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\]\([ \t]*()<?(.*?(?:\(.*?\).*?)?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g, writeAnchorTag);
        text = text.replace(/(\[([^\[\]]+)\])()()()()()/g, writeAnchorTag);
        return text;
    };
    var writeAnchorTag = function(wholeMatch, m1, m2, m3, m4, m5, m6, m7) {
        if (m7 == undefined) m7 = "";
        var whole_match = m1;
        var link_text = m2;
        var link_id = m3.toLowerCase();
        var url = m4;
        var title = m7;
        if (url == "") {
            if (link_id == "") {
                link_id = link_text.toLowerCase().replace(/ ?\n/g, " ");
            }
            url = "#" + link_id;
            if (g_urls[link_id] != undefined) {
                url = g_urls[link_id];
                if (g_titles[link_id] != undefined) {
                    title = g_titles[link_id];
                }
            } else {
                if (whole_match.search(/\(\s*\)$/m) > -1) {
                    url = "";
                } else {
                    return whole_match;
                }
            }
        }
        url = escapeCharacters(url, "*_");
        var result = '<a href="' + url + '"';
        if (title != "") {
            title = title.replace(/"/g, "&quot;");
            title = escapeCharacters(title, "*_");
            result += ' title="' + title + '"';
        }
        result += ">" + link_text + "</a>";
        return result;
    };
    var _DoImages = function(text) {
        text = text.replace(/(!\[(.*?)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g, writeImageTag);
        text = text.replace(/(!\[(.*?)\]\s?\([ \t]*()<?(\S+?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g, writeImageTag);
        return text;
    };
    var writeImageTag = function(wholeMatch, m1, m2, m3, m4, m5, m6, m7) {
        var whole_match = m1;
        var alt_text = m2;
        var link_id = m3.toLowerCase();
        var url = m4;
        var title = m7;
        if (!title) title = "";
        if (url == "") {
            if (link_id == "") {
                link_id = alt_text.toLowerCase().replace(/ ?\n/g, " ");
            }
            url = "#" + link_id;
            if (g_urls[link_id] != undefined) {
                url = g_urls[link_id];
                if (g_titles[link_id] != undefined) {
                    title = g_titles[link_id];
                }
            } else {
                return whole_match;
            }
        }
        alt_text = alt_text.replace(/"/g, "&quot;");
        url = escapeCharacters(url, "*_");
        var result = '<img src="' + url + '" alt="' + alt_text + '"';
        title = title.replace(/"/g, "&quot;");
        title = escapeCharacters(title, "*_");
        result += ' title="' + title + '"';
        result += " />";
        return result;
    };
    var _DoHeaders = function(text) {
        text = text.replace(/^(.+)[ \t]*\n=+[ \t]*\n+/gm, function(wholeMatch, m1) {
            return hashBlock('<h1 id="' + headerId(m1) + '">' + _RunSpanGamut(m1) + "</h1>");
        });
        text = text.replace(/^(.+)[ \t]*\n-+[ \t]*\n+/gm, function(matchFound, m1) {
            return hashBlock('<h2 id="' + headerId(m1) + '">' + _RunSpanGamut(m1) + "</h2>");
        });
        text = text.replace(/^(\#{1,6})[ \t]*(.+?)[ \t]*\#*\n+/gm, function(wholeMatch, m1, m2) {
            var h_level = m1.length;
            return hashBlock("<h" + h_level + ' id="' + headerId(m2) + '">' + _RunSpanGamut(m2) + "</h" + h_level + ">");
        });
        function headerId(m) {
            return m.replace(/[^\w]/g, "").toLowerCase();
        }
        return text;
    };
    var _ProcessListItems;
    var _DoLists = function(text) {
        text += "~0";
        var whole_list = /^(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm;
        if (g_list_level) {
            text = text.replace(whole_list, function(wholeMatch, m1, m2) {
                var list = m1;
                var list_type = m2.search(/[*+-]/g) > -1 ? "ul" : "ol";
                list = list.replace(/\n{2,}/g, "\n\n\n");
                var result = _ProcessListItems(list);
                result = result.replace(/\s+$/, "");
                result = "<" + list_type + ">" + result + "</" + list_type + ">\n";
                return result;
            });
        } else {
            whole_list = /(\n\n|^\n?)(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/g;
            text = text.replace(whole_list, function(wholeMatch, m1, m2, m3) {
                var runup = m1;
                var list = m2;
                var list_type = m3.search(/[*+-]/g) > -1 ? "ul" : "ol";
                var list = list.replace(/\n{2,}/g, "\n\n\n");
                var result = _ProcessListItems(list);
                result = runup + "<" + list_type + ">\n" + result + "</" + list_type + ">\n";
                return result;
            });
        }
        text = text.replace(/~0/, "");
        return text;
    };
    _ProcessListItems = function(list_str) {
        g_list_level++;
        list_str = list_str.replace(/\n{2,}$/, "\n");
        list_str += "~0";
        list_str = list_str.replace(/(\n)?(^[ \t]*)([*+-]|\d+[.])[ \t]+([^\r]+?(\n{1,2}))(?=\n*(~0|\2([*+-]|\d+[.])[ \t]+))/gm, function(wholeMatch, m1, m2, m3, m4) {
            var item = m4;
            var leading_line = m1;
            var leading_space = m2;
            if (leading_line || item.search(/\n{2,}/) > -1) {
                item = _RunBlockGamut(_Outdent(item));
            } else {
                item = _DoLists(_Outdent(item));
                item = item.replace(/\n$/, "");
                item = _RunSpanGamut(item);
            }
            return "<li>" + item + "</li>\n";
        });
        list_str = list_str.replace(/~0/g, "");
        g_list_level--;
        return list_str;
    };
    var _DoCodeBlocks = function(text) {
        text += "~0";
        text = text.replace(/(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=~0))/g, function(wholeMatch, m1, m2) {
            var codeblock = m1;
            var nextChar = m2;
            codeblock = _EncodeCode(_Outdent(codeblock));
            codeblock = _Detab(codeblock);
            codeblock = codeblock.replace(/^\n+/g, "");
            codeblock = codeblock.replace(/\n+$/g, "");
            codeblock = "<pre><code>" + codeblock + "\n</code></pre>";
            return hashBlock(codeblock) + nextChar;
        });
        text = text.replace(/~0/, "");
        return text;
    };
    var _DoGithubCodeBlocks = function(text) {
        text += "~0";
        text = text.replace(/(?:^|\n)```(.*)\n([\s\S]*?)\n```/g, function(wholeMatch, m1, m2) {
            var language = m1;
            var codeblock = m2;
            codeblock = _EncodeCode(codeblock);
            codeblock = _Detab(codeblock);
            codeblock = codeblock.replace(/^\n+/g, "");
            codeblock = codeblock.replace(/\n+$/g, "");
            codeblock = "<pre><code" + (language ? ' class="' + language + '"' : "") + ">" + codeblock + "\n</code></pre>";
            return hashBlock(codeblock);
        });
        text = text.replace(/~0/, "");
        return text;
    };
    var hashBlock = function(text) {
        text = text.replace(/(^\n+|\n+$)/g, "");
        return "\n\n~K" + (g_html_blocks.push(text) - 1) + "K\n\n";
    };
    var _DoCodeSpans = function(text) {
        text = text.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm, function(wholeMatch, m1, m2, m3, m4) {
            var c = m3;
            c = c.replace(/^([ \t]*)/g, "");
            c = c.replace(/[ \t]*$/g, "");
            c = _EncodeCode(c);
            return m1 + "<code>" + c + "</code>";
        });
        return text;
    };
    var _EncodeCode = function(text) {
        text = text.replace(/&/g, "&amp;");
        text = text.replace(/</g, "&lt;");
        text = text.replace(/>/g, "&gt;");
        text = escapeCharacters(text, "*_{}[]\\", false);
        return text;
    };
    var _DoItalicsAndBold = function(text) {
        text = text.replace(/(\*\*|__)(?=\S)([^\r]*?\S[*_]*)\1/g, "<strong>$2</strong>");
        text = text.replace(/(\*|_)(?=\S)([^\r]*?\S)\1/g, "<em>$2</em>");
        return text;
    };
    var _DoBlockQuotes = function(text) {
        text = text.replace(/((^[ \t]*>[ \t]?.+\n(.+\n)*\n*)+)/gm, function(wholeMatch, m1) {
            var bq = m1;
            bq = bq.replace(/^[ \t]*>[ \t]?/gm, "~0");
            bq = bq.replace(/~0/g, "");
            bq = bq.replace(/^[ \t]+$/gm, "");
            bq = _RunBlockGamut(bq);
            bq = bq.replace(/(^|\n)/g, "$1  ");
            bq = bq.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function(wholeMatch, m1) {
                var pre = m1;
                pre = pre.replace(/^  /gm, "~0");
                pre = pre.replace(/~0/g, "");
                return pre;
            });
            return hashBlock("<blockquote>\n" + bq + "\n</blockquote>");
        });
        return text;
    };
    var _FormParagraphs = function(text) {
        text = text.replace(/^\n+/g, "");
        text = text.replace(/\n+$/g, "");
        var grafs = text.split(/\n{2,}/g);
        var grafsOut = [];
        var end = grafs.length;
        for (var i = 0; i < end; i++) {
            var str = grafs[i];
            if (str.search(/~K(\d+)K/g) >= 0) {
                grafsOut.push(str);
            } else if (str.search(/\S/) >= 0) {
                str = _RunSpanGamut(str);
                str = str.replace(/^([ \t]*)/g, "<p>");
                str += "</p>";
                grafsOut.push(str);
            }
        }
        end = grafsOut.length;
        for (var i = 0; i < end; i++) {
            while (grafsOut[i].search(/~K(\d+)K/) >= 0) {
                var blockText = g_html_blocks[RegExp.$1];
                blockText = blockText.replace(/\$/g, "$$$$");
                grafsOut[i] = grafsOut[i].replace(/~K\d+K/, blockText);
            }
        }
        return grafsOut.join("\n\n");
    };
    var _EncodeAmpsAndAngles = function(text) {
        text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, "&amp;");
        text = text.replace(/<(?![a-z\/?\$!])/gi, "&lt;");
        return text;
    };
    var _EncodeBackslashEscapes = function(text) {
        text = text.replace(/\\(\\)/g, escapeCharacters_callback);
        text = text.replace(/\\([`*_{}\[\]()>#+-.!])/g, escapeCharacters_callback);
        return text;
    };
    var _DoAutoLinks = function(text) {
        text = text.replace(/<((https?|ftp|dict):[^'">\s]+)>/gi, '<a href="$1">$1</a>');
        text = text.replace(/<(?:mailto:)?([-.\w]+\@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi, function(wholeMatch, m1) {
            return _EncodeEmailAddress(_UnescapeSpecialChars(m1));
        });
        return text;
    };
    var _EncodeEmailAddress = function(addr) {
        var encode = [ function(ch) {
            return "&#" + ch.charCodeAt(0) + ";";
        }, function(ch) {
            return "&#x" + ch.charCodeAt(0).toString(16) + ";";
        }, function(ch) {
            return ch;
        } ];
        addr = "mailto:" + addr;
        addr = addr.replace(/./g, function(ch) {
            if (ch == "@") {
                ch = encode[Math.floor(Math.random() * 2)](ch);
            } else if (ch != ":") {
                var r = Math.random();
                ch = r > .9 ? encode[2](ch) : r > .45 ? encode[1](ch) : encode[0](ch);
            }
            return ch;
        });
        addr = '<a href="' + addr + '">' + addr + "</a>";
        addr = addr.replace(/">.+:/g, '">');
        return addr;
    };
    var _UnescapeSpecialChars = function(text) {
        text = text.replace(/~E(\d+)E/g, function(wholeMatch, m1) {
            var charCodeToReplace = parseInt(m1);
            return String.fromCharCode(charCodeToReplace);
        });
        return text;
    };
    var _Outdent = function(text) {
        text = text.replace(/^(\t|[ ]{1,4})/gm, "~0");
        text = text.replace(/~0/g, "");
        return text;
    };
    var _Detab = function(text) {
        text = text.replace(/\t(?=\t)/g, "    ");
        text = text.replace(/\t/g, "~A~B");
        text = text.replace(/~B(.+?)~A/g, function(wholeMatch, m1, m2) {
            var leadingText = m1;
            var numSpaces = 4 - leadingText.length % 4;
            for (var i = 0; i < numSpaces; i++) leadingText += " ";
            return leadingText;
        });
        text = text.replace(/~A/g, "    ");
        text = text.replace(/~B/g, "");
        return text;
    };
    var escapeCharacters = function(text, charsToEscape, afterBackslash) {
        var regexString = "([" + charsToEscape.replace(/([\[\]\\])/g, "\\$1") + "])";
        if (afterBackslash) {
            regexString = "\\\\" + regexString;
        }
        var regex = new RegExp(regexString, "g");
        text = text.replace(regex, escapeCharacters_callback);
        return text;
    };
    var escapeCharacters_callback = function(wholeMatch, m1) {
        var charCodeToEscape = m1.charCodeAt(0);
        return "~E" + charCodeToEscape + "E";
    };
};

if (typeof module !== "undefined") module.exports = Showdown;

if (typeof define === "function" && define.amd) {
    define("showdown", function() {
        return Showdown;
    });
}

(function() {
    "use strict";
    var root = this;
    var _, Backbone, BackboneModel, BackboneCollection, ModelProto, defaultEvents, AssociatedModel, pathChecker;
    if (typeof window === "undefined") {
        _ = require("underscore");
        Backbone = require("backbone");
        if (typeof exports !== "undefined") {
            exports = module.exports = Backbone;
        }
    } else {
        _ = root._;
        Backbone = root.Backbone;
    }
    BackboneModel = Backbone.Model;
    BackboneCollection = Backbone.Collection;
    ModelProto = BackboneModel.prototype;
    pathChecker = /[\.\[\]]+/g;
    defaultEvents = [ "change", "add", "remove", "reset", "destroy", "sync", "error", "sort", "request" ];
    Backbone.Many = "Many";
    Backbone.One = "One";
    AssociatedModel = Backbone.AssociatedModel = BackboneModel.extend({
        relations: undefined,
        _proxyCalls: undefined,
        get: function(attr) {
            var obj = ModelProto.get.call(this, attr);
            return obj ? obj : this.getAttr.apply(this, arguments);
        },
        set: function(key, value, options) {
            var attributes, attr, modelMap, modelId, obj, result = this;
            if (_.isObject(key) || key == null) {
                attributes = key;
                options = value;
            } else {
                attributes = {};
                attributes[key] = value;
            }
            if (!attributes) return this;
            for (attr in attributes) {
                modelMap || (modelMap = {});
                if (attr.match(pathChecker)) {
                    var pathTokens = getPathArray(attr), initials = _.initial(pathTokens), last = pathTokens[pathTokens.length - 1], parentModel = this.get(initials);
                    if (parentModel instanceof AssociatedModel) {
                        obj = modelMap[parentModel.cid] || (modelMap[parentModel.cid] = {
                            model: parentModel,
                            data: {}
                        });
                        obj.data[last] = attributes[attr];
                    }
                } else {
                    obj = modelMap[this.cid] || (modelMap[this.cid] = {
                        model: this,
                        data: {}
                    });
                    obj.data[attr] = attributes[attr];
                }
            }
            if (modelMap) {
                for (modelId in modelMap) {
                    obj = modelMap[modelId];
                    this.setAttr.call(obj.model, obj.data, options) || (result = false);
                }
            } else {
                return this.setAttr.call(this, attributes, options);
            }
            return result;
        },
        setAttr: function(attributes, options) {
            var attr;
            options || (options = {});
            if (options.unset) for (attr in attributes) attributes[attr] = void 0;
            if (this.relations) {
                _.each(this.relations, function(relation) {
                    var relationKey = relation.key, relatedModel = relation.relatedModel, collectionType = relation.collectionType, val, relationOptions, data, relationValue;
                    if (attributes[relationKey]) {
                        val = _.result(attributes, relationKey);
                        relatedModel && _.isString(relatedModel) && (relatedModel = eval(relatedModel));
                        collectionType && _.isString(collectionType) && (collectionType = eval(collectionType));
                        relationOptions = relation.options ? _.extend({}, relation.options, options) : options;
                        if (relation.type === Backbone.Many) {
                            if (collectionType && !collectionType.prototype instanceof BackboneCollection) {
                                throw new Error("collectionType must inherit from Backbone.Collection");
                            }
                            if (val instanceof BackboneCollection) {
                                data = val;
                                attributes[relationKey] = data;
                            } else {
                                data = collectionType ? new collectionType() : this._createCollection(relatedModel);
                                data.add(val, relationOptions);
                                attributes[relationKey] = data;
                            }
                        } else if (relation.type === Backbone.One && relatedModel) {
                            data = val instanceof AssociatedModel ? val : new relatedModel(val);
                            attributes[relationKey] = data;
                        }
                        relationValue = data;
                        if (relationValue && !relationValue._proxyCallback) {
                            relationValue._proxyCallback = function() {
                                return this._bubbleEvent.call(this, relationKey, relationValue, arguments);
                            };
                            relationValue.on("all", relationValue._proxyCallback, this);
                        }
                    }
                }, this);
            }
            return ModelProto.set.call(this, attributes, options);
        },
        _bubbleEvent: function(relationKey, relationValue, eventArguments) {
            var args = eventArguments, opt = args[0].split(":"), eventType = opt[0], eventObject = args[1], indexEventObject = -1, _proxyCalls = relationValue._proxyCalls, eventPath, eventAvailable;
            _.size(opt) > 1 && (eventPath = opt[1]);
            if (relationValue instanceof BackboneCollection && "change" === eventType && eventObject) {
                var pathTokens = getPathArray(eventPath), initialTokens = _.initial(pathTokens), colModel;
                colModel = relationValue.find(function(model) {
                    if (eventObject === model) return true;
                    if (model) {
                        var changedModel = model.get(initialTokens);
                        if ((changedModel instanceof AssociatedModel || changedModel instanceof BackboneCollection) && eventObject === changedModel) return true;
                        changedModel = model.get(pathTokens);
                        return (changedModel instanceof AssociatedModel || changedModel instanceof BackboneCollection) && eventObject === changedModel;
                    }
                    return false;
                });
                colModel && (indexEventObject = relationValue.indexOf(colModel));
            }
            eventPath = relationKey + (indexEventObject !== -1 ? "[" + indexEventObject + "]" : "") + (eventPath ? "." + eventPath : "");
            args[0] = eventType + ":" + eventPath;
            if (_proxyCalls) {
                eventAvailable = _.find(_proxyCalls, function(value, eventKey) {
                    return eventPath.indexOf(eventKey, eventPath.length - eventKey.length) !== -1;
                });
                if (eventAvailable) return this;
            } else {
                _proxyCalls = relationValue._proxyCalls = {};
            }
            _proxyCalls[eventPath] = true;
            if ("change" === eventType) {
                this._previousAttributes[relationKey] = relationValue._previousAttributes;
                this.changed[relationKey] = relationValue;
            }
            this.trigger.apply(this, args);
            if (eventPath && _proxyCalls) {
                delete _proxyCalls[eventPath];
            }
            return this;
        },
        _createCollection: function(type) {
            var collection, relatedModel = type;
            _.isString(relatedModel) && (relatedModel = eval(relatedModel));
            if (relatedModel && relatedModel.prototype instanceof AssociatedModel) {
                collection = new BackboneCollection();
                collection.model = relatedModel;
            } else {
                throw new Error("type must inherit from Backbone.AssociatedModel");
            }
            return collection;
        },
        toJSON: function(options) {
            var json, aJson;
            if (!this.visited) {
                this.visited = true;
                json = ModelProto.toJSON.apply(this, arguments);
                if (this.relations) {
                    _.each(this.relations, function(relation) {
                        var attr = this.attributes[relation.key];
                        if (attr) {
                            aJson = attr.toJSON(options);
                            json[relation.key] = _.isArray(aJson) ? _.compact(aJson) : aJson;
                        }
                    }, this);
                }
                delete this.visited;
            }
            return json;
        },
        clone: function() {
            return new this.constructor(this.toJSON());
        },
        getAttr: function(path) {
            var result = this, attrs = getPathArray(path), key, i;
            if (_.size(attrs) < 1) return;
            for (i = 0; i < attrs.length; i++) {
                key = attrs[i];
                if (!result) break;
                result = result instanceof BackboneCollection && !isNaN(key) ? result.at(key) : result.attributes[key];
            }
            return result;
        }
    });
    var delimiters = /[^\.\[\]]+/g;
    var getPathArray = function(path) {
        if (path === "") return [ "" ];
        return _.isString(path) ? path.match(delimiters) : path || [];
    };
}).call(this);

jQuery.fn.sortElements = function() {
    var sort = [].sort;
    return function(comparator, getSortable) {
        getSortable = getSortable || function() {
            return this;
        };
        var placements = this.map(function() {
            var sortElement = getSortable.call(this), parentNode = sortElement.parentNode, nextSibling = parentNode.insertBefore(document.createTextNode(""), sortElement.nextSibling);
            return function() {
                if (parentNode === this) {
                    throw new Error("You can't sort elements if any one is a descendant of another.");
                }
                parentNode.insertBefore(this, nextSibling);
                parentNode.removeChild(nextSibling);
            };
        });
        return sort.call(this, comparator).each(function(i) {
            placements[i].call(getSortable.call(this));
        });
    };
}();